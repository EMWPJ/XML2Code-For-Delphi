unit KMLBase;

interface

uses
  Windows, SysUtils, Types, Classes, Variants, Generics.Collections, Dialogs, Controls, ExtCtrls,
  XMLCore, XMLDoc, XMLIntf, XMLLeafTypes, TeeTree, Menus, XMLInspector;


type

  TKML = class;
  TKMLDocument = class;
  TKMLFolder = class;
  TKMLPlacemark = class;
  TKMLGeometry = class;
  TKMLMultiGeometry = class;
  TKMLPoint = class;
  TKMLPolygon = class;
  TKMLBoundary = class;
  TKMLLinearRing = class;
  TKMLLineString = class;
  TKMLLookAt = class;
  TKMLLatLonBox = class;
  TKMLGroundOverlay = class;
  TKMLExtendedData = class;
  TKMLData = class;
  TKMLSize = class;
  TKMLStyle = class;
  TKMLIconStyle = class;
  TKMLIcon = class;
  TKMLLineStyle = class;
  TKMLBalloonStyle = class;
  TKMLStyleMap = class;
  TKMLScreenOverlay = class;
  TKMLPair = class;

  TKML = class(TXMLTreeNode)
  private
    FXmlns: String;
    FXmlnsExsit: Boolean;
    FDocument: TKMLDocument;
    FFolders: TList<TKMLFolder>;
    procedure SetXmlns(const _Value: String);
    procedure SetDocument(const _Value: TKMLDocument);
    procedure SetFolders(const _Value: TList<TKMLFolder>);
    function GetFolder(Index: Integer): TKMLFolder;
    procedure SetFolder(Index: Integer; const _Value: TKMLFolder);
  protected
    procedure FromXML(node: IXMLNode); override;
    function ToXML(par: IXMLNode; pt: string = ''): IXMLNode; override;
    procedure AddXmlnsEvent(Sender: TObject);
    procedure AddFolderEvent(Sender: TObject);
    procedure AfterCreate; override;
  public
    constructor Create(par: TXML = nil);
    destructor Destroy; override;
    procedure CopyFrom(source: TKML);
    procedure ToTree; override;
    procedure ToPopupMenu(Sender: TObject); override;
    procedure ToInspector(ins: TObject); override;
    procedure PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False); override;
    procedure ChildDeleteEvent(del: TXMLTreeNode); override;
    procedure SetXMLProperty(Index: Integer; _Value: String); override;
    function AddXmlns: String;
    procedure XmlnsRemove;
    function AddFolder: TKMLFolder;
    procedure FolderClear;
    function FolderCount: Integer;
    procedure RemoveFolder(_Value: TKMLFolder);
    procedure DeleteFolder(Index: Integer);
    property Xmlns: String read FXmlns write SetXmlns;
    property Document: TKMLDocument read FDocument write SetDocument;
    property Folders: TList<TKMLFolder> read FFolders write SetFolders;
    property Folder[Index: Integer]: TKMLFolder read GetFolder write SetFolder;
    property XmlnsExsit: Boolean read FXmlnsExsit;
  end;

  TKMLDocument = class(TXMLTreeNode)
  private
    FName: String;
    FNameExsit: Boolean;
    FOpen: Integer;
    FOpenExsit: Boolean;
    FVisibility: Integer;
    FVisibilityExsit: Boolean;
    FDescription: String;
    FDescriptionExsit: Boolean;
    FLookAt: TKMLLookAt;
    FLookAtExsit: Boolean;
    FStyleMaps: TList<TKMLStyleMap>;
    FStyles: TList<TKMLStyle>;
    FPlacemarks: TList<TKMLPlacemark>;
    FFolders: TList<TKMLFolder>;
    procedure SetName(const _Value: String);
    procedure SetOpen(const _Value: Integer);
    procedure SetVisibility(const _Value: Integer);
    procedure SetDescription(const _Value: String);
    procedure SetLookAt(const _Value: TKMLLookAt);
    procedure SetStyleMaps(const _Value: TList<TKMLStyleMap>);
    function GetStyleMap(Index: Integer): TKMLStyleMap;
    procedure SetStyleMap(Index: Integer; const _Value: TKMLStyleMap);
    procedure SetStyles(const _Value: TList<TKMLStyle>);
    function GetStyle(Index: Integer): TKMLStyle;
    procedure SetStyle(Index: Integer; const _Value: TKMLStyle);
    procedure SetPlacemarks(const _Value: TList<TKMLPlacemark>);
    function GetPlacemark(Index: Integer): TKMLPlacemark;
    procedure SetPlacemark(Index: Integer; const _Value: TKMLPlacemark);
    procedure SetFolders(const _Value: TList<TKMLFolder>);
    function GetFolder(Index: Integer): TKMLFolder;
    procedure SetFolder(Index: Integer; const _Value: TKMLFolder);
  protected
    procedure FromXML(node: IXMLNode); override;
    function ToXML(par: IXMLNode; pt: string = ''): IXMLNode; override;
    procedure AddNameEvent(Sender: TObject);
    procedure AddOpenEvent(Sender: TObject);
    procedure AddVisibilityEvent(Sender: TObject);
    procedure AddDescriptionEvent(Sender: TObject);
    procedure AddLookAtEvent(Sender: TObject);
    procedure AddStyleMapEvent(Sender: TObject);
    procedure AddStyleEvent(Sender: TObject);
    procedure AddPlacemarkEvent(Sender: TObject);
    procedure AddFolderEvent(Sender: TObject);
    procedure AfterCreate; override;
  public
    constructor Create(par: TXML = nil);
    destructor Destroy; override;
    procedure CopyFrom(source: TKMLDocument);
    procedure ToTree; override;
    procedure ToPopupMenu(Sender: TObject); override;
    procedure ToInspector(ins: TObject); override;
    procedure PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False); override;
    procedure ChildDeleteEvent(del: TXMLTreeNode); override;
    procedure SetXMLProperty(Index: Integer; _Value: String); override;
    function AddName: String;
    procedure NameRemove;
    function AddOpen: Integer;
    procedure OpenRemove;
    function AddVisibility: Integer;
    procedure VisibilityRemove;
    function AddDescription: String;
    procedure DescriptionRemove;
    function AddLookAt: TKMLLookAt;
    procedure LookAtRemove;
    function AddStyleMap: TKMLStyleMap;
    procedure StyleMapClear;
    function StyleMapCount: Integer;
    procedure RemoveStyleMap(_Value: TKMLStyleMap);
    procedure DeleteStyleMap(Index: Integer);
    function AddStyle: TKMLStyle;
    procedure StyleClear;
    function StyleCount: Integer;
    procedure RemoveStyle(_Value: TKMLStyle);
    procedure DeleteStyle(Index: Integer);
    function AddPlacemark: TKMLPlacemark;
    procedure PlacemarkClear;
    function PlacemarkCount: Integer;
    procedure RemovePlacemark(_Value: TKMLPlacemark);
    procedure DeletePlacemark(Index: Integer);
    function AddFolder: TKMLFolder;
    procedure FolderClear;
    function FolderCount: Integer;
    procedure RemoveFolder(_Value: TKMLFolder);
    procedure DeleteFolder(Index: Integer);
    property Name: String read FName write SetName;
    property Open: Integer read FOpen write SetOpen;
    property Visibility: Integer read FVisibility write SetVisibility;
    property Description: String read FDescription write SetDescription;
    property LookAt: TKMLLookAt read FLookAt write SetLookAt;
    property StyleMaps: TList<TKMLStyleMap> read FStyleMaps write SetStyleMaps;
    property StyleMap[Index: Integer]: TKMLStyleMap read GetStyleMap write SetStyleMap;
    property Styles: TList<TKMLStyle> read FStyles write SetStyles;
    property Style[Index: Integer]: TKMLStyle read GetStyle write SetStyle;
    property Placemarks: TList<TKMLPlacemark> read FPlacemarks write SetPlacemarks;
    property Placemark[Index: Integer]: TKMLPlacemark read GetPlacemark write SetPlacemark;
    property Folders: TList<TKMLFolder> read FFolders write SetFolders;
    property Folder[Index: Integer]: TKMLFolder read GetFolder write SetFolder;
    property NameExsit: Boolean read FNameExsit;
    property OpenExsit: Boolean read FOpenExsit;
    property VisibilityExsit: Boolean read FVisibilityExsit;
    property DescriptionExsit: Boolean read FDescriptionExsit;
    property LookAtExsit: Boolean read FLookAtExsit;
  end;

  TKMLFolder = class(TXMLTreeNode)
  private
    FName: String;
    FNameExsit: Boolean;
    FOpen: Integer;
    FOpenExsit: Boolean;
    FVisibility: Integer;
    FVisibilityExsit: Boolean;
    FDescription: String;
    FDescriptionExsit: Boolean;
    FLookAt: TKMLLookAt;
    FLookAtExsit: Boolean;
    FDocument: TKMLDocument;
    FDocumentExsit: Boolean;
    FGroundOverlays: TList<TKMLGroundOverlay>;
    FPlacemarks: TList<TKMLPlacemark>;
    FScreenOverlays: TList<TKMLScreenOverlay>;
    FFolders: TList<TKMLFolder>;
    procedure SetName(const _Value: String);
    procedure SetOpen(const _Value: Integer);
    procedure SetVisibility(const _Value: Integer);
    procedure SetDescription(const _Value: String);
    procedure SetLookAt(const _Value: TKMLLookAt);
    procedure SetDocument(const _Value: TKMLDocument);
    procedure SetGroundOverlays(const _Value: TList<TKMLGroundOverlay>);
    function GetGroundOverlay(Index: Integer): TKMLGroundOverlay;
    procedure SetGroundOverlay(Index: Integer; const _Value: TKMLGroundOverlay);
    procedure SetPlacemarks(const _Value: TList<TKMLPlacemark>);
    function GetPlacemark(Index: Integer): TKMLPlacemark;
    procedure SetPlacemark(Index: Integer; const _Value: TKMLPlacemark);
    procedure SetScreenOverlays(const _Value: TList<TKMLScreenOverlay>);
    function GetScreenOverlay(Index: Integer): TKMLScreenOverlay;
    procedure SetScreenOverlay(Index: Integer; const _Value: TKMLScreenOverlay);
    procedure SetFolders(const _Value: TList<TKMLFolder>);
    function GetFolder(Index: Integer): TKMLFolder;
    procedure SetFolder(Index: Integer; const _Value: TKMLFolder);
  protected
    procedure FromXML(node: IXMLNode); override;
    function ToXML(par: IXMLNode; pt: string = ''): IXMLNode; override;
    procedure AddNameEvent(Sender: TObject);
    procedure AddOpenEvent(Sender: TObject);
    procedure AddVisibilityEvent(Sender: TObject);
    procedure AddDescriptionEvent(Sender: TObject);
    procedure AddLookAtEvent(Sender: TObject);
    procedure AddDocumentEvent(Sender: TObject);
    procedure AddGroundOverlayEvent(Sender: TObject);
    procedure AddPlacemarkEvent(Sender: TObject);
    procedure AddScreenOverlayEvent(Sender: TObject);
    procedure AddFolderEvent(Sender: TObject);
    procedure AfterCreate; override;
  public
    constructor Create(par: TXML = nil);
    destructor Destroy; override;
    procedure CopyFrom(source: TKMLFolder);
    procedure ToTree; override;
    procedure ToPopupMenu(Sender: TObject); override;
    procedure ToInspector(ins: TObject); override;
    procedure PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False); override;
    procedure ChildDeleteEvent(del: TXMLTreeNode); override;
    procedure SetXMLProperty(Index: Integer; _Value: String); override;
    function AddName: String;
    procedure NameRemove;
    function AddOpen: Integer;
    procedure OpenRemove;
    function AddVisibility: Integer;
    procedure VisibilityRemove;
    function AddDescription: String;
    procedure DescriptionRemove;
    function AddLookAt: TKMLLookAt;
    procedure LookAtRemove;
    function AddDocument: TKMLDocument;
    procedure DocumentRemove;
    function AddGroundOverlay: TKMLGroundOverlay;
    procedure GroundOverlayClear;
    function GroundOverlayCount: Integer;
    procedure RemoveGroundOverlay(_Value: TKMLGroundOverlay);
    procedure DeleteGroundOverlay(Index: Integer);
    function AddPlacemark: TKMLPlacemark;
    procedure PlacemarkClear;
    function PlacemarkCount: Integer;
    procedure RemovePlacemark(_Value: TKMLPlacemark);
    procedure DeletePlacemark(Index: Integer);
    function AddScreenOverlay: TKMLScreenOverlay;
    procedure ScreenOverlayClear;
    function ScreenOverlayCount: Integer;
    procedure RemoveScreenOverlay(_Value: TKMLScreenOverlay);
    procedure DeleteScreenOverlay(Index: Integer);
    function AddFolder: TKMLFolder;
    procedure FolderClear;
    function FolderCount: Integer;
    procedure RemoveFolder(_Value: TKMLFolder);
    procedure DeleteFolder(Index: Integer);
    property Name: String read FName write SetName;
    property Open: Integer read FOpen write SetOpen;
    property Visibility: Integer read FVisibility write SetVisibility;
    property Description: String read FDescription write SetDescription;
    property LookAt: TKMLLookAt read FLookAt write SetLookAt;
    property Document: TKMLDocument read FDocument write SetDocument;
    property GroundOverlays: TList<TKMLGroundOverlay> read FGroundOverlays write SetGroundOverlays;
    property GroundOverlay[Index: Integer]: TKMLGroundOverlay read GetGroundOverlay write SetGroundOverlay;
    property Placemarks: TList<TKMLPlacemark> read FPlacemarks write SetPlacemarks;
    property Placemark[Index: Integer]: TKMLPlacemark read GetPlacemark write SetPlacemark;
    property ScreenOverlays: TList<TKMLScreenOverlay> read FScreenOverlays write SetScreenOverlays;
    property ScreenOverlay[Index: Integer]: TKMLScreenOverlay read GetScreenOverlay write SetScreenOverlay;
    property Folders: TList<TKMLFolder> read FFolders write SetFolders;
    property Folder[Index: Integer]: TKMLFolder read GetFolder write SetFolder;
    property NameExsit: Boolean read FNameExsit;
    property OpenExsit: Boolean read FOpenExsit;
    property VisibilityExsit: Boolean read FVisibilityExsit;
    property DescriptionExsit: Boolean read FDescriptionExsit;
    property LookAtExsit: Boolean read FLookAtExsit;
    property DocumentExsit: Boolean read FDocumentExsit;
  end;

  TKMLPlacemark = class(TXMLTreeNode)
  private
    FName: String;
    FNameExsit: Boolean;
    FVisibility: Integer;
    FVisibilityExsit: Boolean;
    FDescription: String;
    FDescriptionExsit: Boolean;
    FLookAt: TKMLLookAt;
    FLookAtExsit: Boolean;
    FStyleUrl: String;
    FStyleUrlExsit: Boolean;
    FGeometry: TKMLGeometry;
    FGeometryExsit: Boolean;
    FExtendedData: TKMLExtendedData;
    FExtendedDataExsit: Boolean;
    procedure SetName(const _Value: String);
    procedure SetVisibility(const _Value: Integer);
    procedure SetDescription(const _Value: String);
    procedure SetLookAt(const _Value: TKMLLookAt);
    procedure SetStyleUrl(const _Value: String);
    procedure SetGeometry(const _Value: TKMLGeometry);
    procedure SetExtendedData(const _Value: TKMLExtendedData);
  protected
    procedure FromXML(node: IXMLNode); override;
    function ToXML(par: IXMLNode; pt: string = ''): IXMLNode; override;
    procedure AddNameEvent(Sender: TObject);
    procedure AddVisibilityEvent(Sender: TObject);
    procedure AddDescriptionEvent(Sender: TObject);
    procedure AddLookAtEvent(Sender: TObject);
    procedure AddStyleUrlEvent(Sender: TObject);
    procedure AddPointEvent(Sender: TObject);
    procedure AddPolygonEvent(Sender: TObject);
    procedure AddLinearRingEvent(Sender: TObject);
    procedure AddLineStringEvent(Sender: TObject);
    procedure AddMultiGeometryEvent(Sender: TObject);
    procedure AddExtendedDataEvent(Sender: TObject);
    procedure AfterCreate; override;
  public
    constructor Create(par: TXML = nil);
    destructor Destroy; override;
    procedure CopyFrom(source: TKMLPlacemark);
    procedure ToTree; override;
    procedure ToPopupMenu(Sender: TObject); override;
    procedure ToInspector(ins: TObject); override;
    procedure PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False); override;
    procedure ChildDeleteEvent(del: TXMLTreeNode); override;
    procedure SetXMLProperty(Index: Integer; _Value: String); override;
    function AddName: String;
    procedure NameRemove;
    function AddVisibility: Integer;
    procedure VisibilityRemove;
    function AddDescription: String;
    procedure DescriptionRemove;
    function AddLookAt: TKMLLookAt;
    procedure LookAtRemove;
    function AddStyleUrl: String;
    procedure StyleUrlRemove;
    function AddPoint: TKMLPoint;
    function AddPolygon: TKMLPolygon;
    function AddLinearRing: TKMLLinearRing;
    function AddLineString: TKMLLineString;
    function AddMultiGeometry: TKMLMultiGeometry;
    procedure GeometryRemove;
    function AddExtendedData: TKMLExtendedData;
    procedure ExtendedDataRemove;
    property Name: String read FName write SetName;
    property Visibility: Integer read FVisibility write SetVisibility;
    property Description: String read FDescription write SetDescription;
    property LookAt: TKMLLookAt read FLookAt write SetLookAt;
    property StyleUrl: String read FStyleUrl write SetStyleUrl;
    property Geometry: TKMLGeometry read FGeometry write SetGeometry;
    property ExtendedData: TKMLExtendedData read FExtendedData write SetExtendedData;
    property NameExsit: Boolean read FNameExsit;
    property VisibilityExsit: Boolean read FVisibilityExsit;
    property DescriptionExsit: Boolean read FDescriptionExsit;
    property LookAtExsit: Boolean read FLookAtExsit;
    property StyleUrlExsit: Boolean read FStyleUrlExsit;
    property GeometryExsit: Boolean read FGeometryExsit;
    property ExtendedDataExsit: Boolean read FExtendedDataExsit;
  end;

  TKMLGeometry = class abstract(TXMLTreeNode)
  private
  protected
    procedure FromXML(node: IXMLNode); virtual;
    function ToXML(par: IXMLNode; pt: string = ''): IXMLNode; virtual;
    function AppendToXML(node: IXMLNode; pt: string = ''): IXMLNode;
    procedure AfterCreate; override;
  public
    constructor Create(par: TXML = nil);
    destructor Destroy; override;
    procedure CopyFrom(source: TKMLGeometry); virtual;
    procedure ToTree; override;
    procedure ToPopupMenu(Sender: TObject); override;
    procedure ToInspector(ins: TObject); override;
    procedure PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False); override;
    procedure ChildDeleteEvent(del: TXMLTreeNode); override;
    procedure SetXMLProperty(Index: Integer; _Value: String); override;
  end;

  TKMLMultiGeometry = class(TKMLGeometry)
  private
    FGeometrys: TList<TKMLGeometry>;
    procedure SetGeometrys(const _Value: TList<TKMLGeometry>);
    function GetGeometry(Index: Integer): TKMLGeometry;
    procedure SetGeometry(Index: Integer; const _Value: TKMLGeometry);
  protected
    procedure FromXML(node: IXMLNode); override;
    function ToXML(par: IXMLNode; pt: string = ''): IXMLNode; override;
    procedure AddPointEvent(Sender: TObject);
    procedure AddPolygonEvent(Sender: TObject);
    procedure AddLinearRingEvent(Sender: TObject);
    procedure AddLineStringEvent(Sender: TObject);
    procedure AddMultiGeometryEvent(Sender: TObject);
    procedure AfterCreate; override;
  public
    constructor Create(par: TXML = nil);
    destructor Destroy; override;
    procedure CopyFrom(source: TKMLGeometry); override;
    procedure ToTree; override;
    procedure ToPopupMenu(Sender: TObject); override;
    procedure ToInspector(ins: TObject); override;
    procedure PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False); override;
    procedure ChildDeleteEvent(del: TXMLTreeNode); override;
    procedure SetXMLProperty(Index: Integer; _Value: String); override;
    function AddPoint: TKMLPoint;
    function AddPolygon: TKMLPolygon;
    function AddLinearRing: TKMLLinearRing;
    function AddLineString: TKMLLineString;
    function AddMultiGeometry: TKMLMultiGeometry;
    procedure GeometryClear;
    function GeometryCount: Integer;
    procedure RemoveGeometry(_Value: TKMLGeometry);
    procedure DeleteGeometry(Index: Integer);
    property Geometrys: TList<TKMLGeometry> read FGeometrys write SetGeometrys;
    property Geometry[Index: Integer]: TKMLGeometry read GetGeometry write SetGeometry;
  end;

  TKMLPoint = class(TKMLGeometry)
  private
    FExtrude: String;
    FExtrudeExsit: Boolean;
    FAltitudeMode: String;
    FAltitudeModeExsit: Boolean;
    FCoordinates: ArrayCoordinates;
    procedure SetExtrude(const _Value: String);
    procedure SetAltitudeMode(const _Value: String);
    procedure SetCoordinates(const _Value: ArrayCoordinates);
  protected
    procedure FromXML(node: IXMLNode); override;
    function ToXML(par: IXMLNode; pt: string = ''): IXMLNode; override;
    procedure AddExtrudeEvent(Sender: TObject);
    procedure AddAltitudeModeEvent(Sender: TObject);
    procedure AfterCreate; override;
  public
    constructor Create(par: TXML = nil);
    destructor Destroy; override;
    procedure CopyFrom(source: TKMLGeometry); override;
    procedure ToTree; override;
    procedure ToPopupMenu(Sender: TObject); override;
    procedure ToInspector(ins: TObject); override;
    procedure PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False); override;
    procedure ChildDeleteEvent(del: TXMLTreeNode); override;
    procedure SetXMLProperty(Index: Integer; _Value: String); override;
    function AddExtrude: String;
    procedure ExtrudeRemove;
    function AddAltitudeMode: String;
    procedure AltitudeModeRemove;
    property Extrude: String read FExtrude write SetExtrude;
    property AltitudeMode: String read FAltitudeMode write SetAltitudeMode;
    property Coordinates: ArrayCoordinates read FCoordinates write SetCoordinates;
    property ExtrudeExsit: Boolean read FExtrudeExsit;
    property AltitudeModeExsit: Boolean read FAltitudeModeExsit;
  end;

  TKMLPolygon = class(TKMLGeometry)
  private
    FExtrude: String;
    FExtrudeExsit: Boolean;
    FAltitudeMode: String;
    FAltitudeModeExsit: Boolean;
    FOuterBoundaryIss: TList<TKMLBoundary>;
    FInnerBoundaryIss: TList<TKMLBoundary>;
    FTessellate: String;
    FTessellateExsit: Boolean;
    procedure SetExtrude(const _Value: String);
    procedure SetAltitudeMode(const _Value: String);
    procedure SetOuterBoundaryIss(const _Value: TList<TKMLBoundary>);
    function GetOuterBoundaryIs(Index: Integer): TKMLBoundary;
    procedure SetOuterBoundaryIs(Index: Integer; const _Value: TKMLBoundary);
    procedure SetInnerBoundaryIss(const _Value: TList<TKMLBoundary>);
    function GetInnerBoundaryIs(Index: Integer): TKMLBoundary;
    procedure SetInnerBoundaryIs(Index: Integer; const _Value: TKMLBoundary);
    procedure SetTessellate(const _Value: String);
  protected
    procedure FromXML(node: IXMLNode); override;
    function ToXML(par: IXMLNode; pt: string = ''): IXMLNode; override;
    procedure AddExtrudeEvent(Sender: TObject);
    procedure AddAltitudeModeEvent(Sender: TObject);
    procedure AddOuterBoundaryIsEvent(Sender: TObject);
    procedure AddInnerBoundaryIsEvent(Sender: TObject);
    procedure AddTessellateEvent(Sender: TObject);
    procedure AfterCreate; override;
  public
    constructor Create(par: TXML = nil);
    destructor Destroy; override;
    procedure CopyFrom(source: TKMLGeometry); override;
    procedure ToTree; override;
    procedure ToPopupMenu(Sender: TObject); override;
    procedure ToInspector(ins: TObject); override;
    procedure PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False); override;
    procedure ChildDeleteEvent(del: TXMLTreeNode); override;
    procedure SetXMLProperty(Index: Integer; _Value: String); override;
    function AddExtrude: String;
    procedure ExtrudeRemove;
    function AddAltitudeMode: String;
    procedure AltitudeModeRemove;
    function AddOuterBoundaryIs: TKMLBoundary;
    procedure OuterBoundaryIsClear;
    function OuterBoundaryIsCount: Integer;
    procedure RemoveOuterBoundaryIs(_Value: TKMLBoundary);
    procedure DeleteOuterBoundaryIs(Index: Integer);
    function AddInnerBoundaryIs: TKMLBoundary;
    procedure InnerBoundaryIsClear;
    function InnerBoundaryIsCount: Integer;
    procedure RemoveInnerBoundaryIs(_Value: TKMLBoundary);
    procedure DeleteInnerBoundaryIs(Index: Integer);
    function AddTessellate: String;
    procedure TessellateRemove;
    property Extrude: String read FExtrude write SetExtrude;
    property AltitudeMode: String read FAltitudeMode write SetAltitudeMode;
    property OuterBoundaryIss: TList<TKMLBoundary> read FOuterBoundaryIss write SetOuterBoundaryIss;
    property OuterBoundaryIs[Index: Integer]: TKMLBoundary read GetOuterBoundaryIs write SetOuterBoundaryIs;
    property InnerBoundaryIss: TList<TKMLBoundary> read FInnerBoundaryIss write SetInnerBoundaryIss;
    property InnerBoundaryIs[Index: Integer]: TKMLBoundary read GetInnerBoundaryIs write SetInnerBoundaryIs;
    property Tessellate: String read FTessellate write SetTessellate;
    property ExtrudeExsit: Boolean read FExtrudeExsit;
    property AltitudeModeExsit: Boolean read FAltitudeModeExsit;
    property TessellateExsit: Boolean read FTessellateExsit;
  end;

  TKMLBoundary = class(TXMLTreeNode)
  private
    FLinearRing: TKMLLinearRing;
    procedure SetLinearRing(const _Value: TKMLLinearRing);
  protected
    procedure FromXML(node: IXMLNode); override;
    function ToXML(par: IXMLNode; pt: string = ''): IXMLNode; override;
    procedure AfterCreate; override;
  public
    constructor Create(par: TXML = nil);
    destructor Destroy; override;
    procedure CopyFrom(source: TKMLBoundary);
    procedure ToTree; override;
    procedure ToPopupMenu(Sender: TObject); override;
    procedure ToInspector(ins: TObject); override;
    procedure PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False); override;
    procedure ChildDeleteEvent(del: TXMLTreeNode); override;
    procedure SetXMLProperty(Index: Integer; _Value: String); override;
    property LinearRing: TKMLLinearRing read FLinearRing write SetLinearRing;
  end;

  TKMLLinearRing = class(TKMLGeometry)
  private
    FCoordinates: ArrayCoordinates;
    procedure SetCoordinates(const _Value: ArrayCoordinates);
  protected
    procedure FromXML(node: IXMLNode); override;
    function ToXML(par: IXMLNode; pt: string = ''): IXMLNode; override;
    procedure AfterCreate; override;
  public
    constructor Create(par: TXML = nil);
    destructor Destroy; override;
    procedure CopyFrom(source: TKMLGeometry); override;
    procedure ToTree; override;
    procedure ToPopupMenu(Sender: TObject); override;
    procedure ToInspector(ins: TObject); override;
    procedure PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False); override;
    procedure ChildDeleteEvent(del: TXMLTreeNode); override;
    procedure SetXMLProperty(Index: Integer; _Value: String); override;
    property Coordinates: ArrayCoordinates read FCoordinates write SetCoordinates;
  end;

  TKMLLineString = class(TKMLGeometry)
  private
    FTessellate: String;
    FTessellateExsit: Boolean;
    FAltitudeMode: String;
    FAltitudeModeExsit: Boolean;
    FExtrude: String;
    FExtrudeExsit: Boolean;
    FCoordinates: ArrayCoordinates;
    procedure SetTessellate(const _Value: String);
    procedure SetAltitudeMode(const _Value: String);
    procedure SetExtrude(const _Value: String);
    procedure SetCoordinates(const _Value: ArrayCoordinates);
  protected
    procedure FromXML(node: IXMLNode); override;
    function ToXML(par: IXMLNode; pt: string = ''): IXMLNode; override;
    procedure AddTessellateEvent(Sender: TObject);
    procedure AddAltitudeModeEvent(Sender: TObject);
    procedure AddExtrudeEvent(Sender: TObject);
    procedure AfterCreate; override;
  public
    constructor Create(par: TXML = nil);
    destructor Destroy; override;
    procedure CopyFrom(source: TKMLGeometry); override;
    procedure ToTree; override;
    procedure ToPopupMenu(Sender: TObject); override;
    procedure ToInspector(ins: TObject); override;
    procedure PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False); override;
    procedure ChildDeleteEvent(del: TXMLTreeNode); override;
    procedure SetXMLProperty(Index: Integer; _Value: String); override;
    function AddTessellate: String;
    procedure TessellateRemove;
    function AddAltitudeMode: String;
    procedure AltitudeModeRemove;
    function AddExtrude: String;
    procedure ExtrudeRemove;
    property Tessellate: String read FTessellate write SetTessellate;
    property AltitudeMode: String read FAltitudeMode write SetAltitudeMode;
    property Extrude: String read FExtrude write SetExtrude;
    property Coordinates: ArrayCoordinates read FCoordinates write SetCoordinates;
    property TessellateExsit: Boolean read FTessellateExsit;
    property AltitudeModeExsit: Boolean read FAltitudeModeExsit;
    property ExtrudeExsit: Boolean read FExtrudeExsit;
  end;

  TKMLLookAt = class(TXMLTreeNode)
  private
    FLongitude: Double;
    FLongitudeExsit: Boolean;
    FLatitude: Double;
    FLatitudeExsit: Boolean;
    FAltitude: Double;
    FAltitudeExsit: Boolean;
    FHeading: Double;
    FHeadingExsit: Boolean;
    FTilt: Double;
    FTiltExsit: Boolean;
    FRange: Double;
    FRangeExsit: Boolean;
    procedure SetLongitude(const _Value: Double);
    procedure SetLatitude(const _Value: Double);
    procedure SetAltitude(const _Value: Double);
    procedure SetHeading(const _Value: Double);
    procedure SetTilt(const _Value: Double);
    procedure SetRange(const _Value: Double);
  protected
    procedure FromXML(node: IXMLNode); override;
    function ToXML(par: IXMLNode; pt: string = ''): IXMLNode; override;
    procedure AddLongitudeEvent(Sender: TObject);
    procedure AddLatitudeEvent(Sender: TObject);
    procedure AddAltitudeEvent(Sender: TObject);
    procedure AddHeadingEvent(Sender: TObject);
    procedure AddTiltEvent(Sender: TObject);
    procedure AddRangeEvent(Sender: TObject);
    procedure AfterCreate; override;
  public
    constructor Create(par: TXML = nil);
    destructor Destroy; override;
    procedure CopyFrom(source: TKMLLookAt);
    procedure ToTree; override;
    procedure ToPopupMenu(Sender: TObject); override;
    procedure ToInspector(ins: TObject); override;
    procedure PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False); override;
    procedure ChildDeleteEvent(del: TXMLTreeNode); override;
    procedure SetXMLProperty(Index: Integer; _Value: String); override;
    function AddLongitude: Double;
    procedure LongitudeRemove;
    function AddLatitude: Double;
    procedure LatitudeRemove;
    function AddAltitude: Double;
    procedure AltitudeRemove;
    function AddHeading: Double;
    procedure HeadingRemove;
    function AddTilt: Double;
    procedure TiltRemove;
    function AddRange: Double;
    procedure RangeRemove;
    property Longitude: Double read FLongitude write SetLongitude;
    property Latitude: Double read FLatitude write SetLatitude;
    property Altitude: Double read FAltitude write SetAltitude;
    property Heading: Double read FHeading write SetHeading;
    property Tilt: Double read FTilt write SetTilt;
    property Range: Double read FRange write SetRange;
    property LongitudeExsit: Boolean read FLongitudeExsit;
    property LatitudeExsit: Boolean read FLatitudeExsit;
    property AltitudeExsit: Boolean read FAltitudeExsit;
    property HeadingExsit: Boolean read FHeadingExsit;
    property TiltExsit: Boolean read FTiltExsit;
    property RangeExsit: Boolean read FRangeExsit;
  end;

  TKMLLatLonBox = class(TXMLTreeNode)
  private
    FNorth: Double;
    FSouth: Double;
    FEast: Double;
    FWest: Double;
    FRotation: Double;
    procedure SetNorth(const _Value: Double);
    procedure SetSouth(const _Value: Double);
    procedure SetEast(const _Value: Double);
    procedure SetWest(const _Value: Double);
    procedure SetRotation(const _Value: Double);
  protected
    procedure FromXML(node: IXMLNode); override;
    function ToXML(par: IXMLNode; pt: string = ''): IXMLNode; override;
    procedure AfterCreate; override;
  public
    constructor Create(par: TXML = nil);
    destructor Destroy; override;
    procedure CopyFrom(source: TKMLLatLonBox);
    procedure ToTree; override;
    procedure ToPopupMenu(Sender: TObject); override;
    procedure ToInspector(ins: TObject); override;
    procedure PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False); override;
    procedure ChildDeleteEvent(del: TXMLTreeNode); override;
    procedure SetXMLProperty(Index: Integer; _Value: String); override;
    property North: Double read FNorth write SetNorth;
    property South: Double read FSouth write SetSouth;
    property East: Double read FEast write SetEast;
    property West: Double read FWest write SetWest;
    property Rotation: Double read FRotation write SetRotation;
  end;

  TKMLGroundOverlay = class(TXMLTreeNode)
  private
    FName: String;
    FNameExsit: Boolean;
    FVisibility: Integer;
    FVisibilityExsit: Boolean;
    FDescription: String;
    FDescriptionExsit: Boolean;
    FLookAt: TKMLLookAt;
    FLookAtExsit: Boolean;
    FIcon: TKMLIcon;
    FIconExsit: Boolean;
    FLatLonBox: TKMLLatLonBox;
    FLatLonBoxExsit: Boolean;
    procedure SetName(const _Value: String);
    procedure SetVisibility(const _Value: Integer);
    procedure SetDescription(const _Value: String);
    procedure SetLookAt(const _Value: TKMLLookAt);
    procedure SetIcon(const _Value: TKMLIcon);
    procedure SetLatLonBox(const _Value: TKMLLatLonBox);
  protected
    procedure FromXML(node: IXMLNode); override;
    function ToXML(par: IXMLNode; pt: string = ''): IXMLNode; override;
    procedure AddNameEvent(Sender: TObject);
    procedure AddVisibilityEvent(Sender: TObject);
    procedure AddDescriptionEvent(Sender: TObject);
    procedure AddLookAtEvent(Sender: TObject);
    procedure AddIconEvent(Sender: TObject);
    procedure AddLatLonBoxEvent(Sender: TObject);
    procedure AfterCreate; override;
  public
    constructor Create(par: TXML = nil);
    destructor Destroy; override;
    procedure CopyFrom(source: TKMLGroundOverlay);
    procedure ToTree; override;
    procedure ToPopupMenu(Sender: TObject); override;
    procedure ToInspector(ins: TObject); override;
    procedure PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False); override;
    procedure ChildDeleteEvent(del: TXMLTreeNode); override;
    procedure SetXMLProperty(Index: Integer; _Value: String); override;
    function AddName: String;
    procedure NameRemove;
    function AddVisibility: Integer;
    procedure VisibilityRemove;
    function AddDescription: String;
    procedure DescriptionRemove;
    function AddLookAt: TKMLLookAt;
    procedure LookAtRemove;
    function AddIcon: TKMLIcon;
    procedure IconRemove;
    function AddLatLonBox: TKMLLatLonBox;
    procedure LatLonBoxRemove;
    property Name: String read FName write SetName;
    property Visibility: Integer read FVisibility write SetVisibility;
    property Description: String read FDescription write SetDescription;
    property LookAt: TKMLLookAt read FLookAt write SetLookAt;
    property Icon: TKMLIcon read FIcon write SetIcon;
    property LatLonBox: TKMLLatLonBox read FLatLonBox write SetLatLonBox;
    property NameExsit: Boolean read FNameExsit;
    property VisibilityExsit: Boolean read FVisibilityExsit;
    property DescriptionExsit: Boolean read FDescriptionExsit;
    property LookAtExsit: Boolean read FLookAtExsit;
    property IconExsit: Boolean read FIconExsit;
    property LatLonBoxExsit: Boolean read FLatLonBoxExsit;
  end;

  TKMLExtendedData = class(TXMLTreeNode)
  private
    FDatas: TList<TKMLData>;
    procedure SetDatas(const _Value: TList<TKMLData>);
    function GetData(Index: Integer): TKMLData;
    procedure SetData(Index: Integer; const _Value: TKMLData);
  protected
    procedure FromXML(node: IXMLNode); override;
    function ToXML(par: IXMLNode; pt: string = ''): IXMLNode; override;
    procedure AddDataEvent(Sender: TObject);
    procedure AfterCreate; override;
  public
    constructor Create(par: TXML = nil);
    destructor Destroy; override;
    procedure CopyFrom(source: TKMLExtendedData);
    procedure ToTree; override;
    procedure ToPopupMenu(Sender: TObject); override;
    procedure ToInspector(ins: TObject); override;
    procedure PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False); override;
    procedure ChildDeleteEvent(del: TXMLTreeNode); override;
    procedure SetXMLProperty(Index: Integer; _Value: String); override;
    function AddData: TKMLData;
    procedure DataClear;
    function DataCount: Integer;
    procedure RemoveData(_Value: TKMLData);
    procedure DeleteData(Index: Integer);
    property Datas: TList<TKMLData> read FDatas write SetDatas;
    property Data[Index: Integer]: TKMLData read GetData write SetData;
  end;

  TKMLData = class(TXMLTreeNode)
  private
    FName: String;
    FValue: String;
    procedure SetName(const _Value: String);
    procedure SetValue(const _Value: String);
  protected
    procedure FromXML(node: IXMLNode); override;
    function ToXML(par: IXMLNode; pt: string = ''): IXMLNode; override;
    procedure AfterCreate; override;
  public
    constructor Create(par: TXML = nil);
    destructor Destroy; override;
    procedure CopyFrom(source: TKMLData);
    procedure ToTree; override;
    procedure ToPopupMenu(Sender: TObject); override;
    procedure ToInspector(ins: TObject); override;
    procedure PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False); override;
    procedure ChildDeleteEvent(del: TXMLTreeNode); override;
    procedure SetXMLProperty(Index: Integer; _Value: String); override;
    property Name: String read FName write SetName;
    property Value: String read FValue write SetValue;
  end;

  TKMLSize = class(TXMLTreeNode)
  private
    FX: Double;
    FY: Double;
    FXUnits: String;
    FYUnits: String;
    procedure SetX(const _Value: Double);
    procedure SetY(const _Value: Double);
    procedure SetXUnits(const _Value: String);
    procedure SetYUnits(const _Value: String);
  protected
    procedure FromXML(node: IXMLNode); override;
    function ToXML(par: IXMLNode; pt: string = ''): IXMLNode; override;
    procedure AfterCreate; override;
  public
    constructor Create(par: TXML = nil);
    destructor Destroy; override;
    procedure CopyFrom(source: TKMLSize);
    procedure ToTree; override;
    procedure ToPopupMenu(Sender: TObject); override;
    procedure ToInspector(ins: TObject); override;
    procedure PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False); override;
    procedure ChildDeleteEvent(del: TXMLTreeNode); override;
    procedure SetXMLProperty(Index: Integer; _Value: String); override;
    property X: Double read FX write SetX;
    property Y: Double read FY write SetY;
    property XUnits: String read FXUnits write SetXUnits;
    property YUnits: String read FYUnits write SetYUnits;
  end;

  TKMLStyle = class(TXMLTreeNode)
  private
    FID: String;
    FIconStyle: TKMLIconStyle;
    FIconStyleExsit: Boolean;
    FLineStyle: TKMLLineStyle;
    FLineStyleExsit: Boolean;
    FPolyStyle: TKMLLineStyle;
    FPolyStyleExsit: Boolean;
    FBalloonStyle: TKMLBalloonStyle;
    FBalloonStyleExsit: Boolean;
    procedure SetID(const _Value: String);
    procedure SetIconStyle(const _Value: TKMLIconStyle);
    procedure SetLineStyle(const _Value: TKMLLineStyle);
    procedure SetPolyStyle(const _Value: TKMLLineStyle);
    procedure SetBalloonStyle(const _Value: TKMLBalloonStyle);
  protected
    procedure FromXML(node: IXMLNode); override;
    function ToXML(par: IXMLNode; pt: string = ''): IXMLNode; override;
    procedure AddIconStyleEvent(Sender: TObject);
    procedure AddLineStyleEvent(Sender: TObject);
    procedure AddPolyStyleEvent(Sender: TObject);
    procedure AddBalloonStyleEvent(Sender: TObject);
    procedure AfterCreate; override;
  public
    constructor Create(par: TXML = nil);
    destructor Destroy; override;
    procedure CopyFrom(source: TKMLStyle);
    procedure ToTree; override;
    procedure ToPopupMenu(Sender: TObject); override;
    procedure ToInspector(ins: TObject); override;
    procedure PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False); override;
    procedure ChildDeleteEvent(del: TXMLTreeNode); override;
    procedure SetXMLProperty(Index: Integer; _Value: String); override;
    function AddIconStyle: TKMLIconStyle;
    procedure IconStyleRemove;
    function AddLineStyle: TKMLLineStyle;
    procedure LineStyleRemove;
    function AddPolyStyle: TKMLLineStyle;
    procedure PolyStyleRemove;
    function AddBalloonStyle: TKMLBalloonStyle;
    procedure BalloonStyleRemove;
    property ID: String read FID write SetID;
    property IconStyle: TKMLIconStyle read FIconStyle write SetIconStyle;
    property LineStyle: TKMLLineStyle read FLineStyle write SetLineStyle;
    property PolyStyle: TKMLLineStyle read FPolyStyle write SetPolyStyle;
    property BalloonStyle: TKMLBalloonStyle read FBalloonStyle write SetBalloonStyle;
    property IconStyleExsit: Boolean read FIconStyleExsit;
    property LineStyleExsit: Boolean read FLineStyleExsit;
    property PolyStyleExsit: Boolean read FPolyStyleExsit;
    property BalloonStyleExsit: Boolean read FBalloonStyleExsit;
  end;

  TKMLIconStyle = class(TXMLTreeNode)
  private
    FIcon: TKMLIcon;
    procedure SetIcon(const _Value: TKMLIcon);
  protected
    procedure FromXML(node: IXMLNode); override;
    function ToXML(par: IXMLNode; pt: string = ''): IXMLNode; override;
    procedure AfterCreate; override;
  public
    constructor Create(par: TXML = nil);
    destructor Destroy; override;
    procedure CopyFrom(source: TKMLIconStyle);
    procedure ToTree; override;
    procedure ToPopupMenu(Sender: TObject); override;
    procedure ToInspector(ins: TObject); override;
    procedure PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False); override;
    procedure ChildDeleteEvent(del: TXMLTreeNode); override;
    procedure SetXMLProperty(Index: Integer; _Value: String); override;
    property Icon: TKMLIcon read FIcon write SetIcon;
  end;

  TKMLIcon = class(TXMLTreeNode)
  private
    Fhref: String;
    procedure Sethref(const _Value: String);
  protected
    procedure FromXML(node: IXMLNode); override;
    function ToXML(par: IXMLNode; pt: string = ''): IXMLNode; override;
    procedure AfterCreate; override;
  public
    constructor Create(par: TXML = nil);
    destructor Destroy; override;
    procedure CopyFrom(source: TKMLIcon);
    procedure ToTree; override;
    procedure ToPopupMenu(Sender: TObject); override;
    procedure ToInspector(ins: TObject); override;
    procedure PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False); override;
    procedure ChildDeleteEvent(del: TXMLTreeNode); override;
    procedure SetXMLProperty(Index: Integer; _Value: String); override;
    property href: String read Fhref write Sethref;
  end;

  TKMLLineStyle = class(TXMLTreeNode)
  private
    Fcolor: String;
    FcolorExsit: Boolean;
    Fwidth: Double;
    FwidthExsit: Boolean;
    procedure Setcolor(const _Value: String);
    procedure Setwidth(const _Value: Double);
  protected
    procedure FromXML(node: IXMLNode); override;
    function ToXML(par: IXMLNode; pt: string = ''): IXMLNode; override;
    procedure AddcolorEvent(Sender: TObject);
    procedure AddwidthEvent(Sender: TObject);
    procedure AfterCreate; override;
  public
    constructor Create(par: TXML = nil);
    destructor Destroy; override;
    procedure CopyFrom(source: TKMLLineStyle);
    procedure ToTree; override;
    procedure ToPopupMenu(Sender: TObject); override;
    procedure ToInspector(ins: TObject); override;
    procedure PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False); override;
    procedure ChildDeleteEvent(del: TXMLTreeNode); override;
    procedure SetXMLProperty(Index: Integer; _Value: String); override;
    function Addcolor: String;
    procedure colorRemove;
    function Addwidth: Double;
    procedure widthRemove;
    property color: String read Fcolor write Setcolor;
    property width: Double read Fwidth write Setwidth;
    property colorExsit: Boolean read FcolorExsit;
    property widthExsit: Boolean read FwidthExsit;
  end;

  TKMLBalloonStyle = class(TXMLTreeNode)
  private
    Ftext: String;
    procedure Settext(const _Value: String);
  protected
    procedure FromXML(node: IXMLNode); override;
    function ToXML(par: IXMLNode; pt: string = ''): IXMLNode; override;
    procedure AfterCreate; override;
  public
    constructor Create(par: TXML = nil);
    destructor Destroy; override;
    procedure CopyFrom(source: TKMLBalloonStyle);
    procedure ToTree; override;
    procedure ToPopupMenu(Sender: TObject); override;
    procedure ToInspector(ins: TObject); override;
    procedure PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False); override;
    procedure ChildDeleteEvent(del: TXMLTreeNode); override;
    procedure SetXMLProperty(Index: Integer; _Value: String); override;
    property text: String read Ftext write Settext;
  end;

  TKMLStyleMap = class(TXMLTreeNode)
  private
    FPairs: TList<TKMLPair>;
    FID: String;
    procedure SetPairs(const _Value: TList<TKMLPair>);
    function GetPair(Index: Integer): TKMLPair;
    procedure SetPair(Index: Integer; const _Value: TKMLPair);
    procedure SetID(const _Value: String);
  protected
    procedure FromXML(node: IXMLNode); override;
    function ToXML(par: IXMLNode; pt: string = ''): IXMLNode; override;
    procedure AddPairEvent(Sender: TObject);
    procedure AfterCreate; override;
  public
    constructor Create(par: TXML = nil);
    destructor Destroy; override;
    procedure CopyFrom(source: TKMLStyleMap);
    procedure ToTree; override;
    procedure ToPopupMenu(Sender: TObject); override;
    procedure ToInspector(ins: TObject); override;
    procedure PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False); override;
    procedure ChildDeleteEvent(del: TXMLTreeNode); override;
    procedure SetXMLProperty(Index: Integer; _Value: String); override;
    function AddPair: TKMLPair;
    procedure PairClear;
    function PairCount: Integer;
    procedure RemovePair(_Value: TKMLPair);
    procedure DeletePair(Index: Integer);
    property Pairs: TList<TKMLPair> read FPairs write SetPairs;
    property Pair[Index: Integer]: TKMLPair read GetPair write SetPair;
    property ID: String read FID write SetID;
  end;

  TKMLScreenOverlay = class(TXMLTreeNode)
  private
    FName: String;
    FNameExsit: Boolean;
    FVisibility: Integer;
    FVisibilityExsit: Boolean;
    FDescription: String;
    FDescriptionExsit: Boolean;
    FIcon: TKMLIcon;
    FIconExsit: Boolean;
    FOverlayXY: TKMLSize;
    FOverlayXYExsit: Boolean;
    FScreenXY: TKMLSize;
    FScreenXYExsit: Boolean;
    FRotationXY: TKMLSize;
    FRotationXYExsit: Boolean;
    FSize: TKMLSize;
    FSizeExsit: Boolean;
    procedure SetName(const _Value: String);
    procedure SetVisibility(const _Value: Integer);
    procedure SetDescription(const _Value: String);
    procedure SetIcon(const _Value: TKMLIcon);
    procedure SetOverlayXY(const _Value: TKMLSize);
    procedure SetScreenXY(const _Value: TKMLSize);
    procedure SetRotationXY(const _Value: TKMLSize);
    procedure SetSize(const _Value: TKMLSize);
  protected
    procedure FromXML(node: IXMLNode); override;
    function ToXML(par: IXMLNode; pt: string = ''): IXMLNode; override;
    procedure AddNameEvent(Sender: TObject);
    procedure AddVisibilityEvent(Sender: TObject);
    procedure AddDescriptionEvent(Sender: TObject);
    procedure AddIconEvent(Sender: TObject);
    procedure AddOverlayXYEvent(Sender: TObject);
    procedure AddScreenXYEvent(Sender: TObject);
    procedure AddRotationXYEvent(Sender: TObject);
    procedure AddSizeEvent(Sender: TObject);
    procedure AfterCreate; override;
  public
    constructor Create(par: TXML = nil);
    destructor Destroy; override;
    procedure CopyFrom(source: TKMLScreenOverlay);
    procedure ToTree; override;
    procedure ToPopupMenu(Sender: TObject); override;
    procedure ToInspector(ins: TObject); override;
    procedure PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False); override;
    procedure ChildDeleteEvent(del: TXMLTreeNode); override;
    procedure SetXMLProperty(Index: Integer; _Value: String); override;
    function AddName: String;
    procedure NameRemove;
    function AddVisibility: Integer;
    procedure VisibilityRemove;
    function AddDescription: String;
    procedure DescriptionRemove;
    function AddIcon: TKMLIcon;
    procedure IconRemove;
    function AddOverlayXY: TKMLSize;
    procedure OverlayXYRemove;
    function AddScreenXY: TKMLSize;
    procedure ScreenXYRemove;
    function AddRotationXY: TKMLSize;
    procedure RotationXYRemove;
    function AddSize: TKMLSize;
    procedure SizeRemove;
    property Name: String read FName write SetName;
    property Visibility: Integer read FVisibility write SetVisibility;
    property Description: String read FDescription write SetDescription;
    property Icon: TKMLIcon read FIcon write SetIcon;
    property OverlayXY: TKMLSize read FOverlayXY write SetOverlayXY;
    property ScreenXY: TKMLSize read FScreenXY write SetScreenXY;
    property RotationXY: TKMLSize read FRotationXY write SetRotationXY;
    property Size: TKMLSize read FSize write SetSize;
    property NameExsit: Boolean read FNameExsit;
    property VisibilityExsit: Boolean read FVisibilityExsit;
    property DescriptionExsit: Boolean read FDescriptionExsit;
    property IconExsit: Boolean read FIconExsit;
    property OverlayXYExsit: Boolean read FOverlayXYExsit;
    property ScreenXYExsit: Boolean read FScreenXYExsit;
    property RotationXYExsit: Boolean read FRotationXYExsit;
    property SizeExsit: Boolean read FSizeExsit;
  end;

  TKMLPair = class(TXMLTreeNode)
  private
    FKey: String;
    FKeyExsit: Boolean;
    FStyleUrl: String;
    FStyleUrlExsit: Boolean;
    procedure SetKey(const _Value: String);
    procedure SetStyleUrl(const _Value: String);
  protected
    procedure FromXML(node: IXMLNode); override;
    function ToXML(par: IXMLNode; pt: string = ''): IXMLNode; override;
    procedure AddKeyEvent(Sender: TObject);
    procedure AddStyleUrlEvent(Sender: TObject);
    procedure AfterCreate; override;
  public
    constructor Create(par: TXML = nil);
    destructor Destroy; override;
    procedure CopyFrom(source: TKMLPair);
    procedure ToTree; override;
    procedure ToPopupMenu(Sender: TObject); override;
    procedure ToInspector(ins: TObject); override;
    procedure PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False); override;
    procedure ChildDeleteEvent(del: TXMLTreeNode); override;
    procedure SetXMLProperty(Index: Integer; _Value: String); override;
    function AddKey: String;
    procedure KeyRemove;
    function AddStyleUrl: String;
    procedure StyleUrlRemove;
    property Key: String read FKey write SetKey;
    property StyleUrl: String read FStyleUrl write SetStyleUrl;
    property KeyExsit: Boolean read FKeyExsit;
    property StyleUrlExsit: Boolean read FStyleUrlExsit;
  end;



implementation

{  kml}
constructor TKML.Create(par: TXML = nil);
begin
  inherited Create(par);
  FDocument := TKMLDocument.Create(Self);
  FFolders := TList<TKMLFolder>.Create;
end;

destructor TKML.Destroy;
begin
  FDocument.Free;
  FolderClear;
  FFolders.Free;
  inherited;
end;

procedure TKML.AfterCreate;
begin
  inherited;
  FDocument := TKMLDocument.Create(Self);
  FFolders := TList<TKMLFolder>.Create;
end;

procedure TKML.FromXML(node: IXMLNode);
var
  I: Integer;
  nodeTmp: IXMLNode;
  FolderTmp: TKMLFolder;
begin
  try
    FXmlnsExsit := False;
    FolderClear;
    for I := 0 to node.ChildNodes.Count - 1 do
    begin
      nodeTmp := node.ChildNodes.Get(I);
      if nodeTmp.NodeName = 'Document' then
      begin
        FDocument := TKMLDocument.Create(Self);
        FDocument.FromXML(nodeTmp);
      end
      else if nodeTmp.NodeName = 'Folder' then
      begin
        FolderTmp := TKMLFolder.Create(Self);
        FolderTmp.FromXML(nodeTmp);
        FFolders.Add(FolderTmp);
      end;
    end;
    for I := 0 to node.AttributeNodes.Count - 1 do
    begin
      nodeTmp := node.AttributeNodes.Get(I);
      if nodeTmp.NodeName = 'xmlns' then
      begin
        FXmlns := nodeTmp.Text;
        FXmlnsExsit := True;
      end;
    end;
  except
    raise Exception.Create('kml Read XML Error!' + node.Xml);
  end;
end;

function TKML.ToXML(par: IXMLNode; pt: string): IXMLNode;
var
  doc: IXMLDocument;
  node: IXMLNode;
  XmlnsTmp: IXMLNode;
  I: Integer;
begin
  try
    doc := par.OwnerDocument;
  if (pt = '') or (pt[1] = '#') then
    pt := 'kml';
    node := doc.CreateNode(pt);
    par.ChildNodes.Add(node);
    FDocument.ToXML(node, 'Document');
    for I := 0 to FFolders.Count - 1 do
       FFolders.Items[I].ToXML(node, 'Folder');
    if FXmlnsExsit then 
    begin
      XmlnsTmp := doc.CreateNode('xmlns', ntAttribute);
      XmlnsTmp.NodeValue := FXmlns;
      node.AttributeNodes.Add(XmlnsTmp);
    end;
    Result := node;
  except
    raise Exception.Create('XML2Code Write XML Error!');
  end;
end;

procedure TKML.ToTree;
var
  I: Integer;
begin
  if not Assigned(TreeNodeShape) then
  begin
    Exit;
  end;
  TreeNodeShape.Clear;
  TreeNodeShape.Data := Self;
  TreeNodeShape.Text.Clear;
  TreeNodeShape.Text.Add('kml');
  if XmlnsExsit then
    TreeNodeShape.AddChild('Xmlns:' + FXmlns);
  Document.TreeNodeShape := TreeNodeShape.AddChildObject('Document', Document);
  Document.ToTree;
  for I := 0 to FolderCount - 1 do
  begin
    Folders[I].TreeNodeShape := TreeNodeShape.AddChildObject('Folder', Folder[I]);
    Folder[I].ToTree;
  end;
end;

procedure TKML.ToPopupMenu(Sender: TObject);
var
  pop: TPopupMenu;
  XmlnsAddMenu: TMenuItem;
  FolderAddMenu: TMenuItem;
begin
  if Assigned(Sender) and (Sender is TPopupMenu) then
  begin
    pop := TPopupMenu(Sender);
    pop.Items.Clear;
    XmlnsAddMenu := TMenuItem.Create(pop);
    XmlnsAddMenu.Caption := 'Add Xmlns';
    XmlnsAddMenu.OnClick := AddXmlnsEvent;
    pop.Items.Add(XmlnsAddMenu);
    FolderAddMenu := TMenuItem.Create(pop);
    FolderAddMenu.Caption := 'Add Folder';
    FolderAddMenu.OnClick := AddFolderEvent;
    pop.Items.Add(FolderAddMenu);
  end;
end;

procedure TKML.ToInspector;
var
  Names_Value: TStringList;
  Types_Value: TList<XMLTypes>;
  _Values_Value: TStringList;
begin
  if not Assigned(ins) then
    Exit;
  Names_Value := TStringList.Create;
  Types_Value := TList<XMLTypes>.Create;
  _Values_Value := TStringList.Create;
  Names_Value.Add('Xmlns');
  Types_Value.Add(xs_string);
  _Values_Value.Add(Xmlns);
  TXMLInspector(ins).SetData(Names_Value, _Values_Value, Types_Value, Self);
end;

procedure TKML.CopyFrom(source: TKML);
var
  I:Integer;
begin
  FXmlns := source.Xmlns;
  FXmlnsExsit := source.FXmlnsExsit;
    Document.CopyFrom(source.Document);
    FolderClear;
  for I := 0 to FolderCount - 1 do
  begin
    AddFolder.CopyFrom(source.Folder[I]);
  end;
  Self.ToTree;
end;

procedure TKML.PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False);
var
  I: Integer;
  tmpFolder: TKMLFolder;
begin
  if (items.Count = 1) and (items[0] is TKML) and (not isCut) then
  begin
    Self.CopyFrom(TKML(items[0]));
    Self.ToTree;
    Exit;
  end;
  for I := 0 to items.Count - 1 do
  begin
    if items[I] is TKMLFolder then
    begin
      tmpFolder := TKMLFolder(items[I]);
      if isCut then
      begin
        TKML(tmpFolder.Parent).Folders.Remove(tmpFolder);
        Self.Folders.Add(tmpFolder);
        tmpFolder.Parent := Self;
        tmpFolder.TreeNodeShape.Parent := Self.TreeNodeShape;
      end
      else
      begin
        AddFolder.CopyFrom(tmpFolder);
      end;
    end;
  end;
  Self.ToTree;
end;

procedure TKML.ChildDeleteEvent(del: TXMLTreeNode);
begin
  if del is TKMLFolder then
  begin
    Self.RemoveFolder(TKMLFolder(del));
  end;
end;
procedure TKML.SetXMLProperty(Index: Integer; _Value: String);
begin
  case index of
    0:
      begin
        Xmlns := _Value;
      end;
  end;
  ToTree;
end;

function TKML.AddXmlns: String;
begin;
  Result := FXmlns;
  FXmlnsExsit := True;
end;

procedure TKML.SetXmlns(const _Value: String);
begin
  FXmlnsExsit := True;
  FXmlns := _Value;
end;

procedure TKML.XmlnsRemove;
begin
  if FXmlnsExsit then
  begin
    FXmlnsExsit := False;
  end;
end;

procedure TKML.AddXmlnsEvent(Sender: TObject);
begin
  AddXmlns;
end;

procedure TKML.SetDocument(const _Value: TKMLDocument);
begin
  FDocument.Free;
  FDocument := _Value;
  FDocument.Parent := Self;
end;

function TKML.AddFolder: TKMLFolder;
var
  Foldertmp: TKMLFolder;
begin;
  Foldertmp := TKMLFolder.Create(Self);
  FFolders.Add(Foldertmp);
  Result := Foldertmp;
end;

procedure TKML.SetFolders(const _Value: TList<TKMLFolder>);
begin
  FolderClear;
  FFolders := _Value;
end;

procedure TKML.FolderClear;
begin
  while FFolders.Count > 0 do
  begin
    FFolders.Items[0].Free;
    FFolders.Delete(0);
  end;
end;

function TKML.FolderCount: Integer;
begin
  Result := FFolders.Count;
end;

function TKML.GetFolder(Index: Integer): TKMLFolder;
begin
  Result := FFolders[Index];
end;

procedure TKML.SetFolder(Index: Integer;
  const _Value: TKMLFolder);
begin
  _Value.Parent := Self;
  FFolders[Index].Free;
  FFolders[Index] := _Value;
end;

procedure TKML.RemoveFolder(_Value: TKMLFolder);
begin
  FFolders.Remove(_Value);
  _Value.Free;
end;

procedure TKML.DeleteFolder(Index: Integer);
begin
  FFolders.Items[Index].Free;
  FFolders.Delete(Index);
end;

procedure TKML.AddFolderEvent(Sender: TObject);
var
  tmp: TKMLFolder;
begin
  tmp := AddFolder;
  tmp.TreeNodeShape := TreeNodeShape.AddChildObject('Folder', tmp);
  tmp.ToTree;
end;

{  Document}
constructor TKMLDocument.Create(par: TXML = nil);
begin
  inherited Create(par);
  FStyleMaps := TList<TKMLStyleMap>.Create;
  FStyles := TList<TKMLStyle>.Create;
  FPlacemarks := TList<TKMLPlacemark>.Create;
  FFolders := TList<TKMLFolder>.Create;
end;

destructor TKMLDocument.Destroy;
begin
  if FLookAtExsit then
    FLookAt.Free;
  StyleMapClear;
  FStyleMaps.Free;
  StyleClear;
  FStyles.Free;
  PlacemarkClear;
  FPlacemarks.Free;
  FolderClear;
  FFolders.Free;
  inherited;
end;

procedure TKMLDocument.AfterCreate;
begin
  inherited;
  FStyleMaps := TList<TKMLStyleMap>.Create;
  FStyles := TList<TKMLStyle>.Create;
  FPlacemarks := TList<TKMLPlacemark>.Create;
  FFolders := TList<TKMLFolder>.Create;
end;

procedure TKMLDocument.FromXML(node: IXMLNode);
var
  I: Integer;
  nodeTmp: IXMLNode;
  StyleMapTmp: TKMLStyleMap;
  StyleTmp: TKMLStyle;
  PlacemarkTmp: TKMLPlacemark;
  FolderTmp: TKMLFolder;
begin
  try
    FNameExsit := False;
    FOpenExsit := False;
    FVisibilityExsit := False;
    FDescriptionExsit := False;
    FLookAtExsit := False;
    StyleMapClear;
    StyleClear;
    PlacemarkClear;
    FolderClear;
    for I := 0 to node.ChildNodes.Count - 1 do
    begin
      nodeTmp := node.ChildNodes.Get(I);
      if nodeTmp.NodeName = 'name' then
      begin
        FName := nodeTmp.Text;
        FNameExsit := True;
      end
      else if nodeTmp.NodeName = 'open' then
      begin
        FOpen := StrToIntDef(nodeTmp.Text, 0);;
        FOpenExsit := True;
      end
      else if nodeTmp.NodeName = 'visibility' then
      begin
        FVisibility := StrToIntDef(nodeTmp.Text, 0);;
        FVisibilityExsit := True;
      end
      else if nodeTmp.NodeName = 'description' then
      begin
        FDescription := nodeTmp.Text;
        FDescriptionExsit := True;
      end
      else if nodeTmp.NodeName = 'LookAt' then
      begin
        FLookAt := TKMLLookAt.Create(Self);
        FLookAt.FromXML(nodeTmp);
        FLookAtExsit := True;
      end
      else if nodeTmp.NodeName = 'StyleMap' then
      begin
        StyleMapTmp := TKMLStyleMap.Create(Self);
        StyleMapTmp.FromXML(nodeTmp);
        FStyleMaps.Add(StyleMapTmp);
      end
      else if nodeTmp.NodeName = 'Style' then
      begin
        StyleTmp := TKMLStyle.Create(Self);
        StyleTmp.FromXML(nodeTmp);
        FStyles.Add(StyleTmp);
      end
      else if nodeTmp.NodeName = 'Placemark' then
      begin
        PlacemarkTmp := TKMLPlacemark.Create(Self);
        PlacemarkTmp.FromXML(nodeTmp);
        FPlacemarks.Add(PlacemarkTmp);
      end
      else if nodeTmp.NodeName = 'Folder' then
      begin
        FolderTmp := TKMLFolder.Create(Self);
        FolderTmp.FromXML(nodeTmp);
        FFolders.Add(FolderTmp);
      end;
    end;
    for I := 0 to node.AttributeNodes.Count - 1 do
    begin
      nodeTmp := node.AttributeNodes.Get(I);
;
    end;
  except
    raise Exception.Create('Document Read XML Error!' + node.Xml);
  end;
end;

function TKMLDocument.ToXML(par: IXMLNode; pt: string): IXMLNode;
var
  doc: IXMLDocument;
  node: IXMLNode;
  NameTmp: IXMLNode;
  OpenTmp: IXMLNode;
  VisibilityTmp: IXMLNode;
  DescriptionTmp: IXMLNode;
  I: Integer;
begin
  try
    doc := par.OwnerDocument;
  if (pt = '') or (pt[1] = '#') then
    pt := 'Document';
    node := doc.CreateNode(pt);
    par.ChildNodes.Add(node);
    if FNameExsit then
    begin
      NameTmp := doc.CreateNode('name', ntElement);
      NameTmp.NodeValue := FName;
      node.ChildNodes.Add(NameTmp);
    end;
    if FOpenExsit then
    begin
      OpenTmp := doc.CreateNode('open', ntElement);
      OpenTmp.NodeValue := IntToStr(FOpen);
      node.ChildNodes.Add(OpenTmp);
    end;
    if FVisibilityExsit then
    begin
      VisibilityTmp := doc.CreateNode('visibility', ntElement);
      VisibilityTmp.NodeValue := IntToStr(FVisibility);
      node.ChildNodes.Add(VisibilityTmp);
    end;
    if FDescriptionExsit then
    begin
      DescriptionTmp := doc.CreateNode('description', ntElement);
      DescriptionTmp.NodeValue := FDescription;
      node.ChildNodes.Add(DescriptionTmp);
    end;
    if FLookAtExsit then
      FLookAt.ToXML(node, 'LookAt');
    for I := 0 to FStyleMaps.Count - 1 do
       FStyleMaps.Items[I].ToXML(node, 'StyleMap');
    for I := 0 to FStyles.Count - 1 do
       FStyles.Items[I].ToXML(node, 'Style');
    for I := 0 to FPlacemarks.Count - 1 do
       FPlacemarks.Items[I].ToXML(node, 'Placemark');
    for I := 0 to FFolders.Count - 1 do
       FFolders.Items[I].ToXML(node, 'Folder');
    Result := node;
  except
    raise Exception.Create('XML2Code Write XML Error!');
  end;
end;

procedure TKMLDocument.ToTree;
var
  I: Integer;
begin
  if not Assigned(TreeNodeShape) then
  begin
    Exit;
  end;
  TreeNodeShape.Clear;
  TreeNodeShape.Data := Self;
  TreeNodeShape.Text.Clear;
  TreeNodeShape.Text.Add('Document');
  if NameExsit then
    TreeNodeShape.AddChild('Name:' + FName);
  if OpenExsit then
    TreeNodeShape.AddChild('Open:' + IntToStr(FOpen));
  if VisibilityExsit then
    TreeNodeShape.AddChild('Visibility:' + IntToStr(FVisibility));
  if DescriptionExsit then
    TreeNodeShape.AddChild('Description:' + FDescription);
  if LookAtExsit then
  begin
    LookAt.TreeNodeShape := TreeNodeShape.AddChildObject('LookAt', LookAt);
    LookAt.ToTree;
  end;
  for I := 0 to StyleMapCount - 1 do
  begin
    StyleMaps[I].TreeNodeShape := TreeNodeShape.AddChildObject('StyleMap', StyleMap[I]);
    StyleMap[I].ToTree;
  end;
  for I := 0 to StyleCount - 1 do
  begin
    Styles[I].TreeNodeShape := TreeNodeShape.AddChildObject('Style', Style[I]);
    Style[I].ToTree;
  end;
  for I := 0 to PlacemarkCount - 1 do
  begin
    Placemarks[I].TreeNodeShape := TreeNodeShape.AddChildObject('Placemark', Placemark[I]);
    Placemark[I].ToTree;
  end;
  for I := 0 to FolderCount - 1 do
  begin
    Folders[I].TreeNodeShape := TreeNodeShape.AddChildObject('Folder', Folder[I]);
    Folder[I].ToTree;
  end;
end;

procedure TKMLDocument.ToPopupMenu(Sender: TObject);
var
  pop: TPopupMenu;
  NameAddMenu: TMenuItem;
  OpenAddMenu: TMenuItem;
  VisibilityAddMenu: TMenuItem;
  DescriptionAddMenu: TMenuItem;
  LookAtAddMenu: TMenuItem;
  StyleMapAddMenu: TMenuItem;
  StyleAddMenu: TMenuItem;
  PlacemarkAddMenu: TMenuItem;
  FolderAddMenu: TMenuItem;
begin
  if Assigned(Sender) and (Sender is TPopupMenu) then
  begin
    pop := TPopupMenu(Sender);
    pop.Items.Clear;
    NameAddMenu := TMenuItem.Create(pop);
    NameAddMenu.Caption := 'Add Name';
    NameAddMenu.OnClick := AddNameEvent;
    pop.Items.Add(NameAddMenu);
    OpenAddMenu := TMenuItem.Create(pop);
    OpenAddMenu.Caption := 'Add Open';
    OpenAddMenu.OnClick := AddOpenEvent;
    pop.Items.Add(OpenAddMenu);
    VisibilityAddMenu := TMenuItem.Create(pop);
    VisibilityAddMenu.Caption := 'Add Visibility';
    VisibilityAddMenu.OnClick := AddVisibilityEvent;
    pop.Items.Add(VisibilityAddMenu);
    DescriptionAddMenu := TMenuItem.Create(pop);
    DescriptionAddMenu.Caption := 'Add Description';
    DescriptionAddMenu.OnClick := AddDescriptionEvent;
    pop.Items.Add(DescriptionAddMenu);
    LookAtAddMenu := TMenuItem.Create(pop);
    LookAtAddMenu.Caption := 'Add LookAt';
    LookAtAddMenu.OnClick := AddLookAtEvent;
    pop.Items.Add(LookAtAddMenu);
    StyleMapAddMenu := TMenuItem.Create(pop);
    StyleMapAddMenu.Caption := 'Add StyleMap';
    StyleMapAddMenu.OnClick := AddStyleMapEvent;
    pop.Items.Add(StyleMapAddMenu);
    StyleAddMenu := TMenuItem.Create(pop);
    StyleAddMenu.Caption := 'Add Style';
    StyleAddMenu.OnClick := AddStyleEvent;
    pop.Items.Add(StyleAddMenu);
    PlacemarkAddMenu := TMenuItem.Create(pop);
    PlacemarkAddMenu.Caption := 'Add Placemark';
    PlacemarkAddMenu.OnClick := AddPlacemarkEvent;
    pop.Items.Add(PlacemarkAddMenu);
    FolderAddMenu := TMenuItem.Create(pop);
    FolderAddMenu.Caption := 'Add Folder';
    FolderAddMenu.OnClick := AddFolderEvent;
    pop.Items.Add(FolderAddMenu);
  end;
end;

procedure TKMLDocument.ToInspector;
var
  Names_Value: TStringList;
  Types_Value: TList<XMLTypes>;
  _Values_Value: TStringList;
begin
  if not Assigned(ins) then
    Exit;
  Names_Value := TStringList.Create;
  Types_Value := TList<XMLTypes>.Create;
  _Values_Value := TStringList.Create;
  Names_Value.Add('Name');
  Types_Value.Add(xs_string);
  _Values_Value.Add(Name);
  Names_Value.Add('Open');
  Types_Value.Add(xs_integer);
  _Values_Value.Add(IntToStr(Open));
  Names_Value.Add('Visibility');
  Types_Value.Add(xs_integer);
  _Values_Value.Add(IntToStr(Visibility));
  Names_Value.Add('Description');
  Types_Value.Add(xs_string);
  _Values_Value.Add(Description);
  TXMLInspector(ins).SetData(Names_Value, _Values_Value, Types_Value, Self);
end;

procedure TKMLDocument.CopyFrom(source: TKMLDocument);
var
  I:Integer;
begin
  FName := source.Name;
  FNameExsit := source.FNameExsit;
  FOpen := source.Open;
  FOpenExsit := source.FOpenExsit;
  FVisibility := source.Visibility;
  FVisibilityExsit := source.FVisibilityExsit;
  FDescription := source.Description;
  FDescriptionExsit := source.FDescriptionExsit;
  FLookAtExsit := source.FLookAtExsit;
  if source.FLookAtExsit then
  begin
    AddLookAt.CopyFrom(source.LookAt);
  end;
    StyleMapClear;
  for I := 0 to StyleMapCount - 1 do
  begin
    AddStyleMap.CopyFrom(source.StyleMap[I]);
  end;
    StyleClear;
  for I := 0 to StyleCount - 1 do
  begin
    AddStyle.CopyFrom(source.Style[I]);
  end;
    PlacemarkClear;
  for I := 0 to PlacemarkCount - 1 do
  begin
    AddPlacemark.CopyFrom(source.Placemark[I]);
  end;
    FolderClear;
  for I := 0 to FolderCount - 1 do
  begin
    AddFolder.CopyFrom(source.Folder[I]);
  end;
  Self.ToTree;
end;

procedure TKMLDocument.PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False);
var
  I: Integer;
  tmpStyleMap: TKMLStyleMap;
  tmpStyle: TKMLStyle;
  tmpPlacemark: TKMLPlacemark;
  tmpFolder: TKMLFolder;
begin
  if (items.Count = 1) and (items[0] is TKMLDocument) and (not isCut) then
  begin
    Self.CopyFrom(TKMLDocument(items[0]));
    Self.ToTree;
    Exit;
  end;
  for I := 0 to items.Count - 1 do
  begin
    if items[I] is TKMLStyleMap then
    begin
      tmpStyleMap := TKMLStyleMap(items[I]);
      if isCut then
      begin
        TKMLDocument(tmpStyleMap.Parent).StyleMaps.Remove(tmpStyleMap);
        Self.StyleMaps.Add(tmpStyleMap);
        tmpStyleMap.Parent := Self;
        tmpStyleMap.TreeNodeShape.Parent := Self.TreeNodeShape;
      end
      else
      begin
        AddStyleMap.CopyFrom(tmpStyleMap);
      end;
    end;
    if items[I] is TKMLStyle then
    begin
      tmpStyle := TKMLStyle(items[I]);
      if isCut then
      begin
        TKMLDocument(tmpStyle.Parent).Styles.Remove(tmpStyle);
        Self.Styles.Add(tmpStyle);
        tmpStyle.Parent := Self;
        tmpStyle.TreeNodeShape.Parent := Self.TreeNodeShape;
      end
      else
      begin
        AddStyle.CopyFrom(tmpStyle);
      end;
    end;
    if items[I] is TKMLPlacemark then
    begin
      tmpPlacemark := TKMLPlacemark(items[I]);
      if isCut then
      begin
        TKMLDocument(tmpPlacemark.Parent).Placemarks.Remove(tmpPlacemark);
        Self.Placemarks.Add(tmpPlacemark);
        tmpPlacemark.Parent := Self;
        tmpPlacemark.TreeNodeShape.Parent := Self.TreeNodeShape;
      end
      else
      begin
        AddPlacemark.CopyFrom(tmpPlacemark);
      end;
    end;
    if items[I] is TKMLFolder then
    begin
      tmpFolder := TKMLFolder(items[I]);
      if isCut then
      begin
        TKMLDocument(tmpFolder.Parent).Folders.Remove(tmpFolder);
        Self.Folders.Add(tmpFolder);
        tmpFolder.Parent := Self;
        tmpFolder.TreeNodeShape.Parent := Self.TreeNodeShape;
      end
      else
      begin
        AddFolder.CopyFrom(tmpFolder);
      end;
    end;
  end;
  Self.ToTree;
end;

procedure TKMLDocument.ChildDeleteEvent(del: TXMLTreeNode);
begin
  if del is TKMLStyleMap then
  begin
    Self.RemoveStyleMap(TKMLStyleMap(del));
  end;
  if del is TKMLStyle then
  begin
    Self.RemoveStyle(TKMLStyle(del));
  end;
  if del is TKMLPlacemark then
  begin
    Self.RemovePlacemark(TKMLPlacemark(del));
  end;
  if del is TKMLFolder then
  begin
    Self.RemoveFolder(TKMLFolder(del));
  end;
end;
procedure TKMLDocument.SetXMLProperty(Index: Integer; _Value: String);
begin
  case index of
    0:
      begin
        Name := _Value;
      end;
    1:
      begin
        Open := StrToIntDef(_Value, 0);;
      end;
    2:
      begin
        Visibility := StrToIntDef(_Value, 0);;
      end;
    3:
      begin
        Description := _Value;
      end;
  end;
  ToTree;
end;

function TKMLDocument.AddName: String;
begin;
  Result := FName;
  FNameExsit := True;
end;

procedure TKMLDocument.SetName(const _Value: String);
begin
  FNameExsit := True;
  FName := _Value;
end;

procedure TKMLDocument.NameRemove;
begin
  if FNameExsit then
  begin
    FNameExsit := False;
  end;
end;

procedure TKMLDocument.AddNameEvent(Sender: TObject);
begin
  AddName;
end;

function TKMLDocument.AddOpen: Integer;
begin;
  Result := FOpen;
  FOpenExsit := True;
end;

procedure TKMLDocument.SetOpen(const _Value: Integer);
begin
  FOpenExsit := True;
  FOpen := _Value;
end;

procedure TKMLDocument.OpenRemove;
begin
  if FOpenExsit then
  begin
    FOpenExsit := False;
  end;
end;

procedure TKMLDocument.AddOpenEvent(Sender: TObject);
begin
  AddOpen;
end;

function TKMLDocument.AddVisibility: Integer;
begin;
  Result := FVisibility;
  FVisibilityExsit := True;
end;

procedure TKMLDocument.SetVisibility(const _Value: Integer);
begin
  FVisibilityExsit := True;
  FVisibility := _Value;
end;

procedure TKMLDocument.VisibilityRemove;
begin
  if FVisibilityExsit then
  begin
    FVisibilityExsit := False;
  end;
end;

procedure TKMLDocument.AddVisibilityEvent(Sender: TObject);
begin
  AddVisibility;
end;

function TKMLDocument.AddDescription: String;
begin;
  Result := FDescription;
  FDescriptionExsit := True;
end;

procedure TKMLDocument.SetDescription(const _Value: String);
begin
  FDescriptionExsit := True;
  FDescription := _Value;
end;

procedure TKMLDocument.DescriptionRemove;
begin
  if FDescriptionExsit then
  begin
    FDescriptionExsit := False;
  end;
end;

procedure TKMLDocument.AddDescriptionEvent(Sender: TObject);
begin
  AddDescription;
end;

function TKMLDocument.AddLookAt: TKMLLookAt;
begin;
  if not FLookAtExsit then
    FLookAt := TKMLLookAt.Create(Self);
  Result := FLookAt;
  FLookAtExsit := True;
end;

procedure TKMLDocument.SetLookAt(const _Value: TKMLLookAt);
begin
  if FLookAtExsit then
    FLookAt.Free;
  FLookAtExsit := True;
  FLookAt := _Value;
  FLookAt.Parent := Self;
end;

procedure TKMLDocument.LookAtRemove;
begin
  if FLookAtExsit then
  begin
    FLookAt.Free;
    FLookAtExsit := False;
  end;
end;

procedure TKMLDocument.AddLookAtEvent(Sender: TObject);
begin
  AddLookAt;
  FLookAt.ToTree;
end;

function TKMLDocument.AddStyleMap: TKMLStyleMap;
var
  StyleMaptmp: TKMLStyleMap;
begin;
  StyleMaptmp := TKMLStyleMap.Create(Self);
  FStyleMaps.Add(StyleMaptmp);
  Result := StyleMaptmp;
end;

procedure TKMLDocument.SetStyleMaps(const _Value: TList<TKMLStyleMap>);
begin
  StyleMapClear;
  FStyleMaps := _Value;
end;

procedure TKMLDocument.StyleMapClear;
begin
  while FStyleMaps.Count > 0 do
  begin
    FStyleMaps.Items[0].Free;
    FStyleMaps.Delete(0);
  end;
end;

function TKMLDocument.StyleMapCount: Integer;
begin
  Result := FStyleMaps.Count;
end;

function TKMLDocument.GetStyleMap(Index: Integer): TKMLStyleMap;
begin
  Result := FStyleMaps[Index];
end;

procedure TKMLDocument.SetStyleMap(Index: Integer;
  const _Value: TKMLStyleMap);
begin
  _Value.Parent := Self;
  FStyleMaps[Index].Free;
  FStyleMaps[Index] := _Value;
end;

procedure TKMLDocument.RemoveStyleMap(_Value: TKMLStyleMap);
begin
  FStyleMaps.Remove(_Value);
  _Value.Free;
end;

procedure TKMLDocument.DeleteStyleMap(Index: Integer);
begin
  FStyleMaps.Items[Index].Free;
  FStyleMaps.Delete(Index);
end;

procedure TKMLDocument.AddStyleMapEvent(Sender: TObject);
var
  tmp: TKMLStyleMap;
begin
  tmp := AddStyleMap;
  tmp.TreeNodeShape := TreeNodeShape.AddChildObject('StyleMap', tmp);
  tmp.ToTree;
end;

function TKMLDocument.AddStyle: TKMLStyle;
var
  Styletmp: TKMLStyle;
begin;
  Styletmp := TKMLStyle.Create(Self);
  FStyles.Add(Styletmp);
  Result := Styletmp;
end;

procedure TKMLDocument.SetStyles(const _Value: TList<TKMLStyle>);
begin
  StyleClear;
  FStyles := _Value;
end;

procedure TKMLDocument.StyleClear;
begin
  while FStyles.Count > 0 do
  begin
    FStyles.Items[0].Free;
    FStyles.Delete(0);
  end;
end;

function TKMLDocument.StyleCount: Integer;
begin
  Result := FStyles.Count;
end;

function TKMLDocument.GetStyle(Index: Integer): TKMLStyle;
begin
  Result := FStyles[Index];
end;

procedure TKMLDocument.SetStyle(Index: Integer;
  const _Value: TKMLStyle);
begin
  _Value.Parent := Self;
  FStyles[Index].Free;
  FStyles[Index] := _Value;
end;

procedure TKMLDocument.RemoveStyle(_Value: TKMLStyle);
begin
  FStyles.Remove(_Value);
  _Value.Free;
end;

procedure TKMLDocument.DeleteStyle(Index: Integer);
begin
  FStyles.Items[Index].Free;
  FStyles.Delete(Index);
end;

procedure TKMLDocument.AddStyleEvent(Sender: TObject);
var
  tmp: TKMLStyle;
begin
  tmp := AddStyle;
  tmp.TreeNodeShape := TreeNodeShape.AddChildObject('Style', tmp);
  tmp.ToTree;
end;

function TKMLDocument.AddPlacemark: TKMLPlacemark;
var
  Placemarktmp: TKMLPlacemark;
begin;
  Placemarktmp := TKMLPlacemark.Create(Self);
  FPlacemarks.Add(Placemarktmp);
  Result := Placemarktmp;
end;

procedure TKMLDocument.SetPlacemarks(const _Value: TList<TKMLPlacemark>);
begin
  PlacemarkClear;
  FPlacemarks := _Value;
end;

procedure TKMLDocument.PlacemarkClear;
begin
  while FPlacemarks.Count > 0 do
  begin
    FPlacemarks.Items[0].Free;
    FPlacemarks.Delete(0);
  end;
end;

function TKMLDocument.PlacemarkCount: Integer;
begin
  Result := FPlacemarks.Count;
end;

function TKMLDocument.GetPlacemark(Index: Integer): TKMLPlacemark;
begin
  Result := FPlacemarks[Index];
end;

procedure TKMLDocument.SetPlacemark(Index: Integer;
  const _Value: TKMLPlacemark);
begin
  _Value.Parent := Self;
  FPlacemarks[Index].Free;
  FPlacemarks[Index] := _Value;
end;

procedure TKMLDocument.RemovePlacemark(_Value: TKMLPlacemark);
begin
  FPlacemarks.Remove(_Value);
  _Value.Free;
end;

procedure TKMLDocument.DeletePlacemark(Index: Integer);
begin
  FPlacemarks.Items[Index].Free;
  FPlacemarks.Delete(Index);
end;

procedure TKMLDocument.AddPlacemarkEvent(Sender: TObject);
var
  tmp: TKMLPlacemark;
begin
  tmp := AddPlacemark;
  tmp.TreeNodeShape := TreeNodeShape.AddChildObject('Placemark', tmp);
  tmp.ToTree;
end;

function TKMLDocument.AddFolder: TKMLFolder;
var
  Foldertmp: TKMLFolder;
begin;
  Foldertmp := TKMLFolder.Create(Self);
  FFolders.Add(Foldertmp);
  Result := Foldertmp;
end;

procedure TKMLDocument.SetFolders(const _Value: TList<TKMLFolder>);
begin
  FolderClear;
  FFolders := _Value;
end;

procedure TKMLDocument.FolderClear;
begin
  while FFolders.Count > 0 do
  begin
    FFolders.Items[0].Free;
    FFolders.Delete(0);
  end;
end;

function TKMLDocument.FolderCount: Integer;
begin
  Result := FFolders.Count;
end;

function TKMLDocument.GetFolder(Index: Integer): TKMLFolder;
begin
  Result := FFolders[Index];
end;

procedure TKMLDocument.SetFolder(Index: Integer;
  const _Value: TKMLFolder);
begin
  _Value.Parent := Self;
  FFolders[Index].Free;
  FFolders[Index] := _Value;
end;

procedure TKMLDocument.RemoveFolder(_Value: TKMLFolder);
begin
  FFolders.Remove(_Value);
  _Value.Free;
end;

procedure TKMLDocument.DeleteFolder(Index: Integer);
begin
  FFolders.Items[Index].Free;
  FFolders.Delete(Index);
end;

procedure TKMLDocument.AddFolderEvent(Sender: TObject);
var
  tmp: TKMLFolder;
begin
  tmp := AddFolder;
  tmp.TreeNodeShape := TreeNodeShape.AddChildObject('Folder', tmp);
  tmp.ToTree;
end;

{  Folder}
constructor TKMLFolder.Create(par: TXML = nil);
begin
  inherited Create(par);
  FGroundOverlays := TList<TKMLGroundOverlay>.Create;
  FPlacemarks := TList<TKMLPlacemark>.Create;
  FScreenOverlays := TList<TKMLScreenOverlay>.Create;
  FFolders := TList<TKMLFolder>.Create;
end;

destructor TKMLFolder.Destroy;
begin
  if FLookAtExsit then
    FLookAt.Free;
  if FDocumentExsit then
    FDocument.Free;
  GroundOverlayClear;
  FGroundOverlays.Free;
  PlacemarkClear;
  FPlacemarks.Free;
  ScreenOverlayClear;
  FScreenOverlays.Free;
  FolderClear;
  FFolders.Free;
  inherited;
end;

procedure TKMLFolder.AfterCreate;
begin
  inherited;
  FGroundOverlays := TList<TKMLGroundOverlay>.Create;
  FPlacemarks := TList<TKMLPlacemark>.Create;
  FScreenOverlays := TList<TKMLScreenOverlay>.Create;
  FFolders := TList<TKMLFolder>.Create;
end;

procedure TKMLFolder.FromXML(node: IXMLNode);
var
  I: Integer;
  nodeTmp: IXMLNode;
  GroundOverlayTmp: TKMLGroundOverlay;
  PlacemarkTmp: TKMLPlacemark;
  ScreenOverlayTmp: TKMLScreenOverlay;
  FolderTmp: TKMLFolder;
begin
  try
    FNameExsit := False;
    FOpenExsit := False;
    FVisibilityExsit := False;
    FDescriptionExsit := False;
    FLookAtExsit := False;
    FDocumentExsit := False;
    GroundOverlayClear;
    PlacemarkClear;
    ScreenOverlayClear;
    FolderClear;
    for I := 0 to node.ChildNodes.Count - 1 do
    begin
      nodeTmp := node.ChildNodes.Get(I);
      if nodeTmp.NodeName = 'name' then
      begin
        FName := nodeTmp.Text;
        FNameExsit := True;
      end
      else if nodeTmp.NodeName = 'open' then
      begin
        FOpen := StrToIntDef(nodeTmp.Text, 0);;
        FOpenExsit := True;
      end
      else if nodeTmp.NodeName = 'visibility' then
      begin
        FVisibility := StrToIntDef(nodeTmp.Text, 0);;
        FVisibilityExsit := True;
      end
      else if nodeTmp.NodeName = 'description' then
      begin
        FDescription := nodeTmp.Text;
        FDescriptionExsit := True;
      end
      else if nodeTmp.NodeName = 'LookAt' then
      begin
        FLookAt := TKMLLookAt.Create(Self);
        FLookAt.FromXML(nodeTmp);
        FLookAtExsit := True;
      end
      else if nodeTmp.NodeName = 'Document' then
      begin
        FDocument := TKMLDocument.Create(Self);
        FDocument.FromXML(nodeTmp);
        FDocumentExsit := True;
      end
      else if nodeTmp.NodeName = 'GroundOverlay' then
      begin
        GroundOverlayTmp := TKMLGroundOverlay.Create(Self);
        GroundOverlayTmp.FromXML(nodeTmp);
        FGroundOverlays.Add(GroundOverlayTmp);
      end
      else if nodeTmp.NodeName = 'Placemark' then
      begin
        PlacemarkTmp := TKMLPlacemark.Create(Self);
        PlacemarkTmp.FromXML(nodeTmp);
        FPlacemarks.Add(PlacemarkTmp);
      end
      else if nodeTmp.NodeName = 'ScreenOverlay' then
      begin
        ScreenOverlayTmp := TKMLScreenOverlay.Create(Self);
        ScreenOverlayTmp.FromXML(nodeTmp);
        FScreenOverlays.Add(ScreenOverlayTmp);
      end
      else if nodeTmp.NodeName = 'Folder' then
      begin
        FolderTmp := TKMLFolder.Create(Self);
        FolderTmp.FromXML(nodeTmp);
        FFolders.Add(FolderTmp);
      end;
    end;
    for I := 0 to node.AttributeNodes.Count - 1 do
    begin
      nodeTmp := node.AttributeNodes.Get(I);
;
    end;
  except
    raise Exception.Create('Folder Read XML Error!' + node.Xml);
  end;
end;

function TKMLFolder.ToXML(par: IXMLNode; pt: string): IXMLNode;
var
  doc: IXMLDocument;
  node: IXMLNode;
  NameTmp: IXMLNode;
  OpenTmp: IXMLNode;
  VisibilityTmp: IXMLNode;
  DescriptionTmp: IXMLNode;
  I: Integer;
begin
  try
    doc := par.OwnerDocument;
  if (pt = '') or (pt[1] = '#') then
    pt := 'Folder';
    node := doc.CreateNode(pt);
    par.ChildNodes.Add(node);
    if FNameExsit then
    begin
      NameTmp := doc.CreateNode('name', ntElement);
      NameTmp.NodeValue := FName;
      node.ChildNodes.Add(NameTmp);
    end;
    if FOpenExsit then
    begin
      OpenTmp := doc.CreateNode('open', ntElement);
      OpenTmp.NodeValue := IntToStr(FOpen);
      node.ChildNodes.Add(OpenTmp);
    end;
    if FVisibilityExsit then
    begin
      VisibilityTmp := doc.CreateNode('visibility', ntElement);
      VisibilityTmp.NodeValue := IntToStr(FVisibility);
      node.ChildNodes.Add(VisibilityTmp);
    end;
    if FDescriptionExsit then
    begin
      DescriptionTmp := doc.CreateNode('description', ntElement);
      DescriptionTmp.NodeValue := FDescription;
      node.ChildNodes.Add(DescriptionTmp);
    end;
    if FLookAtExsit then
      FLookAt.ToXML(node, 'LookAt');
    if FDocumentExsit then
      FDocument.ToXML(node, 'Document');
    for I := 0 to FGroundOverlays.Count - 1 do
       FGroundOverlays.Items[I].ToXML(node, 'GroundOverlay');
    for I := 0 to FPlacemarks.Count - 1 do
       FPlacemarks.Items[I].ToXML(node, 'Placemark');
    for I := 0 to FScreenOverlays.Count - 1 do
       FScreenOverlays.Items[I].ToXML(node, 'ScreenOverlay');
    for I := 0 to FFolders.Count - 1 do
       FFolders.Items[I].ToXML(node, 'Folder');
    Result := node;
  except
    raise Exception.Create('XML2Code Write XML Error!');
  end;
end;

procedure TKMLFolder.ToTree;
var
  I: Integer;
begin
  if not Assigned(TreeNodeShape) then
  begin
    Exit;
  end;
  TreeNodeShape.Clear;
  TreeNodeShape.Data := Self;
  TreeNodeShape.Text.Clear;
  TreeNodeShape.Text.Add('Folder');
  if NameExsit then
    TreeNodeShape.AddChild('Name:' + FName);
  if OpenExsit then
    TreeNodeShape.AddChild('Open:' + IntToStr(FOpen));
  if VisibilityExsit then
    TreeNodeShape.AddChild('Visibility:' + IntToStr(FVisibility));
  if DescriptionExsit then
    TreeNodeShape.AddChild('Description:' + FDescription);
  if LookAtExsit then
  begin
    LookAt.TreeNodeShape := TreeNodeShape.AddChildObject('LookAt', LookAt);
    LookAt.ToTree;
  end;
  if DocumentExsit then
  begin
    Document.TreeNodeShape := TreeNodeShape.AddChildObject('Document', Document);
    Document.ToTree;
  end;
  for I := 0 to GroundOverlayCount - 1 do
  begin
    GroundOverlays[I].TreeNodeShape := TreeNodeShape.AddChildObject('GroundOverlay', GroundOverlay[I]);
    GroundOverlay[I].ToTree;
  end;
  for I := 0 to PlacemarkCount - 1 do
  begin
    Placemarks[I].TreeNodeShape := TreeNodeShape.AddChildObject('Placemark', Placemark[I]);
    Placemark[I].ToTree;
  end;
  for I := 0 to ScreenOverlayCount - 1 do
  begin
    ScreenOverlays[I].TreeNodeShape := TreeNodeShape.AddChildObject('ScreenOverlay', ScreenOverlay[I]);
    ScreenOverlay[I].ToTree;
  end;
  for I := 0 to FolderCount - 1 do
  begin
    Folders[I].TreeNodeShape := TreeNodeShape.AddChildObject('Folder', Folder[I]);
    Folder[I].ToTree;
  end;
end;

procedure TKMLFolder.ToPopupMenu(Sender: TObject);
var
  pop: TPopupMenu;
  NameAddMenu: TMenuItem;
  OpenAddMenu: TMenuItem;
  VisibilityAddMenu: TMenuItem;
  DescriptionAddMenu: TMenuItem;
  LookAtAddMenu: TMenuItem;
  DocumentAddMenu: TMenuItem;
  GroundOverlayAddMenu: TMenuItem;
  PlacemarkAddMenu: TMenuItem;
  ScreenOverlayAddMenu: TMenuItem;
  FolderAddMenu: TMenuItem;
begin
  if Assigned(Sender) and (Sender is TPopupMenu) then
  begin
    pop := TPopupMenu(Sender);
    pop.Items.Clear;
    NameAddMenu := TMenuItem.Create(pop);
    NameAddMenu.Caption := 'Add Name';
    NameAddMenu.OnClick := AddNameEvent;
    pop.Items.Add(NameAddMenu);
    OpenAddMenu := TMenuItem.Create(pop);
    OpenAddMenu.Caption := 'Add Open';
    OpenAddMenu.OnClick := AddOpenEvent;
    pop.Items.Add(OpenAddMenu);
    VisibilityAddMenu := TMenuItem.Create(pop);
    VisibilityAddMenu.Caption := 'Add Visibility';
    VisibilityAddMenu.OnClick := AddVisibilityEvent;
    pop.Items.Add(VisibilityAddMenu);
    DescriptionAddMenu := TMenuItem.Create(pop);
    DescriptionAddMenu.Caption := 'Add Description';
    DescriptionAddMenu.OnClick := AddDescriptionEvent;
    pop.Items.Add(DescriptionAddMenu);
    LookAtAddMenu := TMenuItem.Create(pop);
    LookAtAddMenu.Caption := 'Add LookAt';
    LookAtAddMenu.OnClick := AddLookAtEvent;
    pop.Items.Add(LookAtAddMenu);
    DocumentAddMenu := TMenuItem.Create(pop);
    DocumentAddMenu.Caption := 'Add Document';
    DocumentAddMenu.OnClick := AddDocumentEvent;
    pop.Items.Add(DocumentAddMenu);
    GroundOverlayAddMenu := TMenuItem.Create(pop);
    GroundOverlayAddMenu.Caption := 'Add GroundOverlay';
    GroundOverlayAddMenu.OnClick := AddGroundOverlayEvent;
    pop.Items.Add(GroundOverlayAddMenu);
    PlacemarkAddMenu := TMenuItem.Create(pop);
    PlacemarkAddMenu.Caption := 'Add Placemark';
    PlacemarkAddMenu.OnClick := AddPlacemarkEvent;
    pop.Items.Add(PlacemarkAddMenu);
    ScreenOverlayAddMenu := TMenuItem.Create(pop);
    ScreenOverlayAddMenu.Caption := 'Add ScreenOverlay';
    ScreenOverlayAddMenu.OnClick := AddScreenOverlayEvent;
    pop.Items.Add(ScreenOverlayAddMenu);
    FolderAddMenu := TMenuItem.Create(pop);
    FolderAddMenu.Caption := 'Add Folder';
    FolderAddMenu.OnClick := AddFolderEvent;
    pop.Items.Add(FolderAddMenu);
  end;
end;

procedure TKMLFolder.ToInspector;
var
  Names_Value: TStringList;
  Types_Value: TList<XMLTypes>;
  _Values_Value: TStringList;
begin
  if not Assigned(ins) then
    Exit;
  Names_Value := TStringList.Create;
  Types_Value := TList<XMLTypes>.Create;
  _Values_Value := TStringList.Create;
  Names_Value.Add('Name');
  Types_Value.Add(xs_string);
  _Values_Value.Add(Name);
  Names_Value.Add('Open');
  Types_Value.Add(xs_integer);
  _Values_Value.Add(IntToStr(Open));
  Names_Value.Add('Visibility');
  Types_Value.Add(xs_integer);
  _Values_Value.Add(IntToStr(Visibility));
  Names_Value.Add('Description');
  Types_Value.Add(xs_string);
  _Values_Value.Add(Description);
  TXMLInspector(ins).SetData(Names_Value, _Values_Value, Types_Value, Self);
end;

procedure TKMLFolder.CopyFrom(source: TKMLFolder);
var
  I:Integer;
begin
  FName := source.Name;
  FNameExsit := source.FNameExsit;
  FOpen := source.Open;
  FOpenExsit := source.FOpenExsit;
  FVisibility := source.Visibility;
  FVisibilityExsit := source.FVisibilityExsit;
  FDescription := source.Description;
  FDescriptionExsit := source.FDescriptionExsit;
  FLookAtExsit := source.FLookAtExsit;
  if source.FLookAtExsit then
  begin
    AddLookAt.CopyFrom(source.LookAt);
  end;
  FDocumentExsit := source.FDocumentExsit;
  if source.FDocumentExsit then
  begin
    AddDocument.CopyFrom(source.Document);
  end;
    GroundOverlayClear;
  for I := 0 to GroundOverlayCount - 1 do
  begin
    AddGroundOverlay.CopyFrom(source.GroundOverlay[I]);
  end;
    PlacemarkClear;
  for I := 0 to PlacemarkCount - 1 do
  begin
    AddPlacemark.CopyFrom(source.Placemark[I]);
  end;
    ScreenOverlayClear;
  for I := 0 to ScreenOverlayCount - 1 do
  begin
    AddScreenOverlay.CopyFrom(source.ScreenOverlay[I]);
  end;
    FolderClear;
  for I := 0 to FolderCount - 1 do
  begin
    AddFolder.CopyFrom(source.Folder[I]);
  end;
  Self.ToTree;
end;

procedure TKMLFolder.PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False);
var
  I: Integer;
  tmpGroundOverlay: TKMLGroundOverlay;
  tmpPlacemark: TKMLPlacemark;
  tmpScreenOverlay: TKMLScreenOverlay;
  tmpFolder: TKMLFolder;
begin
  if (items.Count = 1) and (items[0] is TKMLFolder) and (not isCut) then
  begin
    Self.CopyFrom(TKMLFolder(items[0]));
    Self.ToTree;
    Exit;
  end;
  for I := 0 to items.Count - 1 do
  begin
    if items[I] is TKMLGroundOverlay then
    begin
      tmpGroundOverlay := TKMLGroundOverlay(items[I]);
      if isCut then
      begin
        TKMLFolder(tmpGroundOverlay.Parent).GroundOverlays.Remove(tmpGroundOverlay);
        Self.GroundOverlays.Add(tmpGroundOverlay);
        tmpGroundOverlay.Parent := Self;
        tmpGroundOverlay.TreeNodeShape.Parent := Self.TreeNodeShape;
      end
      else
      begin
        AddGroundOverlay.CopyFrom(tmpGroundOverlay);
      end;
    end;
    if items[I] is TKMLPlacemark then
    begin
      tmpPlacemark := TKMLPlacemark(items[I]);
      if isCut then
      begin
        TKMLFolder(tmpPlacemark.Parent).Placemarks.Remove(tmpPlacemark);
        Self.Placemarks.Add(tmpPlacemark);
        tmpPlacemark.Parent := Self;
        tmpPlacemark.TreeNodeShape.Parent := Self.TreeNodeShape;
      end
      else
      begin
        AddPlacemark.CopyFrom(tmpPlacemark);
      end;
    end;
    if items[I] is TKMLScreenOverlay then
    begin
      tmpScreenOverlay := TKMLScreenOverlay(items[I]);
      if isCut then
      begin
        TKMLFolder(tmpScreenOverlay.Parent).ScreenOverlays.Remove(tmpScreenOverlay);
        Self.ScreenOverlays.Add(tmpScreenOverlay);
        tmpScreenOverlay.Parent := Self;
        tmpScreenOverlay.TreeNodeShape.Parent := Self.TreeNodeShape;
      end
      else
      begin
        AddScreenOverlay.CopyFrom(tmpScreenOverlay);
      end;
    end;
    if items[I] is TKMLFolder then
    begin
      tmpFolder := TKMLFolder(items[I]);
      if isCut then
      begin
        TKMLFolder(tmpFolder.Parent).Folders.Remove(tmpFolder);
        Self.Folders.Add(tmpFolder);
        tmpFolder.Parent := Self;
        tmpFolder.TreeNodeShape.Parent := Self.TreeNodeShape;
      end
      else
      begin
        AddFolder.CopyFrom(tmpFolder);
      end;
    end;
  end;
  Self.ToTree;
end;

procedure TKMLFolder.ChildDeleteEvent(del: TXMLTreeNode);
begin
  if del is TKMLGroundOverlay then
  begin
    Self.RemoveGroundOverlay(TKMLGroundOverlay(del));
  end;
  if del is TKMLPlacemark then
  begin
    Self.RemovePlacemark(TKMLPlacemark(del));
  end;
  if del is TKMLScreenOverlay then
  begin
    Self.RemoveScreenOverlay(TKMLScreenOverlay(del));
  end;
  if del is TKMLFolder then
  begin
    Self.RemoveFolder(TKMLFolder(del));
  end;
end;
procedure TKMLFolder.SetXMLProperty(Index: Integer; _Value: String);
begin
  case index of
    0:
      begin
        Name := _Value;
      end;
    1:
      begin
        Open := StrToIntDef(_Value, 0);;
      end;
    2:
      begin
        Visibility := StrToIntDef(_Value, 0);;
      end;
    3:
      begin
        Description := _Value;
      end;
  end;
  ToTree;
end;

function TKMLFolder.AddName: String;
begin;
  Result := FName;
  FNameExsit := True;
end;

procedure TKMLFolder.SetName(const _Value: String);
begin
  FNameExsit := True;
  FName := _Value;
end;

procedure TKMLFolder.NameRemove;
begin
  if FNameExsit then
  begin
    FNameExsit := False;
  end;
end;

procedure TKMLFolder.AddNameEvent(Sender: TObject);
begin
  AddName;
end;

function TKMLFolder.AddOpen: Integer;
begin;
  Result := FOpen;
  FOpenExsit := True;
end;

procedure TKMLFolder.SetOpen(const _Value: Integer);
begin
  FOpenExsit := True;
  FOpen := _Value;
end;

procedure TKMLFolder.OpenRemove;
begin
  if FOpenExsit then
  begin
    FOpenExsit := False;
  end;
end;

procedure TKMLFolder.AddOpenEvent(Sender: TObject);
begin
  AddOpen;
end;

function TKMLFolder.AddVisibility: Integer;
begin;
  Result := FVisibility;
  FVisibilityExsit := True;
end;

procedure TKMLFolder.SetVisibility(const _Value: Integer);
begin
  FVisibilityExsit := True;
  FVisibility := _Value;
end;

procedure TKMLFolder.VisibilityRemove;
begin
  if FVisibilityExsit then
  begin
    FVisibilityExsit := False;
  end;
end;

procedure TKMLFolder.AddVisibilityEvent(Sender: TObject);
begin
  AddVisibility;
end;

function TKMLFolder.AddDescription: String;
begin;
  Result := FDescription;
  FDescriptionExsit := True;
end;

procedure TKMLFolder.SetDescription(const _Value: String);
begin
  FDescriptionExsit := True;
  FDescription := _Value;
end;

procedure TKMLFolder.DescriptionRemove;
begin
  if FDescriptionExsit then
  begin
    FDescriptionExsit := False;
  end;
end;

procedure TKMLFolder.AddDescriptionEvent(Sender: TObject);
begin
  AddDescription;
end;

function TKMLFolder.AddLookAt: TKMLLookAt;
begin;
  if not FLookAtExsit then
    FLookAt := TKMLLookAt.Create(Self);
  Result := FLookAt;
  FLookAtExsit := True;
end;

procedure TKMLFolder.SetLookAt(const _Value: TKMLLookAt);
begin
  if FLookAtExsit then
    FLookAt.Free;
  FLookAtExsit := True;
  FLookAt := _Value;
  FLookAt.Parent := Self;
end;

procedure TKMLFolder.LookAtRemove;
begin
  if FLookAtExsit then
  begin
    FLookAt.Free;
    FLookAtExsit := False;
  end;
end;

procedure TKMLFolder.AddLookAtEvent(Sender: TObject);
begin
  AddLookAt;
  FLookAt.ToTree;
end;

function TKMLFolder.AddDocument: TKMLDocument;
begin;
  if not FDocumentExsit then
    FDocument := TKMLDocument.Create(Self);
  Result := FDocument;
  FDocumentExsit := True;
end;

procedure TKMLFolder.SetDocument(const _Value: TKMLDocument);
begin
  if FDocumentExsit then
    FDocument.Free;
  FDocumentExsit := True;
  FDocument := _Value;
  FDocument.Parent := Self;
end;

procedure TKMLFolder.DocumentRemove;
begin
  if FDocumentExsit then
  begin
    FDocument.Free;
    FDocumentExsit := False;
  end;
end;

procedure TKMLFolder.AddDocumentEvent(Sender: TObject);
begin
  AddDocument;
  FDocument.ToTree;
end;

function TKMLFolder.AddGroundOverlay: TKMLGroundOverlay;
var
  GroundOverlaytmp: TKMLGroundOverlay;
begin;
  GroundOverlaytmp := TKMLGroundOverlay.Create(Self);
  FGroundOverlays.Add(GroundOverlaytmp);
  Result := GroundOverlaytmp;
end;

procedure TKMLFolder.SetGroundOverlays(const _Value: TList<TKMLGroundOverlay>);
begin
  GroundOverlayClear;
  FGroundOverlays := _Value;
end;

procedure TKMLFolder.GroundOverlayClear;
begin
  while FGroundOverlays.Count > 0 do
  begin
    FGroundOverlays.Items[0].Free;
    FGroundOverlays.Delete(0);
  end;
end;

function TKMLFolder.GroundOverlayCount: Integer;
begin
  Result := FGroundOverlays.Count;
end;

function TKMLFolder.GetGroundOverlay(Index: Integer): TKMLGroundOverlay;
begin
  Result := FGroundOverlays[Index];
end;

procedure TKMLFolder.SetGroundOverlay(Index: Integer;
  const _Value: TKMLGroundOverlay);
begin
  _Value.Parent := Self;
  FGroundOverlays[Index].Free;
  FGroundOverlays[Index] := _Value;
end;

procedure TKMLFolder.RemoveGroundOverlay(_Value: TKMLGroundOverlay);
begin
  FGroundOverlays.Remove(_Value);
  _Value.Free;
end;

procedure TKMLFolder.DeleteGroundOverlay(Index: Integer);
begin
  FGroundOverlays.Items[Index].Free;
  FGroundOverlays.Delete(Index);
end;

procedure TKMLFolder.AddGroundOverlayEvent(Sender: TObject);
var
  tmp: TKMLGroundOverlay;
begin
  tmp := AddGroundOverlay;
  tmp.TreeNodeShape := TreeNodeShape.AddChildObject('GroundOverlay', tmp);
  tmp.ToTree;
end;

function TKMLFolder.AddPlacemark: TKMLPlacemark;
var
  Placemarktmp: TKMLPlacemark;
begin;
  Placemarktmp := TKMLPlacemark.Create(Self);
  FPlacemarks.Add(Placemarktmp);
  Result := Placemarktmp;
end;

procedure TKMLFolder.SetPlacemarks(const _Value: TList<TKMLPlacemark>);
begin
  PlacemarkClear;
  FPlacemarks := _Value;
end;

procedure TKMLFolder.PlacemarkClear;
begin
  while FPlacemarks.Count > 0 do
  begin
    FPlacemarks.Items[0].Free;
    FPlacemarks.Delete(0);
  end;
end;

function TKMLFolder.PlacemarkCount: Integer;
begin
  Result := FPlacemarks.Count;
end;

function TKMLFolder.GetPlacemark(Index: Integer): TKMLPlacemark;
begin
  Result := FPlacemarks[Index];
end;

procedure TKMLFolder.SetPlacemark(Index: Integer;
  const _Value: TKMLPlacemark);
begin
  _Value.Parent := Self;
  FPlacemarks[Index].Free;
  FPlacemarks[Index] := _Value;
end;

procedure TKMLFolder.RemovePlacemark(_Value: TKMLPlacemark);
begin
  FPlacemarks.Remove(_Value);
  _Value.Free;
end;

procedure TKMLFolder.DeletePlacemark(Index: Integer);
begin
  FPlacemarks.Items[Index].Free;
  FPlacemarks.Delete(Index);
end;

procedure TKMLFolder.AddPlacemarkEvent(Sender: TObject);
var
  tmp: TKMLPlacemark;
begin
  tmp := AddPlacemark;
  tmp.TreeNodeShape := TreeNodeShape.AddChildObject('Placemark', tmp);
  tmp.ToTree;
end;

function TKMLFolder.AddScreenOverlay: TKMLScreenOverlay;
var
  ScreenOverlaytmp: TKMLScreenOverlay;
begin;
  ScreenOverlaytmp := TKMLScreenOverlay.Create(Self);
  FScreenOverlays.Add(ScreenOverlaytmp);
  Result := ScreenOverlaytmp;
end;

procedure TKMLFolder.SetScreenOverlays(const _Value: TList<TKMLScreenOverlay>);
begin
  ScreenOverlayClear;
  FScreenOverlays := _Value;
end;

procedure TKMLFolder.ScreenOverlayClear;
begin
  while FScreenOverlays.Count > 0 do
  begin
    FScreenOverlays.Items[0].Free;
    FScreenOverlays.Delete(0);
  end;
end;

function TKMLFolder.ScreenOverlayCount: Integer;
begin
  Result := FScreenOverlays.Count;
end;

function TKMLFolder.GetScreenOverlay(Index: Integer): TKMLScreenOverlay;
begin
  Result := FScreenOverlays[Index];
end;

procedure TKMLFolder.SetScreenOverlay(Index: Integer;
  const _Value: TKMLScreenOverlay);
begin
  _Value.Parent := Self;
  FScreenOverlays[Index].Free;
  FScreenOverlays[Index] := _Value;
end;

procedure TKMLFolder.RemoveScreenOverlay(_Value: TKMLScreenOverlay);
begin
  FScreenOverlays.Remove(_Value);
  _Value.Free;
end;

procedure TKMLFolder.DeleteScreenOverlay(Index: Integer);
begin
  FScreenOverlays.Items[Index].Free;
  FScreenOverlays.Delete(Index);
end;

procedure TKMLFolder.AddScreenOverlayEvent(Sender: TObject);
var
  tmp: TKMLScreenOverlay;
begin
  tmp := AddScreenOverlay;
  tmp.TreeNodeShape := TreeNodeShape.AddChildObject('ScreenOverlay', tmp);
  tmp.ToTree;
end;

function TKMLFolder.AddFolder: TKMLFolder;
var
  Foldertmp: TKMLFolder;
begin;
  Foldertmp := TKMLFolder.Create(Self);
  FFolders.Add(Foldertmp);
  Result := Foldertmp;
end;

procedure TKMLFolder.SetFolders(const _Value: TList<TKMLFolder>);
begin
  FolderClear;
  FFolders := _Value;
end;

procedure TKMLFolder.FolderClear;
begin
  while FFolders.Count > 0 do
  begin
    FFolders.Items[0].Free;
    FFolders.Delete(0);
  end;
end;

function TKMLFolder.FolderCount: Integer;
begin
  Result := FFolders.Count;
end;

function TKMLFolder.GetFolder(Index: Integer): TKMLFolder;
begin
  Result := FFolders[Index];
end;

procedure TKMLFolder.SetFolder(Index: Integer;
  const _Value: TKMLFolder);
begin
  _Value.Parent := Self;
  FFolders[Index].Free;
  FFolders[Index] := _Value;
end;

procedure TKMLFolder.RemoveFolder(_Value: TKMLFolder);
begin
  FFolders.Remove(_Value);
  _Value.Free;
end;

procedure TKMLFolder.DeleteFolder(Index: Integer);
begin
  FFolders.Items[Index].Free;
  FFolders.Delete(Index);
end;

procedure TKMLFolder.AddFolderEvent(Sender: TObject);
var
  tmp: TKMLFolder;
begin
  tmp := AddFolder;
  tmp.TreeNodeShape := TreeNodeShape.AddChildObject('Folder', tmp);
  tmp.ToTree;
end;

{  Placemark}
constructor TKMLPlacemark.Create(par: TXML = nil);
begin
  inherited Create(par);
end;

destructor TKMLPlacemark.Destroy;
begin
  if FLookAtExsit then
    FLookAt.Free;
  if FGeometryExsit then
    FGeometry.Free;
  if FExtendedDataExsit then
    FExtendedData.Free;
  inherited;
end;

procedure TKMLPlacemark.AfterCreate;
begin
  inherited;
end;

procedure TKMLPlacemark.FromXML(node: IXMLNode);
var
  I: Integer;
  nodeTmp: IXMLNode;
begin
  try
    FNameExsit := False;
    FVisibilityExsit := False;
    FDescriptionExsit := False;
    FLookAtExsit := False;
    FStyleUrlExsit := False;
    FGeometryExsit := False;
    FExtendedDataExsit := False;
    for I := 0 to node.ChildNodes.Count - 1 do
    begin
      nodeTmp := node.ChildNodes.Get(I);
      if nodeTmp.NodeName = 'name' then
      begin
        FName := nodeTmp.Text;
        FNameExsit := True;
      end
      else if nodeTmp.NodeName = 'visibility' then
      begin
        FVisibility := StrToIntDef(nodeTmp.Text, 0);;
        FVisibilityExsit := True;
      end
      else if nodeTmp.NodeName = 'description' then
      begin
        FDescription := nodeTmp.Text;
        FDescriptionExsit := True;
      end
      else if nodeTmp.NodeName = 'LookAt' then
      begin
        FLookAt := TKMLLookAt.Create(Self);
        FLookAt.FromXML(nodeTmp);
        FLookAtExsit := True;
      end
      else if nodeTmp.NodeName = 'styleUrl' then
      begin
        FStyleUrl := nodeTmp.Text;
        FStyleUrlExsit := True;
      end
      else if nodeTmp.NodeName = 'Point' then
      begin
        FGeometry := TKMLPoint.Create(Self);
        FGeometry.FromXML(nodeTmp);
        FGeometryExsit := True;
      end
      else if nodeTmp.NodeName = 'Polygon' then
      begin
        FGeometry := TKMLPolygon.Create(Self);
        FGeometry.FromXML(nodeTmp);
        FGeometryExsit := True;
      end
      else if nodeTmp.NodeName = 'LinearRing' then
      begin
        FGeometry := TKMLLinearRing.Create(Self);
        FGeometry.FromXML(nodeTmp);
        FGeometryExsit := True;
      end
      else if nodeTmp.NodeName = 'LineString' then
      begin
        FGeometry := TKMLLineString.Create(Self);
        FGeometry.FromXML(nodeTmp);
        FGeometryExsit := True;
      end
      else if nodeTmp.NodeName = 'MultiGeometry' then
      begin
        FGeometry := TKMLMultiGeometry.Create(Self);
        FGeometry.FromXML(nodeTmp);
        FGeometryExsit := True;
      end
      else if nodeTmp.NodeName = 'ExtendedData' then
      begin
        FExtendedData := TKMLExtendedData.Create(Self);
        FExtendedData.FromXML(nodeTmp);
        FExtendedDataExsit := True;
      end;
    end;
    for I := 0 to node.AttributeNodes.Count - 1 do
    begin
      nodeTmp := node.AttributeNodes.Get(I);
;
    end;
  except
    raise Exception.Create('Placemark Read XML Error!' + node.Xml);
  end;
end;

function TKMLPlacemark.ToXML(par: IXMLNode; pt: string): IXMLNode;
var
  doc: IXMLDocument;
  node: IXMLNode;
  NameTmp: IXMLNode;
  VisibilityTmp: IXMLNode;
  DescriptionTmp: IXMLNode;
  StyleUrlTmp: IXMLNode;
  I: Integer;
begin
  try
    doc := par.OwnerDocument;
  if (pt = '') or (pt[1] = '#') then
    pt := 'Placemark';
    node := doc.CreateNode(pt);
    par.ChildNodes.Add(node);
    if FNameExsit then
    begin
      NameTmp := doc.CreateNode('name', ntElement);
      NameTmp.NodeValue := FName;
      node.ChildNodes.Add(NameTmp);
    end;
    if FVisibilityExsit then
    begin
      VisibilityTmp := doc.CreateNode('visibility', ntElement);
      VisibilityTmp.NodeValue := IntToStr(FVisibility);
      node.ChildNodes.Add(VisibilityTmp);
    end;
    if FDescriptionExsit then
    begin
      DescriptionTmp := doc.CreateNode('description', ntElement);
      DescriptionTmp.NodeValue := FDescription;
      node.ChildNodes.Add(DescriptionTmp);
    end;
    if FLookAtExsit then
      FLookAt.ToXML(node, 'LookAt');
    if FStyleUrlExsit then
    begin
      StyleUrlTmp := doc.CreateNode('styleUrl', ntElement);
      StyleUrlTmp.NodeValue := FStyleUrl;
      node.ChildNodes.Add(StyleUrlTmp);
    end;
    if FGeometryExsit then
      FGeometry.ToXML(node, '#Optional');
    if FExtendedDataExsit then
      FExtendedData.ToXML(node, 'ExtendedData');
    Result := node;
  except
    raise Exception.Create('XML2Code Write XML Error!');
  end;
end;

procedure TKMLPlacemark.ToTree;
var
  I: Integer;
begin
  if not Assigned(TreeNodeShape) then
  begin
    Exit;
  end;
  TreeNodeShape.Clear;
  TreeNodeShape.Data := Self;
  TreeNodeShape.Text.Clear;
  TreeNodeShape.Text.Add('Placemark');
  if NameExsit then
    TreeNodeShape.AddChild('Name:' + FName);
  if VisibilityExsit then
    TreeNodeShape.AddChild('Visibility:' + IntToStr(FVisibility));
  if DescriptionExsit then
    TreeNodeShape.AddChild('Description:' + FDescription);
  if LookAtExsit then
  begin
    LookAt.TreeNodeShape := TreeNodeShape.AddChildObject('LookAt', LookAt);
    LookAt.ToTree;
  end;
  if StyleUrlExsit then
    TreeNodeShape.AddChild('StyleUrl:' + FStyleUrl);
  if GeometryExsit then
  begin
    Geometry.TreeNodeShape := TreeNodeShape.AddChildObject('Geometry', Geometry);
    Geometry.ToTree;
  end;
  if ExtendedDataExsit then
  begin
    ExtendedData.TreeNodeShape := TreeNodeShape.AddChildObject('ExtendedData', ExtendedData);
    ExtendedData.ToTree;
  end;
end;

procedure TKMLPlacemark.ToPopupMenu(Sender: TObject);
var
  pop: TPopupMenu;
  NameAddMenu: TMenuItem;
  VisibilityAddMenu: TMenuItem;
  DescriptionAddMenu: TMenuItem;
  LookAtAddMenu: TMenuItem;
  StyleUrlAddMenu: TMenuItem;
  GeometryAddMenu: TMenuItem;
  PointAddMenu: TMenuItem;
  PolygonAddMenu: TMenuItem;
  LinearRingAddMenu: TMenuItem;
  LineStringAddMenu: TMenuItem;
  MultiGeometryAddMenu: TMenuItem;
  ExtendedDataAddMenu: TMenuItem;
begin
  if Assigned(Sender) and (Sender is TPopupMenu) then
  begin
    pop := TPopupMenu(Sender);
    pop.Items.Clear;
    NameAddMenu := TMenuItem.Create(pop);
    NameAddMenu.Caption := 'Add Name';
    NameAddMenu.OnClick := AddNameEvent;
    pop.Items.Add(NameAddMenu);
    VisibilityAddMenu := TMenuItem.Create(pop);
    VisibilityAddMenu.Caption := 'Add Visibility';
    VisibilityAddMenu.OnClick := AddVisibilityEvent;
    pop.Items.Add(VisibilityAddMenu);
    DescriptionAddMenu := TMenuItem.Create(pop);
    DescriptionAddMenu.Caption := 'Add Description';
    DescriptionAddMenu.OnClick := AddDescriptionEvent;
    pop.Items.Add(DescriptionAddMenu);
    LookAtAddMenu := TMenuItem.Create(pop);
    LookAtAddMenu.Caption := 'Add LookAt';
    LookAtAddMenu.OnClick := AddLookAtEvent;
    pop.Items.Add(LookAtAddMenu);
    StyleUrlAddMenu := TMenuItem.Create(pop);
    StyleUrlAddMenu.Caption := 'Add StyleUrl';
    StyleUrlAddMenu.OnClick := AddStyleUrlEvent;
    pop.Items.Add(StyleUrlAddMenu);
    GeometryAddMenu := TMenuItem.Create(pop);
    GeometryAddMenu.Caption := 'Add Geometry';
    pop.Items.Add(GeometryAddMenu);
    PointAddMenu := TMenuItem.Create(GeometryAddMenu);
    PointAddMenu.Caption := 'Point';
    PointAddMenu.OnClick := AddPointEvent;
    GeometryAddMenu.Add(PointAddMenu);
    PolygonAddMenu := TMenuItem.Create(GeometryAddMenu);
    PolygonAddMenu.Caption := 'Polygon';
    PolygonAddMenu.OnClick := AddPolygonEvent;
    GeometryAddMenu.Add(PolygonAddMenu);
    LinearRingAddMenu := TMenuItem.Create(GeometryAddMenu);
    LinearRingAddMenu.Caption := 'LinearRing';
    LinearRingAddMenu.OnClick := AddLinearRingEvent;
    GeometryAddMenu.Add(LinearRingAddMenu);
    LineStringAddMenu := TMenuItem.Create(GeometryAddMenu);
    LineStringAddMenu.Caption := 'LineString';
    LineStringAddMenu.OnClick := AddLineStringEvent;
    GeometryAddMenu.Add(LineStringAddMenu);
    MultiGeometryAddMenu := TMenuItem.Create(GeometryAddMenu);
    MultiGeometryAddMenu.Caption := 'MultiGeometry';
    MultiGeometryAddMenu.OnClick := AddMultiGeometryEvent;
    GeometryAddMenu.Add(MultiGeometryAddMenu);
    ExtendedDataAddMenu := TMenuItem.Create(pop);
    ExtendedDataAddMenu.Caption := 'Add ExtendedData';
    ExtendedDataAddMenu.OnClick := AddExtendedDataEvent;
    pop.Items.Add(ExtendedDataAddMenu);
  end;
end;

procedure TKMLPlacemark.ToInspector;
var
  Names_Value: TStringList;
  Types_Value: TList<XMLTypes>;
  _Values_Value: TStringList;
begin
  if not Assigned(ins) then
    Exit;
  Names_Value := TStringList.Create;
  Types_Value := TList<XMLTypes>.Create;
  _Values_Value := TStringList.Create;
  Names_Value.Add('Name');
  Types_Value.Add(xs_string);
  _Values_Value.Add(Name);
  Names_Value.Add('Visibility');
  Types_Value.Add(xs_integer);
  _Values_Value.Add(IntToStr(Visibility));
  Names_Value.Add('Description');
  Types_Value.Add(xs_string);
  _Values_Value.Add(Description);
  Names_Value.Add('StyleUrl');
  Types_Value.Add(xs_string);
  _Values_Value.Add(StyleUrl);
  TXMLInspector(ins).SetData(Names_Value, _Values_Value, Types_Value, Self);
end;

procedure TKMLPlacemark.CopyFrom(source: TKMLPlacemark);
var
  I:Integer;
begin
  FName := source.Name;
  FNameExsit := source.FNameExsit;
  FVisibility := source.Visibility;
  FVisibilityExsit := source.FVisibilityExsit;
  FDescription := source.Description;
  FDescriptionExsit := source.FDescriptionExsit;
  FLookAtExsit := source.FLookAtExsit;
  if source.FLookAtExsit then
  begin
    AddLookAt.CopyFrom(source.LookAt);
  end;
  FStyleUrl := source.StyleUrl;
  FStyleUrlExsit := source.FStyleUrlExsit;
  FGeometryExsit := source.FGeometryExsit;
  if source.FGeometryExsit then
  begin
    if source.Geometry is TKMLPoint then
      AddPoint.CopyFrom(source.Geometry);
    if source.Geometry is TKMLPolygon then
      AddPolygon.CopyFrom(source.Geometry);
    if source.Geometry is TKMLLinearRing then
      AddLinearRing.CopyFrom(source.Geometry);
    if source.Geometry is TKMLLineString then
      AddLineString.CopyFrom(source.Geometry);
    if source.Geometry is TKMLMultiGeometry then
      AddMultiGeometry.CopyFrom(source.Geometry);
  end;
  FExtendedDataExsit := source.FExtendedDataExsit;
  if source.FExtendedDataExsit then
  begin
    AddExtendedData.CopyFrom(source.ExtendedData);
  end;
  Self.ToTree;
end;

procedure TKMLPlacemark.PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False);
var
  I: Integer;
begin
  if (items.Count = 1) and (items[0] is TKMLPlacemark) and (not isCut) then
  begin
    Self.CopyFrom(TKMLPlacemark(items[0]));
    Self.ToTree;
    Exit;
  end;
  for I := 0 to items.Count - 1 do
  begin
  end;
  Self.ToTree;
end;

procedure TKMLPlacemark.ChildDeleteEvent(del: TXMLTreeNode);
begin
end;
procedure TKMLPlacemark.SetXMLProperty(Index: Integer; _Value: String);
begin
  case index of
    0:
      begin
        Name := _Value;
      end;
    1:
      begin
        Visibility := StrToIntDef(_Value, 0);;
      end;
    2:
      begin
        Description := _Value;
      end;
    3:
      begin
        StyleUrl := _Value;
      end;
  end;
  ToTree;
end;

function TKMLPlacemark.AddName: String;
begin;
  Result := FName;
  FNameExsit := True;
end;

procedure TKMLPlacemark.SetName(const _Value: String);
begin
  FNameExsit := True;
  FName := _Value;
end;

procedure TKMLPlacemark.NameRemove;
begin
  if FNameExsit then
  begin
    FNameExsit := False;
  end;
end;

procedure TKMLPlacemark.AddNameEvent(Sender: TObject);
begin
  AddName;
end;

function TKMLPlacemark.AddVisibility: Integer;
begin;
  Result := FVisibility;
  FVisibilityExsit := True;
end;

procedure TKMLPlacemark.SetVisibility(const _Value: Integer);
begin
  FVisibilityExsit := True;
  FVisibility := _Value;
end;

procedure TKMLPlacemark.VisibilityRemove;
begin
  if FVisibilityExsit then
  begin
    FVisibilityExsit := False;
  end;
end;

procedure TKMLPlacemark.AddVisibilityEvent(Sender: TObject);
begin
  AddVisibility;
end;

function TKMLPlacemark.AddDescription: String;
begin;
  Result := FDescription;
  FDescriptionExsit := True;
end;

procedure TKMLPlacemark.SetDescription(const _Value: String);
begin
  FDescriptionExsit := True;
  FDescription := _Value;
end;

procedure TKMLPlacemark.DescriptionRemove;
begin
  if FDescriptionExsit then
  begin
    FDescriptionExsit := False;
  end;
end;

procedure TKMLPlacemark.AddDescriptionEvent(Sender: TObject);
begin
  AddDescription;
end;

function TKMLPlacemark.AddLookAt: TKMLLookAt;
begin;
  if not FLookAtExsit then
    FLookAt := TKMLLookAt.Create(Self);
  Result := FLookAt;
  FLookAtExsit := True;
end;

procedure TKMLPlacemark.SetLookAt(const _Value: TKMLLookAt);
begin
  if FLookAtExsit then
    FLookAt.Free;
  FLookAtExsit := True;
  FLookAt := _Value;
  FLookAt.Parent := Self;
end;

procedure TKMLPlacemark.LookAtRemove;
begin
  if FLookAtExsit then
  begin
    FLookAt.Free;
    FLookAtExsit := False;
  end;
end;

procedure TKMLPlacemark.AddLookAtEvent(Sender: TObject);
begin
  AddLookAt;
  FLookAt.ToTree;
end;

function TKMLPlacemark.AddStyleUrl: String;
begin;
  Result := FStyleUrl;
  FStyleUrlExsit := True;
end;

procedure TKMLPlacemark.SetStyleUrl(const _Value: String);
begin
  FStyleUrlExsit := True;
  FStyleUrl := _Value;
end;

procedure TKMLPlacemark.StyleUrlRemove;
begin
  if FStyleUrlExsit then
  begin
    FStyleUrlExsit := False;
  end;
end;

procedure TKMLPlacemark.AddStyleUrlEvent(Sender: TObject);
begin
  AddStyleUrl;
end;

function TKMLPlacemark.AddPoint: TKMLPoint;
begin;
  if not FGeometryExsit then
  FGeometry.Free;
  FGeometry := TKMLPoint.Create(Self);
  Result := TKMLPoint(FGeometry);
  FGeometryExsit := True;
end;

function TKMLPlacemark.AddPolygon: TKMLPolygon;
begin;
  if not FGeometryExsit then
  FGeometry.Free;
  FGeometry := TKMLPolygon.Create(Self);
  Result := TKMLPolygon(FGeometry);
  FGeometryExsit := True;
end;

function TKMLPlacemark.AddLinearRing: TKMLLinearRing;
begin;
  if not FGeometryExsit then
  FGeometry.Free;
  FGeometry := TKMLLinearRing.Create(Self);
  Result := TKMLLinearRing(FGeometry);
  FGeometryExsit := True;
end;

function TKMLPlacemark.AddLineString: TKMLLineString;
begin;
  if not FGeometryExsit then
  FGeometry.Free;
  FGeometry := TKMLLineString.Create(Self);
  Result := TKMLLineString(FGeometry);
  FGeometryExsit := True;
end;

function TKMLPlacemark.AddMultiGeometry: TKMLMultiGeometry;
begin;
  if not FGeometryExsit then
  FGeometry.Free;
  FGeometry := TKMLMultiGeometry.Create(Self);
  Result := TKMLMultiGeometry(FGeometry);
  FGeometryExsit := True;
end;

procedure TKMLPlacemark.SetGeometry(const _Value: TKMLGeometry);
begin
  if FGeometryExsit then
    FGeometry.Free;
  FGeometryExsit := True;
  FGeometry := _Value;
  FGeometry.Parent := Self;
end;

procedure TKMLPlacemark.GeometryRemove;
begin
  if FGeometryExsit then
  begin
    FGeometry.Free;
    FGeometryExsit := False;
  end;
end;

procedure TKMLPlacemark.AddPointEvent(Sender: TObject);
begin
  AddPoint;
  FGeometry.ToTree;
end;

procedure TKMLPlacemark.AddPolygonEvent(Sender: TObject);
begin
  AddPolygon;
  FGeometry.ToTree;
end;

procedure TKMLPlacemark.AddLinearRingEvent(Sender: TObject);
begin
  AddLinearRing;
  FGeometry.ToTree;
end;

procedure TKMLPlacemark.AddLineStringEvent(Sender: TObject);
begin
  AddLineString;
  FGeometry.ToTree;
end;

procedure TKMLPlacemark.AddMultiGeometryEvent(Sender: TObject);
begin
  AddMultiGeometry;
  FGeometry.ToTree;
end;

function TKMLPlacemark.AddExtendedData: TKMLExtendedData;
begin;
  if not FExtendedDataExsit then
    FExtendedData := TKMLExtendedData.Create(Self);
  Result := FExtendedData;
  FExtendedDataExsit := True;
end;

procedure TKMLPlacemark.SetExtendedData(const _Value: TKMLExtendedData);
begin
  if FExtendedDataExsit then
    FExtendedData.Free;
  FExtendedDataExsit := True;
  FExtendedData := _Value;
  FExtendedData.Parent := Self;
end;

procedure TKMLPlacemark.ExtendedDataRemove;
begin
  if FExtendedDataExsit then
  begin
    FExtendedData.Free;
    FExtendedDataExsit := False;
  end;
end;

procedure TKMLPlacemark.AddExtendedDataEvent(Sender: TObject);
begin
  AddExtendedData;
  FExtendedData.ToTree;
end;

{  Geometry}
constructor TKMLGeometry.Create(par: TXML = nil);
begin
  inherited Create(par);
end;

destructor TKMLGeometry.Destroy;
begin
  inherited;
end;

procedure TKMLGeometry.AfterCreate;
begin
  inherited;
end;

procedure TKMLGeometry.FromXML(node: IXMLNode);
var
  I: Integer;
  nodeTmp: IXMLNode;
begin
  try
    for I := 0 to node.ChildNodes.Count - 1 do
    begin
      nodeTmp := node.ChildNodes.Get(I);
;
    end;
    for I := 0 to node.AttributeNodes.Count - 1 do
    begin
      nodeTmp := node.AttributeNodes.Get(I);
;
    end;
  except
    raise Exception.Create('Geometry Read XML Error!' + node.Xml);
  end;
end;

function TKMLGeometry.ToXML(par: IXMLNode; pt: string): IXMLNode;
var
  doc: IXMLDocument;
  node: IXMLNode;
  I: Integer;
begin
  try
    doc := par.OwnerDocument;
  if (pt = '') or (pt[1] = '#') then
    pt := '#Optional';
    node := doc.CreateNode(pt);
    par.ChildNodes.Add(node);
    Result := node;
  except
    raise Exception.Create('XML2Code Write XML Error!');
  end;
end;

function TKMLGeometry.AppendToXML(node: IXMLNode; pt: string): IXMLNode;
var
  doc: IXMLDocument;
  I: Integer;
begin
  try
    doc := node.OwnerDocument;
    Result := node;
  except
    raise Exception.Create('XML2Code Write XML Error!');
  end;
end;

procedure TKMLGeometry.ToTree;
var
  I: Integer;
begin
  if not Assigned(TreeNodeShape) then
  begin
    Exit;
  end;
  TreeNodeShape.Clear;
  TreeNodeShape.Data := Self;
  TreeNodeShape.Text.Clear;
  TreeNodeShape.Text.Add('Geometry');
end;

procedure TKMLGeometry.ToPopupMenu(Sender: TObject);
var
  pop: TPopupMenu;
begin
  if Assigned(Sender) and (Sender is TPopupMenu) then
  begin
    pop := TPopupMenu(Sender);
    pop.Items.Clear;
  end;
end;

procedure TKMLGeometry.ToInspector;
var
  Names_Value: TStringList;
  Types_Value: TList<XMLTypes>;
  _Values_Value: TStringList;
begin
  if not Assigned(ins) then
    Exit;
  Names_Value := TStringList.Create;
  Types_Value := TList<XMLTypes>.Create;
  _Values_Value := TStringList.Create;
  TXMLInspector(ins).SetData(Names_Value, _Values_Value, Types_Value, Self);
end;

procedure TKMLGeometry.CopyFrom(source: TKMLGeometry);
var
  I:Integer;
begin
  Self.ToTree;
end;

procedure TKMLGeometry.PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False);
var
  I: Integer;
begin
  if (items.Count = 1) and (items[0] is TKMLGeometry) and (not isCut) then
  begin
    Self.CopyFrom(TKMLGeometry(items[0]));
    Self.ToTree;
    Exit;
  end;
  for I := 0 to items.Count - 1 do
  begin
  end;
  Self.ToTree;
end;

procedure TKMLGeometry.ChildDeleteEvent(del: TXMLTreeNode);
begin
end;
procedure TKMLGeometry.SetXMLProperty(Index: Integer; _Value: String);
begin
end;

{  MultiGeometry}
constructor TKMLMultiGeometry.Create(par: TXML = nil);
begin
  inherited Create(par);
  FGeometrys := TList<TKMLGeometry>.Create;
end;

destructor TKMLMultiGeometry.Destroy;
begin
  GeometryClear;
  FGeometrys.Free;
  inherited;
end;

procedure TKMLMultiGeometry.AfterCreate;
begin
  inherited;
  FGeometrys := TList<TKMLGeometry>.Create;
end;

procedure TKMLMultiGeometry.FromXML(node: IXMLNode);
var
  I: Integer;
  nodeTmp: IXMLNode;
  GeometryTmp: TKMLGeometry;
begin
  try
    inherited FromXML(node);
    GeometryClear;
    for I := 0 to node.ChildNodes.Count - 1 do
    begin
      nodeTmp := node.ChildNodes.Get(I);
      if nodeTmp.NodeName = 'Point' then
      begin
        GeometryTmp := TKMLPoint.Create(Self);
        GeometryTmp.FromXML(nodeTmp);
        FGeometrys.Add(GeometryTmp);
      end
      else if nodeTmp.NodeName = 'Polygon' then
      begin
        GeometryTmp := TKMLPolygon.Create(Self);
        GeometryTmp.FromXML(nodeTmp);
        FGeometrys.Add(GeometryTmp);
      end
      else if nodeTmp.NodeName = 'LinearRing' then
      begin
        GeometryTmp := TKMLLinearRing.Create(Self);
        GeometryTmp.FromXML(nodeTmp);
        FGeometrys.Add(GeometryTmp);
      end
      else if nodeTmp.NodeName = 'LineString' then
      begin
        GeometryTmp := TKMLLineString.Create(Self);
        GeometryTmp.FromXML(nodeTmp);
        FGeometrys.Add(GeometryTmp);
      end
      else if nodeTmp.NodeName = 'MultiGeometry' then
      begin
        GeometryTmp := TKMLMultiGeometry.Create(Self);
        GeometryTmp.FromXML(nodeTmp);
        FGeometrys.Add(GeometryTmp);
      end;
    end;
    for I := 0 to node.AttributeNodes.Count - 1 do
    begin
      nodeTmp := node.AttributeNodes.Get(I);
;
    end;
  except
    raise Exception.Create('MultiGeometry Read XML Error!' + node.Xml);
  end;
end;

function TKMLMultiGeometry.ToXML(par: IXMLNode; pt: string): IXMLNode;
var
  doc: IXMLDocument;
  node: IXMLNode;
  I: Integer;
begin
  try
    doc := par.OwnerDocument;
  if (pt = '') or (pt[1] = '#') then
    pt := 'MultiGeometry';
    node := doc.CreateNode(pt);
    par.ChildNodes.Add(node);
    inherited AppendToXML(node);
    for I := 0 to FGeometrys.Count - 1 do
       FGeometrys.Items[I].ToXML(node, '#Optional');
    Result := node;
  except
    raise Exception.Create('XML2Code Write XML Error!');
  end;
end;

procedure TKMLMultiGeometry.ToTree;
var
  I: Integer;
begin
  if not Assigned(TreeNodeShape) then
  begin
    Exit;
  end;
  TreeNodeShape.Clear;
  TreeNodeShape.Data := Self;
  TreeNodeShape.Text.Clear;
  TreeNodeShape.Text.Add('MultiGeometry');
  for I := 0 to GeometryCount - 1 do
  begin
    Geometrys[I].TreeNodeShape := TreeNodeShape.AddChildObject('Geometry', Geometry[I]);
    Geometry[I].ToTree;
  end;
end;

procedure TKMLMultiGeometry.ToPopupMenu(Sender: TObject);
var
  pop: TPopupMenu;
  GeometryAddMenu: TMenuItem;
  PointAddMenu: TMenuItem;
  PolygonAddMenu: TMenuItem;
  LinearRingAddMenu: TMenuItem;
  LineStringAddMenu: TMenuItem;
  MultiGeometryAddMenu: TMenuItem;
begin
  if Assigned(Sender) and (Sender is TPopupMenu) then
  begin
    pop := TPopupMenu(Sender);
    pop.Items.Clear;
    GeometryAddMenu := TMenuItem.Create(pop);
    GeometryAddMenu.Caption := 'Add Geometry';
    pop.Items.Add(GeometryAddMenu);
    PointAddMenu := TMenuItem.Create(GeometryAddMenu);
    PointAddMenu.Caption := 'Point';
    PointAddMenu.OnClick := AddPointEvent;
    GeometryAddMenu.Add(PointAddMenu);
    PolygonAddMenu := TMenuItem.Create(GeometryAddMenu);
    PolygonAddMenu.Caption := 'Polygon';
    PolygonAddMenu.OnClick := AddPolygonEvent;
    GeometryAddMenu.Add(PolygonAddMenu);
    LinearRingAddMenu := TMenuItem.Create(GeometryAddMenu);
    LinearRingAddMenu.Caption := 'LinearRing';
    LinearRingAddMenu.OnClick := AddLinearRingEvent;
    GeometryAddMenu.Add(LinearRingAddMenu);
    LineStringAddMenu := TMenuItem.Create(GeometryAddMenu);
    LineStringAddMenu.Caption := 'LineString';
    LineStringAddMenu.OnClick := AddLineStringEvent;
    GeometryAddMenu.Add(LineStringAddMenu);
    MultiGeometryAddMenu := TMenuItem.Create(GeometryAddMenu);
    MultiGeometryAddMenu.Caption := 'MultiGeometry';
    MultiGeometryAddMenu.OnClick := AddMultiGeometryEvent;
    GeometryAddMenu.Add(MultiGeometryAddMenu);
  end;
end;

procedure TKMLMultiGeometry.ToInspector;
var
  Names_Value: TStringList;
  Types_Value: TList<XMLTypes>;
  _Values_Value: TStringList;
begin
  if not Assigned(ins) then
    Exit;
  Names_Value := TStringList.Create;
  Types_Value := TList<XMLTypes>.Create;
  _Values_Value := TStringList.Create;
  TXMLInspector(ins).SetData(Names_Value, _Values_Value, Types_Value, Self);
end;

procedure TKMLMultiGeometry.CopyFrom(source: TKMLGeometry);
var
  I:Integer;
begin
    GeometryClear;
  for I := 0 to GeometryCount - 1 do
  begin
    if TKMLMultiGeometry(source).Geometry[I] is TKMLPoint then
      AddPoint.CopyFrom(TKMLMultiGeometry(source).Geometry[I]);
    if TKMLMultiGeometry(source).Geometry[I] is TKMLPolygon then
      AddPolygon.CopyFrom(TKMLMultiGeometry(source).Geometry[I]);
    if TKMLMultiGeometry(source).Geometry[I] is TKMLLinearRing then
      AddLinearRing.CopyFrom(TKMLMultiGeometry(source).Geometry[I]);
    if TKMLMultiGeometry(source).Geometry[I] is TKMLLineString then
      AddLineString.CopyFrom(TKMLMultiGeometry(source).Geometry[I]);
    if TKMLMultiGeometry(source).Geometry[I] is TKMLMultiGeometry then
      AddMultiGeometry.CopyFrom(TKMLMultiGeometry(source).Geometry[I]);
  end;
  Self.ToTree;
end;

procedure TKMLMultiGeometry.PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False);
var
  I: Integer;
  tmpGeometry: TKMLGeometry;
begin
  if (items.Count = 1) and (items[0] is TKMLMultiGeometry) and (not isCut) then
  begin
    Self.CopyFrom(TKMLMultiGeometry(items[0]));
    Self.ToTree;
    Exit;
  end;
  for I := 0 to items.Count - 1 do
  begin
    if items[I] is TKMLGeometry then
    begin
      tmpGeometry := TKMLGeometry(items[I]);
      if isCut then
      begin
        TKMLMultiGeometry(tmpGeometry.Parent).Geometrys.Remove(tmpGeometry);
        Self.Geometrys.Add(tmpGeometry);
        tmpGeometry.Parent := Self;
        tmpGeometry.TreeNodeShape.Parent := Self.TreeNodeShape;
      end
      else
      begin
        if tmpGeometry is TKMLPoint then
          AddPoint.CopyFrom(tmpGeometry);
        if tmpGeometry is TKMLPolygon then
          AddPolygon.CopyFrom(tmpGeometry);
        if tmpGeometry is TKMLLinearRing then
          AddLinearRing.CopyFrom(tmpGeometry);
        if tmpGeometry is TKMLLineString then
          AddLineString.CopyFrom(tmpGeometry);
        if tmpGeometry is TKMLMultiGeometry then
          AddMultiGeometry.CopyFrom(tmpGeometry);
      end;
    end;
  end;
  Self.ToTree;
end;

procedure TKMLMultiGeometry.ChildDeleteEvent(del: TXMLTreeNode);
begin
  if del is TKMLGeometry then
  begin
    Self.RemoveGeometry(TKMLGeometry(del));
  end;
end;
procedure TKMLMultiGeometry.SetXMLProperty(Index: Integer; _Value: String);
begin
end;

function TKMLMultiGeometry.AddPoint: TKMLPoint;
var
  Pointtmp: TKMLPoint;
begin;
  Pointtmp := TKMLPoint.Create(Self);
  FGeometrys.Add(Pointtmp);
  Result := Pointtmp;
end;

function TKMLMultiGeometry.AddPolygon: TKMLPolygon;
var
  Polygontmp: TKMLPolygon;
begin;
  Polygontmp := TKMLPolygon.Create(Self);
  FGeometrys.Add(Polygontmp);
  Result := Polygontmp;
end;

function TKMLMultiGeometry.AddLinearRing: TKMLLinearRing;
var
  LinearRingtmp: TKMLLinearRing;
begin;
  LinearRingtmp := TKMLLinearRing.Create(Self);
  FGeometrys.Add(LinearRingtmp);
  Result := LinearRingtmp;
end;

function TKMLMultiGeometry.AddLineString: TKMLLineString;
var
  LineStringtmp: TKMLLineString;
begin;
  LineStringtmp := TKMLLineString.Create(Self);
  FGeometrys.Add(LineStringtmp);
  Result := LineStringtmp;
end;

function TKMLMultiGeometry.AddMultiGeometry: TKMLMultiGeometry;
var
  MultiGeometrytmp: TKMLMultiGeometry;
begin;
  MultiGeometrytmp := TKMLMultiGeometry.Create(Self);
  FGeometrys.Add(MultiGeometrytmp);
  Result := MultiGeometrytmp;
end;

procedure TKMLMultiGeometry.SetGeometrys(const _Value: TList<TKMLGeometry>);
begin
  GeometryClear;
  FGeometrys := _Value;
end;

procedure TKMLMultiGeometry.GeometryClear;
begin
  while FGeometrys.Count > 0 do
  begin
    FGeometrys.Items[0].Free;
    FGeometrys.Delete(0);
  end;
end;

function TKMLMultiGeometry.GeometryCount: Integer;
begin
  Result := FGeometrys.Count;
end;

function TKMLMultiGeometry.GetGeometry(Index: Integer): TKMLGeometry;
begin
  Result := FGeometrys[Index];
end;

procedure TKMLMultiGeometry.SetGeometry(Index: Integer;
  const _Value: TKMLGeometry);
begin
  _Value.Parent := Self;
  FGeometrys[Index].Free;
  FGeometrys[Index] := _Value;
end;

procedure TKMLMultiGeometry.RemoveGeometry(_Value: TKMLGeometry);
begin
  FGeometrys.Remove(_Value);
  _Value.Free;
end;

procedure TKMLMultiGeometry.DeleteGeometry(Index: Integer);
begin
  FGeometrys.Items[Index].Free;
  FGeometrys.Delete(Index);
end;

procedure TKMLMultiGeometry.AddPointEvent(Sender: TObject);
var
  tmp: TKMLPoint;
begin
  tmp := AddPoint;
  tmp.TreeNodeShape := TreeNodeShape.AddChildObject('Point', tmp);
  tmp.ToTree;
end;

procedure TKMLMultiGeometry.AddPolygonEvent(Sender: TObject);
var
  tmp: TKMLPolygon;
begin
  tmp := AddPolygon;
  tmp.TreeNodeShape := TreeNodeShape.AddChildObject('Polygon', tmp);
  tmp.ToTree;
end;

procedure TKMLMultiGeometry.AddLinearRingEvent(Sender: TObject);
var
  tmp: TKMLLinearRing;
begin
  tmp := AddLinearRing;
  tmp.TreeNodeShape := TreeNodeShape.AddChildObject('LinearRing', tmp);
  tmp.ToTree;
end;

procedure TKMLMultiGeometry.AddLineStringEvent(Sender: TObject);
var
  tmp: TKMLLineString;
begin
  tmp := AddLineString;
  tmp.TreeNodeShape := TreeNodeShape.AddChildObject('LineString', tmp);
  tmp.ToTree;
end;

procedure TKMLMultiGeometry.AddMultiGeometryEvent(Sender: TObject);
var
  tmp: TKMLMultiGeometry;
begin
  tmp := AddMultiGeometry;
  tmp.TreeNodeShape := TreeNodeShape.AddChildObject('MultiGeometry', tmp);
  tmp.ToTree;
end;

{  Point}
constructor TKMLPoint.Create(par: TXML = nil);
begin
  inherited Create(par);
end;

destructor TKMLPoint.Destroy;
begin
  inherited;
end;

procedure TKMLPoint.AfterCreate;
begin
  inherited;
end;

procedure TKMLPoint.FromXML(node: IXMLNode);
var
  I: Integer;
  nodeTmp: IXMLNode;
begin
  try
    inherited FromXML(node);
    FExtrudeExsit := False;
    FAltitudeModeExsit := False;
    for I := 0 to node.ChildNodes.Count - 1 do
    begin
      nodeTmp := node.ChildNodes.Get(I);
      if nodeTmp.NodeName = 'extrude' then
      begin
        FExtrude := nodeTmp.Text;
        FExtrudeExsit := True;
      end
      else if nodeTmp.NodeName = 'altitudeMode' then
      begin
        FAltitudeMode := nodeTmp.Text;
        FAltitudeModeExsit := True;
      end
      else if nodeTmp.NodeName = 'coordinates' then
      begin
        FCoordinates := StringToCoordinates(nodeTmp.Text);
      end;
    end;
    for I := 0 to node.AttributeNodes.Count - 1 do
    begin
      nodeTmp := node.AttributeNodes.Get(I);
;
    end;
  except
    raise Exception.Create('Point Read XML Error!' + node.Xml);
  end;
end;

function TKMLPoint.ToXML(par: IXMLNode; pt: string): IXMLNode;
var
  doc: IXMLDocument;
  node: IXMLNode;
  ExtrudeTmp: IXMLNode;
  AltitudeModeTmp: IXMLNode;
  CoordinatesTmp: IXMLNode;
  I: Integer;
begin
  try
    doc := par.OwnerDocument;
  if (pt = '') or (pt[1] = '#') then
    pt := 'Point';
    node := doc.CreateNode(pt);
    par.ChildNodes.Add(node);
    inherited AppendToXML(node);
    if FExtrudeExsit then
    begin
      ExtrudeTmp := doc.CreateNode('extrude', ntElement);
      ExtrudeTmp.NodeValue := FExtrude;
      node.ChildNodes.Add(ExtrudeTmp);
    end;
    if FAltitudeModeExsit then
    begin
      AltitudeModeTmp := doc.CreateNode('altitudeMode', ntElement);
      AltitudeModeTmp.NodeValue := FAltitudeMode;
      node.ChildNodes.Add(AltitudeModeTmp);
    end;
    CoordinatesTmp := doc.CreateNode('coordinates', ntElement);
    CoordinatesTmp.NodeValue := CoordinatesToString(FCoordinates);
    node.ChildNodes.Add(CoordinatesTmp);
    Result := node;
  except
    raise Exception.Create('XML2Code Write XML Error!');
  end;
end;

procedure TKMLPoint.ToTree;
var
  I: Integer;
begin
  if not Assigned(TreeNodeShape) then
  begin
    Exit;
  end;
  TreeNodeShape.Clear;
  TreeNodeShape.Data := Self;
  TreeNodeShape.Text.Clear;
  TreeNodeShape.Text.Add('Point');
  if ExtrudeExsit then
    TreeNodeShape.AddChild('Extrude:' + FExtrude);
  if AltitudeModeExsit then
    TreeNodeShape.AddChild('AltitudeMode:' + FAltitudeMode);
  TreeNodeShape.AddChild('Coordinates:' + CoordinatesToString(FCoordinates));
end;

procedure TKMLPoint.ToPopupMenu(Sender: TObject);
var
  pop: TPopupMenu;
  ExtrudeAddMenu: TMenuItem;
  AltitudeModeAddMenu: TMenuItem;
begin
  if Assigned(Sender) and (Sender is TPopupMenu) then
  begin
    pop := TPopupMenu(Sender);
    pop.Items.Clear;
    ExtrudeAddMenu := TMenuItem.Create(pop);
    ExtrudeAddMenu.Caption := 'Add Extrude';
    ExtrudeAddMenu.OnClick := AddExtrudeEvent;
    pop.Items.Add(ExtrudeAddMenu);
    AltitudeModeAddMenu := TMenuItem.Create(pop);
    AltitudeModeAddMenu.Caption := 'Add AltitudeMode';
    AltitudeModeAddMenu.OnClick := AddAltitudeModeEvent;
    pop.Items.Add(AltitudeModeAddMenu);
  end;
end;

procedure TKMLPoint.ToInspector;
var
  Names_Value: TStringList;
  Types_Value: TList<XMLTypes>;
  _Values_Value: TStringList;
begin
  if not Assigned(ins) then
    Exit;
  Names_Value := TStringList.Create;
  Types_Value := TList<XMLTypes>.Create;
  _Values_Value := TStringList.Create;
  Names_Value.Add('Extrude');
  Types_Value.Add(xs_string);
  _Values_Value.Add(Extrude);
  Names_Value.Add('AltitudeMode');
  Types_Value.Add(xs_string);
  _Values_Value.Add(AltitudeMode);
  Names_Value.Add('Coordinates');
  Types_Value.Add(xml_ArrayCoordinates);
  _Values_Value.Add(CoordinatesToString(Coordinates));
  TXMLInspector(ins).SetData(Names_Value, _Values_Value, Types_Value, Self);
end;

procedure TKMLPoint.CopyFrom(source: TKMLGeometry);
var
  I:Integer;
begin
  FExtrude := TKMLPoint(source).Extrude;
  FExtrudeExsit := TKMLPoint(source).FExtrudeExsit;
  FAltitudeMode := TKMLPoint(source).AltitudeMode;
  FAltitudeModeExsit := TKMLPoint(source).FAltitudeModeExsit;
  FCoordinates := TKMLPoint(source).Coordinates;
  Self.ToTree;
end;

procedure TKMLPoint.PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False);
var
  I: Integer;
begin
  if (items.Count = 1) and (items[0] is TKMLPoint) and (not isCut) then
  begin
    Self.CopyFrom(TKMLPoint(items[0]));
    Self.ToTree;
    Exit;
  end;
  for I := 0 to items.Count - 1 do
  begin
  end;
  Self.ToTree;
end;

procedure TKMLPoint.ChildDeleteEvent(del: TXMLTreeNode);
begin
end;
procedure TKMLPoint.SetXMLProperty(Index: Integer; _Value: String);
begin
  case index of
    0:
      begin
        Extrude := _Value;
      end;
    1:
      begin
        AltitudeMode := _Value;
      end;
    2:
      begin
        Coordinates := StringToCoordinates(_Value);
      end;
  end;
  ToTree;
end;

function TKMLPoint.AddExtrude: String;
begin;
  Result := FExtrude;
  FExtrudeExsit := True;
end;

procedure TKMLPoint.SetExtrude(const _Value: String);
begin
  FExtrudeExsit := True;
  FExtrude := _Value;
end;

procedure TKMLPoint.ExtrudeRemove;
begin
  if FExtrudeExsit then
  begin
    FExtrudeExsit := False;
  end;
end;

procedure TKMLPoint.AddExtrudeEvent(Sender: TObject);
begin
  AddExtrude;
end;

function TKMLPoint.AddAltitudeMode: String;
begin;
  Result := FAltitudeMode;
  FAltitudeModeExsit := True;
end;

procedure TKMLPoint.SetAltitudeMode(const _Value: String);
begin
  FAltitudeModeExsit := True;
  FAltitudeMode := _Value;
end;

procedure TKMLPoint.AltitudeModeRemove;
begin
  if FAltitudeModeExsit then
  begin
    FAltitudeModeExsit := False;
  end;
end;

procedure TKMLPoint.AddAltitudeModeEvent(Sender: TObject);
begin
  AddAltitudeMode;
end;

procedure TKMLPoint.SetCoordinates(const _Value: ArrayCoordinates);
begin
  FCoordinates := _Value;
end;

{  Polygon}
constructor TKMLPolygon.Create(par: TXML = nil);
begin
  inherited Create(par);
  FOuterBoundaryIss := TList<TKMLBoundary>.Create;
  FInnerBoundaryIss := TList<TKMLBoundary>.Create;
end;

destructor TKMLPolygon.Destroy;
begin
  OuterBoundaryIsClear;
  FOuterBoundaryIss.Free;
  InnerBoundaryIsClear;
  FInnerBoundaryIss.Free;
  inherited;
end;

procedure TKMLPolygon.AfterCreate;
begin
  inherited;
  FOuterBoundaryIss := TList<TKMLBoundary>.Create;
  FInnerBoundaryIss := TList<TKMLBoundary>.Create;
end;

procedure TKMLPolygon.FromXML(node: IXMLNode);
var
  I: Integer;
  nodeTmp: IXMLNode;
  OuterBoundaryIsTmp: TKMLBoundary;
  InnerBoundaryIsTmp: TKMLBoundary;
begin
  try
    inherited FromXML(node);
    FExtrudeExsit := False;
    FAltitudeModeExsit := False;
    OuterBoundaryIsClear;
    InnerBoundaryIsClear;
    FTessellateExsit := False;
    for I := 0 to node.ChildNodes.Count - 1 do
    begin
      nodeTmp := node.ChildNodes.Get(I);
      if nodeTmp.NodeName = 'extrude' then
      begin
        FExtrude := nodeTmp.Text;
        FExtrudeExsit := True;
      end
      else if nodeTmp.NodeName = 'altitudeMode' then
      begin
        FAltitudeMode := nodeTmp.Text;
        FAltitudeModeExsit := True;
      end
      else if nodeTmp.NodeName = 'outerBoundaryIs' then
      begin
        OuterBoundaryIsTmp := TKMLBoundary.Create(Self);
        OuterBoundaryIsTmp.FromXML(nodeTmp);
        FOuterBoundaryIss.Add(OuterBoundaryIsTmp);
      end
      else if nodeTmp.NodeName = 'innerBoundaryIs' then
      begin
        InnerBoundaryIsTmp := TKMLBoundary.Create(Self);
        InnerBoundaryIsTmp.FromXML(nodeTmp);
        FInnerBoundaryIss.Add(InnerBoundaryIsTmp);
      end
      else if nodeTmp.NodeName = 'tessellate' then
      begin
        FTessellate := nodeTmp.Text;
        FTessellateExsit := True;
      end;
    end;
    for I := 0 to node.AttributeNodes.Count - 1 do
    begin
      nodeTmp := node.AttributeNodes.Get(I);
;
    end;
  except
    raise Exception.Create('Polygon Read XML Error!' + node.Xml);
  end;
end;

function TKMLPolygon.ToXML(par: IXMLNode; pt: string): IXMLNode;
var
  doc: IXMLDocument;
  node: IXMLNode;
  ExtrudeTmp: IXMLNode;
  AltitudeModeTmp: IXMLNode;
  TessellateTmp: IXMLNode;
  I: Integer;
begin
  try
    doc := par.OwnerDocument;
  if (pt = '') or (pt[1] = '#') then
    pt := 'Polygon';
    node := doc.CreateNode(pt);
    par.ChildNodes.Add(node);
    inherited AppendToXML(node);
    if FExtrudeExsit then
    begin
      ExtrudeTmp := doc.CreateNode('extrude', ntElement);
      ExtrudeTmp.NodeValue := FExtrude;
      node.ChildNodes.Add(ExtrudeTmp);
    end;
    if FAltitudeModeExsit then
    begin
      AltitudeModeTmp := doc.CreateNode('altitudeMode', ntElement);
      AltitudeModeTmp.NodeValue := FAltitudeMode;
      node.ChildNodes.Add(AltitudeModeTmp);
    end;
    for I := 0 to FOuterBoundaryIss.Count - 1 do
       FOuterBoundaryIss.Items[I].ToXML(node, 'outerBoundaryIs');
    for I := 0 to FInnerBoundaryIss.Count - 1 do
       FInnerBoundaryIss.Items[I].ToXML(node, 'innerBoundaryIs');
    if FTessellateExsit then
    begin
      TessellateTmp := doc.CreateNode('tessellate', ntElement);
      TessellateTmp.NodeValue := FTessellate;
      node.ChildNodes.Add(TessellateTmp);
    end;
    Result := node;
  except
    raise Exception.Create('XML2Code Write XML Error!');
  end;
end;

procedure TKMLPolygon.ToTree;
var
  I: Integer;
begin
  if not Assigned(TreeNodeShape) then
  begin
    Exit;
  end;
  TreeNodeShape.Clear;
  TreeNodeShape.Data := Self;
  TreeNodeShape.Text.Clear;
  TreeNodeShape.Text.Add('Polygon');
  if ExtrudeExsit then
    TreeNodeShape.AddChild('Extrude:' + FExtrude);
  if AltitudeModeExsit then
    TreeNodeShape.AddChild('AltitudeMode:' + FAltitudeMode);
  for I := 0 to OuterBoundaryIsCount - 1 do
  begin
    OuterBoundaryIss[I].TreeNodeShape := TreeNodeShape.AddChildObject('OuterBoundaryIs', OuterBoundaryIs[I]);
    OuterBoundaryIs[I].ToTree;
  end;
  for I := 0 to InnerBoundaryIsCount - 1 do
  begin
    InnerBoundaryIss[I].TreeNodeShape := TreeNodeShape.AddChildObject('InnerBoundaryIs', InnerBoundaryIs[I]);
    InnerBoundaryIs[I].ToTree;
  end;
  if TessellateExsit then
    TreeNodeShape.AddChild('Tessellate:' + FTessellate);
end;

procedure TKMLPolygon.ToPopupMenu(Sender: TObject);
var
  pop: TPopupMenu;
  ExtrudeAddMenu: TMenuItem;
  AltitudeModeAddMenu: TMenuItem;
  OuterBoundaryIsAddMenu: TMenuItem;
  InnerBoundaryIsAddMenu: TMenuItem;
  TessellateAddMenu: TMenuItem;
begin
  if Assigned(Sender) and (Sender is TPopupMenu) then
  begin
    pop := TPopupMenu(Sender);
    pop.Items.Clear;
    ExtrudeAddMenu := TMenuItem.Create(pop);
    ExtrudeAddMenu.Caption := 'Add Extrude';
    ExtrudeAddMenu.OnClick := AddExtrudeEvent;
    pop.Items.Add(ExtrudeAddMenu);
    AltitudeModeAddMenu := TMenuItem.Create(pop);
    AltitudeModeAddMenu.Caption := 'Add AltitudeMode';
    AltitudeModeAddMenu.OnClick := AddAltitudeModeEvent;
    pop.Items.Add(AltitudeModeAddMenu);
    OuterBoundaryIsAddMenu := TMenuItem.Create(pop);
    OuterBoundaryIsAddMenu.Caption := 'Add OuterBoundaryIs';
    OuterBoundaryIsAddMenu.OnClick := AddOuterBoundaryIsEvent;
    pop.Items.Add(OuterBoundaryIsAddMenu);
    InnerBoundaryIsAddMenu := TMenuItem.Create(pop);
    InnerBoundaryIsAddMenu.Caption := 'Add InnerBoundaryIs';
    InnerBoundaryIsAddMenu.OnClick := AddInnerBoundaryIsEvent;
    pop.Items.Add(InnerBoundaryIsAddMenu);
    TessellateAddMenu := TMenuItem.Create(pop);
    TessellateAddMenu.Caption := 'Add Tessellate';
    TessellateAddMenu.OnClick := AddTessellateEvent;
    pop.Items.Add(TessellateAddMenu);
  end;
end;

procedure TKMLPolygon.ToInspector;
var
  Names_Value: TStringList;
  Types_Value: TList<XMLTypes>;
  _Values_Value: TStringList;
begin
  if not Assigned(ins) then
    Exit;
  Names_Value := TStringList.Create;
  Types_Value := TList<XMLTypes>.Create;
  _Values_Value := TStringList.Create;
  Names_Value.Add('Extrude');
  Types_Value.Add(xs_string);
  _Values_Value.Add(Extrude);
  Names_Value.Add('AltitudeMode');
  Types_Value.Add(xs_string);
  _Values_Value.Add(AltitudeMode);
  Names_Value.Add('Tessellate');
  Types_Value.Add(xs_string);
  _Values_Value.Add(Tessellate);
  TXMLInspector(ins).SetData(Names_Value, _Values_Value, Types_Value, Self);
end;

procedure TKMLPolygon.CopyFrom(source: TKMLGeometry);
var
  I:Integer;
begin
  FExtrude := TKMLPolygon(source).Extrude;
  FExtrudeExsit := TKMLPolygon(source).FExtrudeExsit;
  FAltitudeMode := TKMLPolygon(source).AltitudeMode;
  FAltitudeModeExsit := TKMLPolygon(source).FAltitudeModeExsit;
    OuterBoundaryIsClear;
  for I := 0 to OuterBoundaryIsCount - 1 do
  begin
    AddOuterBoundaryIs.CopyFrom(TKMLPolygon(source).OuterBoundaryIs[I]);
  end;
    InnerBoundaryIsClear;
  for I := 0 to InnerBoundaryIsCount - 1 do
  begin
    AddInnerBoundaryIs.CopyFrom(TKMLPolygon(source).InnerBoundaryIs[I]);
  end;
  FTessellate := TKMLPolygon(source).Tessellate;
  FTessellateExsit := TKMLPolygon(source).FTessellateExsit;
  Self.ToTree;
end;

procedure TKMLPolygon.PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False);
var
  I: Integer;
  tmpOuterBoundaryIs: TKMLBoundary;
  tmpInnerBoundaryIs: TKMLBoundary;
begin
  if (items.Count = 1) and (items[0] is TKMLPolygon) and (not isCut) then
  begin
    Self.CopyFrom(TKMLPolygon(items[0]));
    Self.ToTree;
    Exit;
  end;
  for I := 0 to items.Count - 1 do
  begin
    if items[I] is TKMLBoundary then
    begin
      tmpOuterBoundaryIs := TKMLBoundary(items[I]);
      if isCut then
      begin
        TKMLPolygon(tmpOuterBoundaryIs.Parent).OuterBoundaryIss.Remove(tmpOuterBoundaryIs);
        Self.OuterBoundaryIss.Add(tmpOuterBoundaryIs);
        tmpOuterBoundaryIs.Parent := Self;
        tmpOuterBoundaryIs.TreeNodeShape.Parent := Self.TreeNodeShape;
      end
      else
      begin
        AddOuterBoundaryIs.CopyFrom(tmpOuterBoundaryIs);
      end;
    end;
    if items[I] is TKMLBoundary then
    begin
      tmpInnerBoundaryIs := TKMLBoundary(items[I]);
      if isCut then
      begin
        TKMLPolygon(tmpInnerBoundaryIs.Parent).InnerBoundaryIss.Remove(tmpInnerBoundaryIs);
        Self.InnerBoundaryIss.Add(tmpInnerBoundaryIs);
        tmpInnerBoundaryIs.Parent := Self;
        tmpInnerBoundaryIs.TreeNodeShape.Parent := Self.TreeNodeShape;
      end
      else
      begin
        AddInnerBoundaryIs.CopyFrom(tmpInnerBoundaryIs);
      end;
    end;
  end;
  Self.ToTree;
end;

procedure TKMLPolygon.ChildDeleteEvent(del: TXMLTreeNode);
begin
  if del is TKMLBoundary then
  begin
    Self.RemoveOuterBoundaryIs(TKMLBoundary(del));
  end;
  if del is TKMLBoundary then
  begin
    Self.RemoveInnerBoundaryIs(TKMLBoundary(del));
  end;
end;
procedure TKMLPolygon.SetXMLProperty(Index: Integer; _Value: String);
begin
  case index of
    0:
      begin
        Extrude := _Value;
      end;
    1:
      begin
        AltitudeMode := _Value;
      end;
    2:
      begin
        Tessellate := _Value;
      end;
  end;
  ToTree;
end;

function TKMLPolygon.AddExtrude: String;
begin;
  Result := FExtrude;
  FExtrudeExsit := True;
end;

procedure TKMLPolygon.SetExtrude(const _Value: String);
begin
  FExtrudeExsit := True;
  FExtrude := _Value;
end;

procedure TKMLPolygon.ExtrudeRemove;
begin
  if FExtrudeExsit then
  begin
    FExtrudeExsit := False;
  end;
end;

procedure TKMLPolygon.AddExtrudeEvent(Sender: TObject);
begin
  AddExtrude;
end;

function TKMLPolygon.AddAltitudeMode: String;
begin;
  Result := FAltitudeMode;
  FAltitudeModeExsit := True;
end;

procedure TKMLPolygon.SetAltitudeMode(const _Value: String);
begin
  FAltitudeModeExsit := True;
  FAltitudeMode := _Value;
end;

procedure TKMLPolygon.AltitudeModeRemove;
begin
  if FAltitudeModeExsit then
  begin
    FAltitudeModeExsit := False;
  end;
end;

procedure TKMLPolygon.AddAltitudeModeEvent(Sender: TObject);
begin
  AddAltitudeMode;
end;

function TKMLPolygon.AddOuterBoundaryIs: TKMLBoundary;
var
  OuterBoundaryIstmp: TKMLBoundary;
begin;
  OuterBoundaryIstmp := TKMLBoundary.Create(Self);
  FOuterBoundaryIss.Add(OuterBoundaryIstmp);
  Result := OuterBoundaryIstmp;
end;

procedure TKMLPolygon.SetOuterBoundaryIss(const _Value: TList<TKMLBoundary>);
begin
  OuterBoundaryIsClear;
  FOuterBoundaryIss := _Value;
end;

procedure TKMLPolygon.OuterBoundaryIsClear;
begin
  while FOuterBoundaryIss.Count > 0 do
  begin
    FOuterBoundaryIss.Items[0].Free;
    FOuterBoundaryIss.Delete(0);
  end;
end;

function TKMLPolygon.OuterBoundaryIsCount: Integer;
begin
  Result := FOuterBoundaryIss.Count;
end;

function TKMLPolygon.GetOuterBoundaryIs(Index: Integer): TKMLBoundary;
begin
  Result := FOuterBoundaryIss[Index];
end;

procedure TKMLPolygon.SetOuterBoundaryIs(Index: Integer;
  const _Value: TKMLBoundary);
begin
  _Value.Parent := Self;
  FOuterBoundaryIss[Index].Free;
  FOuterBoundaryIss[Index] := _Value;
end;

procedure TKMLPolygon.RemoveOuterBoundaryIs(_Value: TKMLBoundary);
begin
  FOuterBoundaryIss.Remove(_Value);
  _Value.Free;
end;

procedure TKMLPolygon.DeleteOuterBoundaryIs(Index: Integer);
begin
  FOuterBoundaryIss.Items[Index].Free;
  FOuterBoundaryIss.Delete(Index);
end;

procedure TKMLPolygon.AddOuterBoundaryIsEvent(Sender: TObject);
var
  tmp: TKMLBoundary;
begin
  tmp := AddOuterBoundaryIs;
  tmp.TreeNodeShape := TreeNodeShape.AddChildObject('OuterBoundaryIs', tmp);
  tmp.ToTree;
end;

function TKMLPolygon.AddInnerBoundaryIs: TKMLBoundary;
var
  InnerBoundaryIstmp: TKMLBoundary;
begin;
  InnerBoundaryIstmp := TKMLBoundary.Create(Self);
  FInnerBoundaryIss.Add(InnerBoundaryIstmp);
  Result := InnerBoundaryIstmp;
end;

procedure TKMLPolygon.SetInnerBoundaryIss(const _Value: TList<TKMLBoundary>);
begin
  InnerBoundaryIsClear;
  FInnerBoundaryIss := _Value;
end;

procedure TKMLPolygon.InnerBoundaryIsClear;
begin
  while FInnerBoundaryIss.Count > 0 do
  begin
    FInnerBoundaryIss.Items[0].Free;
    FInnerBoundaryIss.Delete(0);
  end;
end;

function TKMLPolygon.InnerBoundaryIsCount: Integer;
begin
  Result := FInnerBoundaryIss.Count;
end;

function TKMLPolygon.GetInnerBoundaryIs(Index: Integer): TKMLBoundary;
begin
  Result := FInnerBoundaryIss[Index];
end;

procedure TKMLPolygon.SetInnerBoundaryIs(Index: Integer;
  const _Value: TKMLBoundary);
begin
  _Value.Parent := Self;
  FInnerBoundaryIss[Index].Free;
  FInnerBoundaryIss[Index] := _Value;
end;

procedure TKMLPolygon.RemoveInnerBoundaryIs(_Value: TKMLBoundary);
begin
  FInnerBoundaryIss.Remove(_Value);
  _Value.Free;
end;

procedure TKMLPolygon.DeleteInnerBoundaryIs(Index: Integer);
begin
  FInnerBoundaryIss.Items[Index].Free;
  FInnerBoundaryIss.Delete(Index);
end;

procedure TKMLPolygon.AddInnerBoundaryIsEvent(Sender: TObject);
var
  tmp: TKMLBoundary;
begin
  tmp := AddInnerBoundaryIs;
  tmp.TreeNodeShape := TreeNodeShape.AddChildObject('InnerBoundaryIs', tmp);
  tmp.ToTree;
end;

function TKMLPolygon.AddTessellate: String;
begin;
  Result := FTessellate;
  FTessellateExsit := True;
end;

procedure TKMLPolygon.SetTessellate(const _Value: String);
begin
  FTessellateExsit := True;
  FTessellate := _Value;
end;

procedure TKMLPolygon.TessellateRemove;
begin
  if FTessellateExsit then
  begin
    FTessellateExsit := False;
  end;
end;

procedure TKMLPolygon.AddTessellateEvent(Sender: TObject);
begin
  AddTessellate;
end;

{  Boundary}
constructor TKMLBoundary.Create(par: TXML = nil);
begin
  inherited Create(par);
  FLinearRing := TKMLLinearRing.Create(Self);
end;

destructor TKMLBoundary.Destroy;
begin
  FLinearRing.Free;
  inherited;
end;

procedure TKMLBoundary.AfterCreate;
begin
  inherited;
  FLinearRing := TKMLLinearRing.Create(Self);
end;

procedure TKMLBoundary.FromXML(node: IXMLNode);
var
  I: Integer;
  nodeTmp: IXMLNode;
begin
  try
    for I := 0 to node.ChildNodes.Count - 1 do
    begin
      nodeTmp := node.ChildNodes.Get(I);
      if nodeTmp.NodeName = 'LinearRing' then
      begin
        FLinearRing := TKMLLinearRing.Create(Self);
        FLinearRing.FromXML(nodeTmp);
      end;
    end;
    for I := 0 to node.AttributeNodes.Count - 1 do
    begin
      nodeTmp := node.AttributeNodes.Get(I);
;
    end;
  except
    raise Exception.Create('Boundary Read XML Error!' + node.Xml);
  end;
end;

function TKMLBoundary.ToXML(par: IXMLNode; pt: string): IXMLNode;
var
  doc: IXMLDocument;
  node: IXMLNode;
  I: Integer;
begin
  try
    doc := par.OwnerDocument;
  if (pt = '') or (pt[1] = '#') then
    pt := 'Boundary';
    node := doc.CreateNode(pt);
    par.ChildNodes.Add(node);
    FLinearRing.ToXML(node, 'LinearRing');
    Result := node;
  except
    raise Exception.Create('XML2Code Write XML Error!');
  end;
end;

procedure TKMLBoundary.ToTree;
var
  I: Integer;
begin
  if not Assigned(TreeNodeShape) then
  begin
    Exit;
  end;
  TreeNodeShape.Clear;
  TreeNodeShape.Data := Self;
  TreeNodeShape.Text.Clear;
  TreeNodeShape.Text.Add('Boundary');
  LinearRing.TreeNodeShape := TreeNodeShape.AddChildObject('LinearRing', LinearRing);
  LinearRing.ToTree;
end;

procedure TKMLBoundary.ToPopupMenu(Sender: TObject);
var
  pop: TPopupMenu;
begin
  if Assigned(Sender) and (Sender is TPopupMenu) then
  begin
    pop := TPopupMenu(Sender);
    pop.Items.Clear;
  end;
end;

procedure TKMLBoundary.ToInspector;
var
  Names_Value: TStringList;
  Types_Value: TList<XMLTypes>;
  _Values_Value: TStringList;
begin
  if not Assigned(ins) then
    Exit;
  Names_Value := TStringList.Create;
  Types_Value := TList<XMLTypes>.Create;
  _Values_Value := TStringList.Create;
  TXMLInspector(ins).SetData(Names_Value, _Values_Value, Types_Value, Self);
end;

procedure TKMLBoundary.CopyFrom(source: TKMLBoundary);
var
  I:Integer;
begin
    LinearRing.CopyFrom(source.LinearRing);
  Self.ToTree;
end;

procedure TKMLBoundary.PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False);
var
  I: Integer;
begin
  if (items.Count = 1) and (items[0] is TKMLBoundary) and (not isCut) then
  begin
    Self.CopyFrom(TKMLBoundary(items[0]));
    Self.ToTree;
    Exit;
  end;
  for I := 0 to items.Count - 1 do
  begin
  end;
  Self.ToTree;
end;

procedure TKMLBoundary.ChildDeleteEvent(del: TXMLTreeNode);
begin
end;
procedure TKMLBoundary.SetXMLProperty(Index: Integer; _Value: String);
begin
end;

procedure TKMLBoundary.SetLinearRing(const _Value: TKMLLinearRing);
begin
  FLinearRing.Free;
  FLinearRing := _Value;
  FLinearRing.Parent := Self;
end;

{  LinearRing}
constructor TKMLLinearRing.Create(par: TXML = nil);
begin
  inherited Create(par);
end;

destructor TKMLLinearRing.Destroy;
begin
  inherited;
end;

procedure TKMLLinearRing.AfterCreate;
begin
  inherited;
end;

procedure TKMLLinearRing.FromXML(node: IXMLNode);
var
  I: Integer;
  nodeTmp: IXMLNode;
begin
  try
    inherited FromXML(node);
    for I := 0 to node.ChildNodes.Count - 1 do
    begin
      nodeTmp := node.ChildNodes.Get(I);
      if nodeTmp.NodeName = 'coordinates' then
      begin
        FCoordinates := StringToCoordinates(nodeTmp.Text);
      end;
    end;
    for I := 0 to node.AttributeNodes.Count - 1 do
    begin
      nodeTmp := node.AttributeNodes.Get(I);
;
    end;
  except
    raise Exception.Create('LinearRing Read XML Error!' + node.Xml);
  end;
end;

function TKMLLinearRing.ToXML(par: IXMLNode; pt: string): IXMLNode;
var
  doc: IXMLDocument;
  node: IXMLNode;
  CoordinatesTmp: IXMLNode;
  I: Integer;
begin
  try
    doc := par.OwnerDocument;
  if (pt = '') or (pt[1] = '#') then
    pt := 'LinearRing';
    node := doc.CreateNode(pt);
    par.ChildNodes.Add(node);
    inherited AppendToXML(node);
    CoordinatesTmp := doc.CreateNode('coordinates', ntElement);
    CoordinatesTmp.NodeValue := CoordinatesToString(FCoordinates);
    node.ChildNodes.Add(CoordinatesTmp);
    Result := node;
  except
    raise Exception.Create('XML2Code Write XML Error!');
  end;
end;

procedure TKMLLinearRing.ToTree;
var
  I: Integer;
begin
  if not Assigned(TreeNodeShape) then
  begin
    Exit;
  end;
  TreeNodeShape.Clear;
  TreeNodeShape.Data := Self;
  TreeNodeShape.Text.Clear;
  TreeNodeShape.Text.Add('LinearRing');
  TreeNodeShape.AddChild('Coordinates:' + CoordinatesToString(FCoordinates));
end;

procedure TKMLLinearRing.ToPopupMenu(Sender: TObject);
var
  pop: TPopupMenu;
begin
  if Assigned(Sender) and (Sender is TPopupMenu) then
  begin
    pop := TPopupMenu(Sender);
    pop.Items.Clear;
  end;
end;

procedure TKMLLinearRing.ToInspector;
var
  Names_Value: TStringList;
  Types_Value: TList<XMLTypes>;
  _Values_Value: TStringList;
begin
  if not Assigned(ins) then
    Exit;
  Names_Value := TStringList.Create;
  Types_Value := TList<XMLTypes>.Create;
  _Values_Value := TStringList.Create;
  Names_Value.Add('Coordinates');
  Types_Value.Add(xml_ArrayCoordinates);
  _Values_Value.Add(CoordinatesToString(Coordinates));
  TXMLInspector(ins).SetData(Names_Value, _Values_Value, Types_Value, Self);
end;

procedure TKMLLinearRing.CopyFrom(source: TKMLGeometry);
var
  I:Integer;
begin
  FCoordinates := TKMLLinearRing(source).Coordinates;
  Self.ToTree;
end;

procedure TKMLLinearRing.PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False);
var
  I: Integer;
begin
  if (items.Count = 1) and (items[0] is TKMLLinearRing) and (not isCut) then
  begin
    Self.CopyFrom(TKMLLinearRing(items[0]));
    Self.ToTree;
    Exit;
  end;
  for I := 0 to items.Count - 1 do
  begin
  end;
  Self.ToTree;
end;

procedure TKMLLinearRing.ChildDeleteEvent(del: TXMLTreeNode);
begin
end;
procedure TKMLLinearRing.SetXMLProperty(Index: Integer; _Value: String);
begin
  case index of
    0:
      begin
        Coordinates := StringToCoordinates(_Value);
      end;
  end;
  ToTree;
end;

procedure TKMLLinearRing.SetCoordinates(const _Value: ArrayCoordinates);
begin
  FCoordinates := _Value;
end;

{  LineString}
constructor TKMLLineString.Create(par: TXML = nil);
begin
  inherited Create(par);
end;

destructor TKMLLineString.Destroy;
begin
  inherited;
end;

procedure TKMLLineString.AfterCreate;
begin
  inherited;
end;

procedure TKMLLineString.FromXML(node: IXMLNode);
var
  I: Integer;
  nodeTmp: IXMLNode;
begin
  try
    inherited FromXML(node);
    FTessellateExsit := False;
    FAltitudeModeExsit := False;
    FExtrudeExsit := False;
    for I := 0 to node.ChildNodes.Count - 1 do
    begin
      nodeTmp := node.ChildNodes.Get(I);
      if nodeTmp.NodeName = 'tessellate' then
      begin
        FTessellate := nodeTmp.Text;
        FTessellateExsit := True;
      end
      else if nodeTmp.NodeName = 'altitudeMode' then
      begin
        FAltitudeMode := nodeTmp.Text;
        FAltitudeModeExsit := True;
      end
      else if nodeTmp.NodeName = 'extrude' then
      begin
        FExtrude := nodeTmp.Text;
        FExtrudeExsit := True;
      end
      else if nodeTmp.NodeName = 'coordinates' then
      begin
        FCoordinates := StringToCoordinates(nodeTmp.Text);
      end;
    end;
    for I := 0 to node.AttributeNodes.Count - 1 do
    begin
      nodeTmp := node.AttributeNodes.Get(I);
;
    end;
  except
    raise Exception.Create('LineString Read XML Error!' + node.Xml);
  end;
end;

function TKMLLineString.ToXML(par: IXMLNode; pt: string): IXMLNode;
var
  doc: IXMLDocument;
  node: IXMLNode;
  TessellateTmp: IXMLNode;
  AltitudeModeTmp: IXMLNode;
  ExtrudeTmp: IXMLNode;
  CoordinatesTmp: IXMLNode;
  I: Integer;
begin
  try
    doc := par.OwnerDocument;
  if (pt = '') or (pt[1] = '#') then
    pt := 'LineString';
    node := doc.CreateNode(pt);
    par.ChildNodes.Add(node);
    inherited AppendToXML(node);
    if FTessellateExsit then
    begin
      TessellateTmp := doc.CreateNode('tessellate', ntElement);
      TessellateTmp.NodeValue := FTessellate;
      node.ChildNodes.Add(TessellateTmp);
    end;
    if FAltitudeModeExsit then
    begin
      AltitudeModeTmp := doc.CreateNode('altitudeMode', ntElement);
      AltitudeModeTmp.NodeValue := FAltitudeMode;
      node.ChildNodes.Add(AltitudeModeTmp);
    end;
    if FExtrudeExsit then
    begin
      ExtrudeTmp := doc.CreateNode('extrude', ntElement);
      ExtrudeTmp.NodeValue := FExtrude;
      node.ChildNodes.Add(ExtrudeTmp);
    end;
    CoordinatesTmp := doc.CreateNode('coordinates', ntElement);
    CoordinatesTmp.NodeValue := CoordinatesToString(FCoordinates);
    node.ChildNodes.Add(CoordinatesTmp);
    Result := node;
  except
    raise Exception.Create('XML2Code Write XML Error!');
  end;
end;

procedure TKMLLineString.ToTree;
var
  I: Integer;
begin
  if not Assigned(TreeNodeShape) then
  begin
    Exit;
  end;
  TreeNodeShape.Clear;
  TreeNodeShape.Data := Self;
  TreeNodeShape.Text.Clear;
  TreeNodeShape.Text.Add('LineString');
  if TessellateExsit then
    TreeNodeShape.AddChild('Tessellate:' + FTessellate);
  if AltitudeModeExsit then
    TreeNodeShape.AddChild('AltitudeMode:' + FAltitudeMode);
  if ExtrudeExsit then
    TreeNodeShape.AddChild('Extrude:' + FExtrude);
  TreeNodeShape.AddChild('Coordinates:' + CoordinatesToString(FCoordinates));
end;

procedure TKMLLineString.ToPopupMenu(Sender: TObject);
var
  pop: TPopupMenu;
  TessellateAddMenu: TMenuItem;
  AltitudeModeAddMenu: TMenuItem;
  ExtrudeAddMenu: TMenuItem;
begin
  if Assigned(Sender) and (Sender is TPopupMenu) then
  begin
    pop := TPopupMenu(Sender);
    pop.Items.Clear;
    TessellateAddMenu := TMenuItem.Create(pop);
    TessellateAddMenu.Caption := 'Add Tessellate';
    TessellateAddMenu.OnClick := AddTessellateEvent;
    pop.Items.Add(TessellateAddMenu);
    AltitudeModeAddMenu := TMenuItem.Create(pop);
    AltitudeModeAddMenu.Caption := 'Add AltitudeMode';
    AltitudeModeAddMenu.OnClick := AddAltitudeModeEvent;
    pop.Items.Add(AltitudeModeAddMenu);
    ExtrudeAddMenu := TMenuItem.Create(pop);
    ExtrudeAddMenu.Caption := 'Add Extrude';
    ExtrudeAddMenu.OnClick := AddExtrudeEvent;
    pop.Items.Add(ExtrudeAddMenu);
  end;
end;

procedure TKMLLineString.ToInspector;
var
  Names_Value: TStringList;
  Types_Value: TList<XMLTypes>;
  _Values_Value: TStringList;
begin
  if not Assigned(ins) then
    Exit;
  Names_Value := TStringList.Create;
  Types_Value := TList<XMLTypes>.Create;
  _Values_Value := TStringList.Create;
  Names_Value.Add('Tessellate');
  Types_Value.Add(xs_string);
  _Values_Value.Add(Tessellate);
  Names_Value.Add('AltitudeMode');
  Types_Value.Add(xs_string);
  _Values_Value.Add(AltitudeMode);
  Names_Value.Add('Extrude');
  Types_Value.Add(xs_string);
  _Values_Value.Add(Extrude);
  Names_Value.Add('Coordinates');
  Types_Value.Add(xml_ArrayCoordinates);
  _Values_Value.Add(CoordinatesToString(Coordinates));
  TXMLInspector(ins).SetData(Names_Value, _Values_Value, Types_Value, Self);
end;

procedure TKMLLineString.CopyFrom(source: TKMLGeometry);
var
  I:Integer;
begin
  FTessellate := TKMLLineString(source).Tessellate;
  FTessellateExsit := TKMLLineString(source).FTessellateExsit;
  FAltitudeMode := TKMLLineString(source).AltitudeMode;
  FAltitudeModeExsit := TKMLLineString(source).FAltitudeModeExsit;
  FExtrude := TKMLLineString(source).Extrude;
  FExtrudeExsit := TKMLLineString(source).FExtrudeExsit;
  FCoordinates := TKMLLineString(source).Coordinates;
  Self.ToTree;
end;

procedure TKMLLineString.PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False);
var
  I: Integer;
begin
  if (items.Count = 1) and (items[0] is TKMLLineString) and (not isCut) then
  begin
    Self.CopyFrom(TKMLLineString(items[0]));
    Self.ToTree;
    Exit;
  end;
  for I := 0 to items.Count - 1 do
  begin
  end;
  Self.ToTree;
end;

procedure TKMLLineString.ChildDeleteEvent(del: TXMLTreeNode);
begin
end;
procedure TKMLLineString.SetXMLProperty(Index: Integer; _Value: String);
begin
  case index of
    0:
      begin
        Tessellate := _Value;
      end;
    1:
      begin
        AltitudeMode := _Value;
      end;
    2:
      begin
        Extrude := _Value;
      end;
    3:
      begin
        Coordinates := StringToCoordinates(_Value);
      end;
  end;
  ToTree;
end;

function TKMLLineString.AddTessellate: String;
begin;
  Result := FTessellate;
  FTessellateExsit := True;
end;

procedure TKMLLineString.SetTessellate(const _Value: String);
begin
  FTessellateExsit := True;
  FTessellate := _Value;
end;

procedure TKMLLineString.TessellateRemove;
begin
  if FTessellateExsit then
  begin
    FTessellateExsit := False;
  end;
end;

procedure TKMLLineString.AddTessellateEvent(Sender: TObject);
begin
  AddTessellate;
end;

function TKMLLineString.AddAltitudeMode: String;
begin;
  Result := FAltitudeMode;
  FAltitudeModeExsit := True;
end;

procedure TKMLLineString.SetAltitudeMode(const _Value: String);
begin
  FAltitudeModeExsit := True;
  FAltitudeMode := _Value;
end;

procedure TKMLLineString.AltitudeModeRemove;
begin
  if FAltitudeModeExsit then
  begin
    FAltitudeModeExsit := False;
  end;
end;

procedure TKMLLineString.AddAltitudeModeEvent(Sender: TObject);
begin
  AddAltitudeMode;
end;

function TKMLLineString.AddExtrude: String;
begin;
  Result := FExtrude;
  FExtrudeExsit := True;
end;

procedure TKMLLineString.SetExtrude(const _Value: String);
begin
  FExtrudeExsit := True;
  FExtrude := _Value;
end;

procedure TKMLLineString.ExtrudeRemove;
begin
  if FExtrudeExsit then
  begin
    FExtrudeExsit := False;
  end;
end;

procedure TKMLLineString.AddExtrudeEvent(Sender: TObject);
begin
  AddExtrude;
end;

procedure TKMLLineString.SetCoordinates(const _Value: ArrayCoordinates);
begin
  FCoordinates := _Value;
end;

{  LookAt}
constructor TKMLLookAt.Create(par: TXML = nil);
begin
  inherited Create(par);
end;

destructor TKMLLookAt.Destroy;
begin
  inherited;
end;

procedure TKMLLookAt.AfterCreate;
begin
  inherited;
end;

procedure TKMLLookAt.FromXML(node: IXMLNode);
var
  I: Integer;
  nodeTmp: IXMLNode;
begin
  try
    FLongitudeExsit := False;
    FLatitudeExsit := False;
    FAltitudeExsit := False;
    FHeadingExsit := False;
    FTiltExsit := False;
    FRangeExsit := False;
    for I := 0 to node.ChildNodes.Count - 1 do
    begin
      nodeTmp := node.ChildNodes.Get(I);
      if nodeTmp.NodeName = 'longitude' then
      begin
        FLongitude := StrToFloatDef(nodeTmp.Text, 0);;
        FLongitudeExsit := True;
      end
      else if nodeTmp.NodeName = 'latitude' then
      begin
        FLatitude := StrToFloatDef(nodeTmp.Text, 0);;
        FLatitudeExsit := True;
      end
      else if nodeTmp.NodeName = 'altitude' then
      begin
        FAltitude := StrToFloatDef(nodeTmp.Text, 0);;
        FAltitudeExsit := True;
      end
      else if nodeTmp.NodeName = 'heading' then
      begin
        FHeading := StrToFloatDef(nodeTmp.Text, 0);;
        FHeadingExsit := True;
      end
      else if nodeTmp.NodeName = 'tilt' then
      begin
        FTilt := StrToFloatDef(nodeTmp.Text, 0);;
        FTiltExsit := True;
      end
      else if nodeTmp.NodeName = 'range' then
      begin
        FRange := StrToFloatDef(nodeTmp.Text, 0);;
        FRangeExsit := True;
      end;
    end;
    for I := 0 to node.AttributeNodes.Count - 1 do
    begin
      nodeTmp := node.AttributeNodes.Get(I);
;
    end;
  except
    raise Exception.Create('LookAt Read XML Error!' + node.Xml);
  end;
end;

function TKMLLookAt.ToXML(par: IXMLNode; pt: string): IXMLNode;
var
  doc: IXMLDocument;
  node: IXMLNode;
  LongitudeTmp: IXMLNode;
  LatitudeTmp: IXMLNode;
  AltitudeTmp: IXMLNode;
  HeadingTmp: IXMLNode;
  TiltTmp: IXMLNode;
  RangeTmp: IXMLNode;
  I: Integer;
begin
  try
    doc := par.OwnerDocument;
  if (pt = '') or (pt[1] = '#') then
    pt := 'LookAt';
    node := doc.CreateNode(pt);
    par.ChildNodes.Add(node);
    if FLongitudeExsit then
    begin
      LongitudeTmp := doc.CreateNode('longitude', ntElement);
      LongitudeTmp.NodeValue := FloatToStr(FLongitude);
      node.ChildNodes.Add(LongitudeTmp);
    end;
    if FLatitudeExsit then
    begin
      LatitudeTmp := doc.CreateNode('latitude', ntElement);
      LatitudeTmp.NodeValue := FloatToStr(FLatitude);
      node.ChildNodes.Add(LatitudeTmp);
    end;
    if FAltitudeExsit then
    begin
      AltitudeTmp := doc.CreateNode('altitude', ntElement);
      AltitudeTmp.NodeValue := FloatToStr(FAltitude);
      node.ChildNodes.Add(AltitudeTmp);
    end;
    if FHeadingExsit then
    begin
      HeadingTmp := doc.CreateNode('heading', ntElement);
      HeadingTmp.NodeValue := FloatToStr(FHeading);
      node.ChildNodes.Add(HeadingTmp);
    end;
    if FTiltExsit then
    begin
      TiltTmp := doc.CreateNode('tilt', ntElement);
      TiltTmp.NodeValue := FloatToStr(FTilt);
      node.ChildNodes.Add(TiltTmp);
    end;
    if FRangeExsit then
    begin
      RangeTmp := doc.CreateNode('range', ntElement);
      RangeTmp.NodeValue := FloatToStr(FRange);
      node.ChildNodes.Add(RangeTmp);
    end;
    Result := node;
  except
    raise Exception.Create('XML2Code Write XML Error!');
  end;
end;

procedure TKMLLookAt.ToTree;
var
  I: Integer;
begin
  if not Assigned(TreeNodeShape) then
  begin
    Exit;
  end;
  TreeNodeShape.Clear;
  TreeNodeShape.Data := Self;
  TreeNodeShape.Text.Clear;
  TreeNodeShape.Text.Add('LookAt');
  if LongitudeExsit then
    TreeNodeShape.AddChild('Longitude:' + FloatToStr(FLongitude));
  if LatitudeExsit then
    TreeNodeShape.AddChild('Latitude:' + FloatToStr(FLatitude));
  if AltitudeExsit then
    TreeNodeShape.AddChild('Altitude:' + FloatToStr(FAltitude));
  if HeadingExsit then
    TreeNodeShape.AddChild('Heading:' + FloatToStr(FHeading));
  if TiltExsit then
    TreeNodeShape.AddChild('Tilt:' + FloatToStr(FTilt));
  if RangeExsit then
    TreeNodeShape.AddChild('Range:' + FloatToStr(FRange));
end;

procedure TKMLLookAt.ToPopupMenu(Sender: TObject);
var
  pop: TPopupMenu;
  LongitudeAddMenu: TMenuItem;
  LatitudeAddMenu: TMenuItem;
  AltitudeAddMenu: TMenuItem;
  HeadingAddMenu: TMenuItem;
  TiltAddMenu: TMenuItem;
  RangeAddMenu: TMenuItem;
begin
  if Assigned(Sender) and (Sender is TPopupMenu) then
  begin
    pop := TPopupMenu(Sender);
    pop.Items.Clear;
    LongitudeAddMenu := TMenuItem.Create(pop);
    LongitudeAddMenu.Caption := 'Add Longitude';
    LongitudeAddMenu.OnClick := AddLongitudeEvent;
    pop.Items.Add(LongitudeAddMenu);
    LatitudeAddMenu := TMenuItem.Create(pop);
    LatitudeAddMenu.Caption := 'Add Latitude';
    LatitudeAddMenu.OnClick := AddLatitudeEvent;
    pop.Items.Add(LatitudeAddMenu);
    AltitudeAddMenu := TMenuItem.Create(pop);
    AltitudeAddMenu.Caption := 'Add Altitude';
    AltitudeAddMenu.OnClick := AddAltitudeEvent;
    pop.Items.Add(AltitudeAddMenu);
    HeadingAddMenu := TMenuItem.Create(pop);
    HeadingAddMenu.Caption := 'Add Heading';
    HeadingAddMenu.OnClick := AddHeadingEvent;
    pop.Items.Add(HeadingAddMenu);
    TiltAddMenu := TMenuItem.Create(pop);
    TiltAddMenu.Caption := 'Add Tilt';
    TiltAddMenu.OnClick := AddTiltEvent;
    pop.Items.Add(TiltAddMenu);
    RangeAddMenu := TMenuItem.Create(pop);
    RangeAddMenu.Caption := 'Add Range';
    RangeAddMenu.OnClick := AddRangeEvent;
    pop.Items.Add(RangeAddMenu);
  end;
end;

procedure TKMLLookAt.ToInspector;
var
  Names_Value: TStringList;
  Types_Value: TList<XMLTypes>;
  _Values_Value: TStringList;
begin
  if not Assigned(ins) then
    Exit;
  Names_Value := TStringList.Create;
  Types_Value := TList<XMLTypes>.Create;
  _Values_Value := TStringList.Create;
  Names_Value.Add('Longitude');
  Types_Value.Add(xs_double);
  _Values_Value.Add(FloatToStr(Longitude));
  Names_Value.Add('Latitude');
  Types_Value.Add(xs_double);
  _Values_Value.Add(FloatToStr(Latitude));
  Names_Value.Add('Altitude');
  Types_Value.Add(xs_double);
  _Values_Value.Add(FloatToStr(Altitude));
  Names_Value.Add('Heading');
  Types_Value.Add(xs_double);
  _Values_Value.Add(FloatToStr(Heading));
  Names_Value.Add('Tilt');
  Types_Value.Add(xs_double);
  _Values_Value.Add(FloatToStr(Tilt));
  Names_Value.Add('Range');
  Types_Value.Add(xs_double);
  _Values_Value.Add(FloatToStr(Range));
  TXMLInspector(ins).SetData(Names_Value, _Values_Value, Types_Value, Self);
end;

procedure TKMLLookAt.CopyFrom(source: TKMLLookAt);
var
  I:Integer;
begin
  FLongitude := source.Longitude;
  FLongitudeExsit := source.FLongitudeExsit;
  FLatitude := source.Latitude;
  FLatitudeExsit := source.FLatitudeExsit;
  FAltitude := source.Altitude;
  FAltitudeExsit := source.FAltitudeExsit;
  FHeading := source.Heading;
  FHeadingExsit := source.FHeadingExsit;
  FTilt := source.Tilt;
  FTiltExsit := source.FTiltExsit;
  FRange := source.Range;
  FRangeExsit := source.FRangeExsit;
  Self.ToTree;
end;

procedure TKMLLookAt.PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False);
var
  I: Integer;
begin
  if (items.Count = 1) and (items[0] is TKMLLookAt) and (not isCut) then
  begin
    Self.CopyFrom(TKMLLookAt(items[0]));
    Self.ToTree;
    Exit;
  end;
  for I := 0 to items.Count - 1 do
  begin
  end;
  Self.ToTree;
end;

procedure TKMLLookAt.ChildDeleteEvent(del: TXMLTreeNode);
begin
end;
procedure TKMLLookAt.SetXMLProperty(Index: Integer; _Value: String);
begin
  case index of
    0:
      begin
        Longitude := StrToFloatDef(_Value, 0);;
      end;
    1:
      begin
        Latitude := StrToFloatDef(_Value, 0);;
      end;
    2:
      begin
        Altitude := StrToFloatDef(_Value, 0);;
      end;
    3:
      begin
        Heading := StrToFloatDef(_Value, 0);;
      end;
    4:
      begin
        Tilt := StrToFloatDef(_Value, 0);;
      end;
    5:
      begin
        Range := StrToFloatDef(_Value, 0);;
      end;
  end;
  ToTree;
end;

function TKMLLookAt.AddLongitude: Double;
begin;
  Result := FLongitude;
  FLongitudeExsit := True;
end;

procedure TKMLLookAt.SetLongitude(const _Value: Double);
begin
  FLongitudeExsit := True;
  FLongitude := _Value;
end;

procedure TKMLLookAt.LongitudeRemove;
begin
  if FLongitudeExsit then
  begin
    FLongitudeExsit := False;
  end;
end;

procedure TKMLLookAt.AddLongitudeEvent(Sender: TObject);
begin
  AddLongitude;
end;

function TKMLLookAt.AddLatitude: Double;
begin;
  Result := FLatitude;
  FLatitudeExsit := True;
end;

procedure TKMLLookAt.SetLatitude(const _Value: Double);
begin
  FLatitudeExsit := True;
  FLatitude := _Value;
end;

procedure TKMLLookAt.LatitudeRemove;
begin
  if FLatitudeExsit then
  begin
    FLatitudeExsit := False;
  end;
end;

procedure TKMLLookAt.AddLatitudeEvent(Sender: TObject);
begin
  AddLatitude;
end;

function TKMLLookAt.AddAltitude: Double;
begin;
  Result := FAltitude;
  FAltitudeExsit := True;
end;

procedure TKMLLookAt.SetAltitude(const _Value: Double);
begin
  FAltitudeExsit := True;
  FAltitude := _Value;
end;

procedure TKMLLookAt.AltitudeRemove;
begin
  if FAltitudeExsit then
  begin
    FAltitudeExsit := False;
  end;
end;

procedure TKMLLookAt.AddAltitudeEvent(Sender: TObject);
begin
  AddAltitude;
end;

function TKMLLookAt.AddHeading: Double;
begin;
  Result := FHeading;
  FHeadingExsit := True;
end;

procedure TKMLLookAt.SetHeading(const _Value: Double);
begin
  FHeadingExsit := True;
  FHeading := _Value;
end;

procedure TKMLLookAt.HeadingRemove;
begin
  if FHeadingExsit then
  begin
    FHeadingExsit := False;
  end;
end;

procedure TKMLLookAt.AddHeadingEvent(Sender: TObject);
begin
  AddHeading;
end;

function TKMLLookAt.AddTilt: Double;
begin;
  Result := FTilt;
  FTiltExsit := True;
end;

procedure TKMLLookAt.SetTilt(const _Value: Double);
begin
  FTiltExsit := True;
  FTilt := _Value;
end;

procedure TKMLLookAt.TiltRemove;
begin
  if FTiltExsit then
  begin
    FTiltExsit := False;
  end;
end;

procedure TKMLLookAt.AddTiltEvent(Sender: TObject);
begin
  AddTilt;
end;

function TKMLLookAt.AddRange: Double;
begin;
  Result := FRange;
  FRangeExsit := True;
end;

procedure TKMLLookAt.SetRange(const _Value: Double);
begin
  FRangeExsit := True;
  FRange := _Value;
end;

procedure TKMLLookAt.RangeRemove;
begin
  if FRangeExsit then
  begin
    FRangeExsit := False;
  end;
end;

procedure TKMLLookAt.AddRangeEvent(Sender: TObject);
begin
  AddRange;
end;

{  LatLonBox}
constructor TKMLLatLonBox.Create(par: TXML = nil);
begin
  inherited Create(par);
end;

destructor TKMLLatLonBox.Destroy;
begin
  inherited;
end;

procedure TKMLLatLonBox.AfterCreate;
begin
  inherited;
end;

procedure TKMLLatLonBox.FromXML(node: IXMLNode);
var
  I: Integer;
  nodeTmp: IXMLNode;
begin
  try
    for I := 0 to node.ChildNodes.Count - 1 do
    begin
      nodeTmp := node.ChildNodes.Get(I);
      if nodeTmp.NodeName = 'north' then
      begin
        FNorth := StrToFloatDef(nodeTmp.Text, 0);;
      end
      else if nodeTmp.NodeName = 'south' then
      begin
        FSouth := StrToFloatDef(nodeTmp.Text, 0);;
      end
      else if nodeTmp.NodeName = 'east' then
      begin
        FEast := StrToFloatDef(nodeTmp.Text, 0);;
      end
      else if nodeTmp.NodeName = 'west' then
      begin
        FWest := StrToFloatDef(nodeTmp.Text, 0);;
      end
      else if nodeTmp.NodeName = 'rotation' then
      begin
        FRotation := StrToFloatDef(nodeTmp.Text, 0);;
      end;
    end;
    for I := 0 to node.AttributeNodes.Count - 1 do
    begin
      nodeTmp := node.AttributeNodes.Get(I);
;
    end;
  except
    raise Exception.Create('LatLonBox Read XML Error!' + node.Xml);
  end;
end;

function TKMLLatLonBox.ToXML(par: IXMLNode; pt: string): IXMLNode;
var
  doc: IXMLDocument;
  node: IXMLNode;
  NorthTmp: IXMLNode;
  SouthTmp: IXMLNode;
  EastTmp: IXMLNode;
  WestTmp: IXMLNode;
  RotationTmp: IXMLNode;
  I: Integer;
begin
  try
    doc := par.OwnerDocument;
  if (pt = '') or (pt[1] = '#') then
    pt := 'LatLonBox';
    node := doc.CreateNode(pt);
    par.ChildNodes.Add(node);
    NorthTmp := doc.CreateNode('north', ntElement);
    NorthTmp.NodeValue := FloatToStr(FNorth);
    node.ChildNodes.Add(NorthTmp);
    SouthTmp := doc.CreateNode('south', ntElement);
    SouthTmp.NodeValue := FloatToStr(FSouth);
    node.ChildNodes.Add(SouthTmp);
    EastTmp := doc.CreateNode('east', ntElement);
    EastTmp.NodeValue := FloatToStr(FEast);
    node.ChildNodes.Add(EastTmp);
    WestTmp := doc.CreateNode('west', ntElement);
    WestTmp.NodeValue := FloatToStr(FWest);
    node.ChildNodes.Add(WestTmp);
    RotationTmp := doc.CreateNode('rotation', ntElement);
    RotationTmp.NodeValue := FloatToStr(FRotation);
    node.ChildNodes.Add(RotationTmp);
    Result := node;
  except
    raise Exception.Create('XML2Code Write XML Error!');
  end;
end;

procedure TKMLLatLonBox.ToTree;
var
  I: Integer;
begin
  if not Assigned(TreeNodeShape) then
  begin
    Exit;
  end;
  TreeNodeShape.Clear;
  TreeNodeShape.Data := Self;
  TreeNodeShape.Text.Clear;
  TreeNodeShape.Text.Add('LatLonBox');
  TreeNodeShape.AddChild('North:' + FloatToStr(FNorth));
  TreeNodeShape.AddChild('South:' + FloatToStr(FSouth));
  TreeNodeShape.AddChild('East:' + FloatToStr(FEast));
  TreeNodeShape.AddChild('West:' + FloatToStr(FWest));
  TreeNodeShape.AddChild('Rotation:' + FloatToStr(FRotation));
end;

procedure TKMLLatLonBox.ToPopupMenu(Sender: TObject);
var
  pop: TPopupMenu;
begin
  if Assigned(Sender) and (Sender is TPopupMenu) then
  begin
    pop := TPopupMenu(Sender);
    pop.Items.Clear;
  end;
end;

procedure TKMLLatLonBox.ToInspector;
var
  Names_Value: TStringList;
  Types_Value: TList<XMLTypes>;
  _Values_Value: TStringList;
begin
  if not Assigned(ins) then
    Exit;
  Names_Value := TStringList.Create;
  Types_Value := TList<XMLTypes>.Create;
  _Values_Value := TStringList.Create;
  Names_Value.Add('North');
  Types_Value.Add(xs_double);
  _Values_Value.Add(FloatToStr(North));
  Names_Value.Add('South');
  Types_Value.Add(xs_double);
  _Values_Value.Add(FloatToStr(South));
  Names_Value.Add('East');
  Types_Value.Add(xs_double);
  _Values_Value.Add(FloatToStr(East));
  Names_Value.Add('West');
  Types_Value.Add(xs_double);
  _Values_Value.Add(FloatToStr(West));
  Names_Value.Add('Rotation');
  Types_Value.Add(xs_double);
  _Values_Value.Add(FloatToStr(Rotation));
  TXMLInspector(ins).SetData(Names_Value, _Values_Value, Types_Value, Self);
end;

procedure TKMLLatLonBox.CopyFrom(source: TKMLLatLonBox);
var
  I:Integer;
begin
  FNorth := source.North;
  FSouth := source.South;
  FEast := source.East;
  FWest := source.West;
  FRotation := source.Rotation;
  Self.ToTree;
end;

procedure TKMLLatLonBox.PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False);
var
  I: Integer;
begin
  if (items.Count = 1) and (items[0] is TKMLLatLonBox) and (not isCut) then
  begin
    Self.CopyFrom(TKMLLatLonBox(items[0]));
    Self.ToTree;
    Exit;
  end;
  for I := 0 to items.Count - 1 do
  begin
  end;
  Self.ToTree;
end;

procedure TKMLLatLonBox.ChildDeleteEvent(del: TXMLTreeNode);
begin
end;
procedure TKMLLatLonBox.SetXMLProperty(Index: Integer; _Value: String);
begin
  case index of
    0:
      begin
        North := StrToFloatDef(_Value, 0);;
      end;
    1:
      begin
        South := StrToFloatDef(_Value, 0);;
      end;
    2:
      begin
        East := StrToFloatDef(_Value, 0);;
      end;
    3:
      begin
        West := StrToFloatDef(_Value, 0);;
      end;
    4:
      begin
        Rotation := StrToFloatDef(_Value, 0);;
      end;
  end;
  ToTree;
end;

procedure TKMLLatLonBox.SetNorth(const _Value: Double);
begin
  FNorth := _Value;
end;

procedure TKMLLatLonBox.SetSouth(const _Value: Double);
begin
  FSouth := _Value;
end;

procedure TKMLLatLonBox.SetEast(const _Value: Double);
begin
  FEast := _Value;
end;

procedure TKMLLatLonBox.SetWest(const _Value: Double);
begin
  FWest := _Value;
end;

procedure TKMLLatLonBox.SetRotation(const _Value: Double);
begin
  FRotation := _Value;
end;

{  GroundOverlay}
constructor TKMLGroundOverlay.Create(par: TXML = nil);
begin
  inherited Create(par);
end;

destructor TKMLGroundOverlay.Destroy;
begin
  if FLookAtExsit then
    FLookAt.Free;
  if FIconExsit then
    FIcon.Free;
  if FLatLonBoxExsit then
    FLatLonBox.Free;
  inherited;
end;

procedure TKMLGroundOverlay.AfterCreate;
begin
  inherited;
end;

procedure TKMLGroundOverlay.FromXML(node: IXMLNode);
var
  I: Integer;
  nodeTmp: IXMLNode;
begin
  try
    FNameExsit := False;
    FVisibilityExsit := False;
    FDescriptionExsit := False;
    FLookAtExsit := False;
    FIconExsit := False;
    FLatLonBoxExsit := False;
    for I := 0 to node.ChildNodes.Count - 1 do
    begin
      nodeTmp := node.ChildNodes.Get(I);
      if nodeTmp.NodeName = 'name' then
      begin
        FName := nodeTmp.Text;
        FNameExsit := True;
      end
      else if nodeTmp.NodeName = 'visibility' then
      begin
        FVisibility := StrToIntDef(nodeTmp.Text, 0);;
        FVisibilityExsit := True;
      end
      else if nodeTmp.NodeName = 'description' then
      begin
        FDescription := nodeTmp.Text;
        FDescriptionExsit := True;
      end
      else if nodeTmp.NodeName = 'LookAt' then
      begin
        FLookAt := TKMLLookAt.Create(Self);
        FLookAt.FromXML(nodeTmp);
        FLookAtExsit := True;
      end
      else if nodeTmp.NodeName = 'Icon' then
      begin
        FIcon := TKMLIcon.Create(Self);
        FIcon.FromXML(nodeTmp);
        FIconExsit := True;
      end
      else if nodeTmp.NodeName = 'LatLonBox' then
      begin
        FLatLonBox := TKMLLatLonBox.Create(Self);
        FLatLonBox.FromXML(nodeTmp);
        FLatLonBoxExsit := True;
      end;
    end;
    for I := 0 to node.AttributeNodes.Count - 1 do
    begin
      nodeTmp := node.AttributeNodes.Get(I);
;
    end;
  except
    raise Exception.Create('GroundOverlay Read XML Error!' + node.Xml);
  end;
end;

function TKMLGroundOverlay.ToXML(par: IXMLNode; pt: string): IXMLNode;
var
  doc: IXMLDocument;
  node: IXMLNode;
  NameTmp: IXMLNode;
  VisibilityTmp: IXMLNode;
  DescriptionTmp: IXMLNode;
  I: Integer;
begin
  try
    doc := par.OwnerDocument;
  if (pt = '') or (pt[1] = '#') then
    pt := 'GroundOverlay';
    node := doc.CreateNode(pt);
    par.ChildNodes.Add(node);
    if FNameExsit then
    begin
      NameTmp := doc.CreateNode('name', ntElement);
      NameTmp.NodeValue := FName;
      node.ChildNodes.Add(NameTmp);
    end;
    if FVisibilityExsit then
    begin
      VisibilityTmp := doc.CreateNode('visibility', ntElement);
      VisibilityTmp.NodeValue := IntToStr(FVisibility);
      node.ChildNodes.Add(VisibilityTmp);
    end;
    if FDescriptionExsit then
    begin
      DescriptionTmp := doc.CreateNode('description', ntElement);
      DescriptionTmp.NodeValue := FDescription;
      node.ChildNodes.Add(DescriptionTmp);
    end;
    if FLookAtExsit then
      FLookAt.ToXML(node, 'LookAt');
    if FIconExsit then
      FIcon.ToXML(node, 'Icon');
    if FLatLonBoxExsit then
      FLatLonBox.ToXML(node, 'LatLonBox');
    Result := node;
  except
    raise Exception.Create('XML2Code Write XML Error!');
  end;
end;

procedure TKMLGroundOverlay.ToTree;
var
  I: Integer;
begin
  if not Assigned(TreeNodeShape) then
  begin
    Exit;
  end;
  TreeNodeShape.Clear;
  TreeNodeShape.Data := Self;
  TreeNodeShape.Text.Clear;
  TreeNodeShape.Text.Add('GroundOverlay');
  if NameExsit then
    TreeNodeShape.AddChild('Name:' + FName);
  if VisibilityExsit then
    TreeNodeShape.AddChild('Visibility:' + IntToStr(FVisibility));
  if DescriptionExsit then
    TreeNodeShape.AddChild('Description:' + FDescription);
  if LookAtExsit then
  begin
    LookAt.TreeNodeShape := TreeNodeShape.AddChildObject('LookAt', LookAt);
    LookAt.ToTree;
  end;
  if IconExsit then
  begin
    Icon.TreeNodeShape := TreeNodeShape.AddChildObject('Icon', Icon);
    Icon.ToTree;
  end;
  if LatLonBoxExsit then
  begin
    LatLonBox.TreeNodeShape := TreeNodeShape.AddChildObject('LatLonBox', LatLonBox);
    LatLonBox.ToTree;
  end;
end;

procedure TKMLGroundOverlay.ToPopupMenu(Sender: TObject);
var
  pop: TPopupMenu;
  NameAddMenu: TMenuItem;
  VisibilityAddMenu: TMenuItem;
  DescriptionAddMenu: TMenuItem;
  LookAtAddMenu: TMenuItem;
  IconAddMenu: TMenuItem;
  LatLonBoxAddMenu: TMenuItem;
begin
  if Assigned(Sender) and (Sender is TPopupMenu) then
  begin
    pop := TPopupMenu(Sender);
    pop.Items.Clear;
    NameAddMenu := TMenuItem.Create(pop);
    NameAddMenu.Caption := 'Add Name';
    NameAddMenu.OnClick := AddNameEvent;
    pop.Items.Add(NameAddMenu);
    VisibilityAddMenu := TMenuItem.Create(pop);
    VisibilityAddMenu.Caption := 'Add Visibility';
    VisibilityAddMenu.OnClick := AddVisibilityEvent;
    pop.Items.Add(VisibilityAddMenu);
    DescriptionAddMenu := TMenuItem.Create(pop);
    DescriptionAddMenu.Caption := 'Add Description';
    DescriptionAddMenu.OnClick := AddDescriptionEvent;
    pop.Items.Add(DescriptionAddMenu);
    LookAtAddMenu := TMenuItem.Create(pop);
    LookAtAddMenu.Caption := 'Add LookAt';
    LookAtAddMenu.OnClick := AddLookAtEvent;
    pop.Items.Add(LookAtAddMenu);
    IconAddMenu := TMenuItem.Create(pop);
    IconAddMenu.Caption := 'Add Icon';
    IconAddMenu.OnClick := AddIconEvent;
    pop.Items.Add(IconAddMenu);
    LatLonBoxAddMenu := TMenuItem.Create(pop);
    LatLonBoxAddMenu.Caption := 'Add LatLonBox';
    LatLonBoxAddMenu.OnClick := AddLatLonBoxEvent;
    pop.Items.Add(LatLonBoxAddMenu);
  end;
end;

procedure TKMLGroundOverlay.ToInspector;
var
  Names_Value: TStringList;
  Types_Value: TList<XMLTypes>;
  _Values_Value: TStringList;
begin
  if not Assigned(ins) then
    Exit;
  Names_Value := TStringList.Create;
  Types_Value := TList<XMLTypes>.Create;
  _Values_Value := TStringList.Create;
  Names_Value.Add('Name');
  Types_Value.Add(xs_string);
  _Values_Value.Add(Name);
  Names_Value.Add('Visibility');
  Types_Value.Add(xs_integer);
  _Values_Value.Add(IntToStr(Visibility));
  Names_Value.Add('Description');
  Types_Value.Add(xs_string);
  _Values_Value.Add(Description);
  TXMLInspector(ins).SetData(Names_Value, _Values_Value, Types_Value, Self);
end;

procedure TKMLGroundOverlay.CopyFrom(source: TKMLGroundOverlay);
var
  I:Integer;
begin
  FName := source.Name;
  FNameExsit := source.FNameExsit;
  FVisibility := source.Visibility;
  FVisibilityExsit := source.FVisibilityExsit;
  FDescription := source.Description;
  FDescriptionExsit := source.FDescriptionExsit;
  FLookAtExsit := source.FLookAtExsit;
  if source.FLookAtExsit then
  begin
    AddLookAt.CopyFrom(source.LookAt);
  end;
  FIconExsit := source.FIconExsit;
  if source.FIconExsit then
  begin
    AddIcon.CopyFrom(source.Icon);
  end;
  FLatLonBoxExsit := source.FLatLonBoxExsit;
  if source.FLatLonBoxExsit then
  begin
    AddLatLonBox.CopyFrom(source.LatLonBox);
  end;
  Self.ToTree;
end;

procedure TKMLGroundOverlay.PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False);
var
  I: Integer;
begin
  if (items.Count = 1) and (items[0] is TKMLGroundOverlay) and (not isCut) then
  begin
    Self.CopyFrom(TKMLGroundOverlay(items[0]));
    Self.ToTree;
    Exit;
  end;
  for I := 0 to items.Count - 1 do
  begin
  end;
  Self.ToTree;
end;

procedure TKMLGroundOverlay.ChildDeleteEvent(del: TXMLTreeNode);
begin
end;
procedure TKMLGroundOverlay.SetXMLProperty(Index: Integer; _Value: String);
begin
  case index of
    0:
      begin
        Name := _Value;
      end;
    1:
      begin
        Visibility := StrToIntDef(_Value, 0);;
      end;
    2:
      begin
        Description := _Value;
      end;
  end;
  ToTree;
end;

function TKMLGroundOverlay.AddName: String;
begin;
  Result := FName;
  FNameExsit := True;
end;

procedure TKMLGroundOverlay.SetName(const _Value: String);
begin
  FNameExsit := True;
  FName := _Value;
end;

procedure TKMLGroundOverlay.NameRemove;
begin
  if FNameExsit then
  begin
    FNameExsit := False;
  end;
end;

procedure TKMLGroundOverlay.AddNameEvent(Sender: TObject);
begin
  AddName;
end;

function TKMLGroundOverlay.AddVisibility: Integer;
begin;
  Result := FVisibility;
  FVisibilityExsit := True;
end;

procedure TKMLGroundOverlay.SetVisibility(const _Value: Integer);
begin
  FVisibilityExsit := True;
  FVisibility := _Value;
end;

procedure TKMLGroundOverlay.VisibilityRemove;
begin
  if FVisibilityExsit then
  begin
    FVisibilityExsit := False;
  end;
end;

procedure TKMLGroundOverlay.AddVisibilityEvent(Sender: TObject);
begin
  AddVisibility;
end;

function TKMLGroundOverlay.AddDescription: String;
begin;
  Result := FDescription;
  FDescriptionExsit := True;
end;

procedure TKMLGroundOverlay.SetDescription(const _Value: String);
begin
  FDescriptionExsit := True;
  FDescription := _Value;
end;

procedure TKMLGroundOverlay.DescriptionRemove;
begin
  if FDescriptionExsit then
  begin
    FDescriptionExsit := False;
  end;
end;

procedure TKMLGroundOverlay.AddDescriptionEvent(Sender: TObject);
begin
  AddDescription;
end;

function TKMLGroundOverlay.AddLookAt: TKMLLookAt;
begin;
  if not FLookAtExsit then
    FLookAt := TKMLLookAt.Create(Self);
  Result := FLookAt;
  FLookAtExsit := True;
end;

procedure TKMLGroundOverlay.SetLookAt(const _Value: TKMLLookAt);
begin
  if FLookAtExsit then
    FLookAt.Free;
  FLookAtExsit := True;
  FLookAt := _Value;
  FLookAt.Parent := Self;
end;

procedure TKMLGroundOverlay.LookAtRemove;
begin
  if FLookAtExsit then
  begin
    FLookAt.Free;
    FLookAtExsit := False;
  end;
end;

procedure TKMLGroundOverlay.AddLookAtEvent(Sender: TObject);
begin
  AddLookAt;
  FLookAt.ToTree;
end;

function TKMLGroundOverlay.AddIcon: TKMLIcon;
begin;
  if not FIconExsit then
    FIcon := TKMLIcon.Create(Self);
  Result := FIcon;
  FIconExsit := True;
end;

procedure TKMLGroundOverlay.SetIcon(const _Value: TKMLIcon);
begin
  if FIconExsit then
    FIcon.Free;
  FIconExsit := True;
  FIcon := _Value;
  FIcon.Parent := Self;
end;

procedure TKMLGroundOverlay.IconRemove;
begin
  if FIconExsit then
  begin
    FIcon.Free;
    FIconExsit := False;
  end;
end;

procedure TKMLGroundOverlay.AddIconEvent(Sender: TObject);
begin
  AddIcon;
  FIcon.ToTree;
end;

function TKMLGroundOverlay.AddLatLonBox: TKMLLatLonBox;
begin;
  if not FLatLonBoxExsit then
    FLatLonBox := TKMLLatLonBox.Create(Self);
  Result := FLatLonBox;
  FLatLonBoxExsit := True;
end;

procedure TKMLGroundOverlay.SetLatLonBox(const _Value: TKMLLatLonBox);
begin
  if FLatLonBoxExsit then
    FLatLonBox.Free;
  FLatLonBoxExsit := True;
  FLatLonBox := _Value;
  FLatLonBox.Parent := Self;
end;

procedure TKMLGroundOverlay.LatLonBoxRemove;
begin
  if FLatLonBoxExsit then
  begin
    FLatLonBox.Free;
    FLatLonBoxExsit := False;
  end;
end;

procedure TKMLGroundOverlay.AddLatLonBoxEvent(Sender: TObject);
begin
  AddLatLonBox;
  FLatLonBox.ToTree;
end;

{  ExtendedData}
constructor TKMLExtendedData.Create(par: TXML = nil);
begin
  inherited Create(par);
  FDatas := TList<TKMLData>.Create;
end;

destructor TKMLExtendedData.Destroy;
begin
  DataClear;
  FDatas.Free;
  inherited;
end;

procedure TKMLExtendedData.AfterCreate;
begin
  inherited;
  FDatas := TList<TKMLData>.Create;
end;

procedure TKMLExtendedData.FromXML(node: IXMLNode);
var
  I: Integer;
  nodeTmp: IXMLNode;
  DataTmp: TKMLData;
begin
  try
    DataClear;
    for I := 0 to node.ChildNodes.Count - 1 do
    begin
      nodeTmp := node.ChildNodes.Get(I);
      if nodeTmp.NodeName = 'Data' then
      begin
        DataTmp := TKMLData.Create(Self);
        DataTmp.FromXML(nodeTmp);
        FDatas.Add(DataTmp);
      end;
    end;
    for I := 0 to node.AttributeNodes.Count - 1 do
    begin
      nodeTmp := node.AttributeNodes.Get(I);
;
    end;
  except
    raise Exception.Create('ExtendedData Read XML Error!' + node.Xml);
  end;
end;

function TKMLExtendedData.ToXML(par: IXMLNode; pt: string): IXMLNode;
var
  doc: IXMLDocument;
  node: IXMLNode;
  I: Integer;
begin
  try
    doc := par.OwnerDocument;
  if (pt = '') or (pt[1] = '#') then
    pt := 'ExtendedData';
    node := doc.CreateNode(pt);
    par.ChildNodes.Add(node);
    for I := 0 to FDatas.Count - 1 do
       FDatas.Items[I].ToXML(node, 'Data');
    Result := node;
  except
    raise Exception.Create('XML2Code Write XML Error!');
  end;
end;

procedure TKMLExtendedData.ToTree;
var
  I: Integer;
begin
  if not Assigned(TreeNodeShape) then
  begin
    Exit;
  end;
  TreeNodeShape.Clear;
  TreeNodeShape.Data := Self;
  TreeNodeShape.Text.Clear;
  TreeNodeShape.Text.Add('ExtendedData');
  for I := 0 to DataCount - 1 do
  begin
    Datas[I].TreeNodeShape := TreeNodeShape.AddChildObject('Data', Data[I]);
    Data[I].ToTree;
  end;
end;

procedure TKMLExtendedData.ToPopupMenu(Sender: TObject);
var
  pop: TPopupMenu;
  DataAddMenu: TMenuItem;
begin
  if Assigned(Sender) and (Sender is TPopupMenu) then
  begin
    pop := TPopupMenu(Sender);
    pop.Items.Clear;
    DataAddMenu := TMenuItem.Create(pop);
    DataAddMenu.Caption := 'Add Data';
    DataAddMenu.OnClick := AddDataEvent;
    pop.Items.Add(DataAddMenu);
  end;
end;

procedure TKMLExtendedData.ToInspector;
var
  Names_Value: TStringList;
  Types_Value: TList<XMLTypes>;
  _Values_Value: TStringList;
begin
  if not Assigned(ins) then
    Exit;
  Names_Value := TStringList.Create;
  Types_Value := TList<XMLTypes>.Create;
  _Values_Value := TStringList.Create;
  TXMLInspector(ins).SetData(Names_Value, _Values_Value, Types_Value, Self);
end;

procedure TKMLExtendedData.CopyFrom(source: TKMLExtendedData);
var
  I:Integer;
begin
    DataClear;
  for I := 0 to DataCount - 1 do
  begin
    AddData.CopyFrom(source.Data[I]);
  end;
  Self.ToTree;
end;

procedure TKMLExtendedData.PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False);
var
  I: Integer;
  tmpData: TKMLData;
begin
  if (items.Count = 1) and (items[0] is TKMLExtendedData) and (not isCut) then
  begin
    Self.CopyFrom(TKMLExtendedData(items[0]));
    Self.ToTree;
    Exit;
  end;
  for I := 0 to items.Count - 1 do
  begin
    if items[I] is TKMLData then
    begin
      tmpData := TKMLData(items[I]);
      if isCut then
      begin
        TKMLExtendedData(tmpData.Parent).Datas.Remove(tmpData);
        Self.Datas.Add(tmpData);
        tmpData.Parent := Self;
        tmpData.TreeNodeShape.Parent := Self.TreeNodeShape;
      end
      else
      begin
        AddData.CopyFrom(tmpData);
      end;
    end;
  end;
  Self.ToTree;
end;

procedure TKMLExtendedData.ChildDeleteEvent(del: TXMLTreeNode);
begin
  if del is TKMLData then
  begin
    Self.RemoveData(TKMLData(del));
  end;
end;
procedure TKMLExtendedData.SetXMLProperty(Index: Integer; _Value: String);
begin
end;

function TKMLExtendedData.AddData: TKMLData;
var
  Datatmp: TKMLData;
begin;
  Datatmp := TKMLData.Create(Self);
  FDatas.Add(Datatmp);
  Result := Datatmp;
end;

procedure TKMLExtendedData.SetDatas(const _Value: TList<TKMLData>);
begin
  DataClear;
  FDatas := _Value;
end;

procedure TKMLExtendedData.DataClear;
begin
  while FDatas.Count > 0 do
  begin
    FDatas.Items[0].Free;
    FDatas.Delete(0);
  end;
end;

function TKMLExtendedData.DataCount: Integer;
begin
  Result := FDatas.Count;
end;

function TKMLExtendedData.GetData(Index: Integer): TKMLData;
begin
  Result := FDatas[Index];
end;

procedure TKMLExtendedData.SetData(Index: Integer;
  const _Value: TKMLData);
begin
  _Value.Parent := Self;
  FDatas[Index].Free;
  FDatas[Index] := _Value;
end;

procedure TKMLExtendedData.RemoveData(_Value: TKMLData);
begin
  FDatas.Remove(_Value);
  _Value.Free;
end;

procedure TKMLExtendedData.DeleteData(Index: Integer);
begin
  FDatas.Items[Index].Free;
  FDatas.Delete(Index);
end;

procedure TKMLExtendedData.AddDataEvent(Sender: TObject);
var
  tmp: TKMLData;
begin
  tmp := AddData;
  tmp.TreeNodeShape := TreeNodeShape.AddChildObject('Data', tmp);
  tmp.ToTree;
end;

{  Data}
constructor TKMLData.Create(par: TXML = nil);
begin
  inherited Create(par);
end;

destructor TKMLData.Destroy;
begin
  inherited;
end;

procedure TKMLData.AfterCreate;
begin
  inherited;
end;

procedure TKMLData.FromXML(node: IXMLNode);
var
  I: Integer;
  nodeTmp: IXMLNode;
begin
  try
    for I := 0 to node.ChildNodes.Count - 1 do
    begin
      nodeTmp := node.ChildNodes.Get(I);
      if nodeTmp.NodeName = 'value' then
      begin
        FValue := nodeTmp.Text;
      end;
    end;
    for I := 0 to node.AttributeNodes.Count - 1 do
    begin
      nodeTmp := node.AttributeNodes.Get(I);
      if nodeTmp.NodeName = 'name' then
      begin
        FName := nodeTmp.Text;
      end;
    end;
  except
    raise Exception.Create('Data Read XML Error!' + node.Xml);
  end;
end;

function TKMLData.ToXML(par: IXMLNode; pt: string): IXMLNode;
var
  doc: IXMLDocument;
  node: IXMLNode;
  NameTmp: IXMLNode;
  ValueTmp: IXMLNode;
  I: Integer;
begin
  try
    doc := par.OwnerDocument;
  if (pt = '') or (pt[1] = '#') then
    pt := 'Data';
    node := doc.CreateNode(pt);
    par.ChildNodes.Add(node);
    ValueTmp := doc.CreateNode('value', ntElement);
    ValueTmp.NodeValue := FValue;
    node.ChildNodes.Add(ValueTmp);
    NameTmp := doc.CreateNode('name', ntAttribute);
    NameTmp.NodeValue := FName;
    node.AttributeNodes.Add(NameTmp);
    Result := node;
  except
    raise Exception.Create('XML2Code Write XML Error!');
  end;
end;

procedure TKMLData.ToTree;
var
  I: Integer;
begin
  if not Assigned(TreeNodeShape) then
  begin
    Exit;
  end;
  TreeNodeShape.Clear;
  TreeNodeShape.Data := Self;
  TreeNodeShape.Text.Clear;
  TreeNodeShape.Text.Add('Data');
  TreeNodeShape.AddChild('Name:' + FName);
  TreeNodeShape.AddChild('Value:' + FValue);
end;

procedure TKMLData.ToPopupMenu(Sender: TObject);
var
  pop: TPopupMenu;
begin
  if Assigned(Sender) and (Sender is TPopupMenu) then
  begin
    pop := TPopupMenu(Sender);
    pop.Items.Clear;
  end;
end;

procedure TKMLData.ToInspector;
var
  Names_Value: TStringList;
  Types_Value: TList<XMLTypes>;
  _Values_Value: TStringList;
begin
  if not Assigned(ins) then
    Exit;
  Names_Value := TStringList.Create;
  Types_Value := TList<XMLTypes>.Create;
  _Values_Value := TStringList.Create;
  Names_Value.Add('Name');
  Types_Value.Add(xs_string);
  _Values_Value.Add(Name);
  Names_Value.Add('Value');
  Types_Value.Add(xs_string);
  _Values_Value.Add(Value);
  TXMLInspector(ins).SetData(Names_Value, _Values_Value, Types_Value, Self);
end;

procedure TKMLData.CopyFrom(source: TKMLData);
var
  I:Integer;
begin
  FName := source.Name;
  FValue := source.Value;
  Self.ToTree;
end;

procedure TKMLData.PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False);
var
  I: Integer;
begin
  if (items.Count = 1) and (items[0] is TKMLData) and (not isCut) then
  begin
    Self.CopyFrom(TKMLData(items[0]));
    Self.ToTree;
    Exit;
  end;
  for I := 0 to items.Count - 1 do
  begin
  end;
  Self.ToTree;
end;

procedure TKMLData.ChildDeleteEvent(del: TXMLTreeNode);
begin
end;
procedure TKMLData.SetXMLProperty(Index: Integer; _Value: String);
begin
  case index of
    0:
      begin
        Name := _Value;
      end;
    1:
      begin
        Value := _Value;
      end;
  end;
  ToTree;
end;

procedure TKMLData.SetName(const _Value: String);
begin
  FName := _Value;
end;

procedure TKMLData.SetValue(const _Value: String);
begin
  FValue := _Value;
end;

{  Size}
constructor TKMLSize.Create(par: TXML = nil);
begin
  inherited Create(par);
end;

destructor TKMLSize.Destroy;
begin
  inherited;
end;

procedure TKMLSize.AfterCreate;
begin
  inherited;
end;

procedure TKMLSize.FromXML(node: IXMLNode);
var
  I: Integer;
  nodeTmp: IXMLNode;
begin
  try
    for I := 0 to node.ChildNodes.Count - 1 do
    begin
      nodeTmp := node.ChildNodes.Get(I);
;
    end;
    for I := 0 to node.AttributeNodes.Count - 1 do
    begin
      nodeTmp := node.AttributeNodes.Get(I);
      if nodeTmp.NodeName = 'x' then
      begin
        FX := StrToFloatDef(nodeTmp.Text, 0);;
      end
      else if nodeTmp.NodeName = 'y' then
      begin
        FY := StrToFloatDef(nodeTmp.Text, 0);;
      end
      else if nodeTmp.NodeName = 'xunits' then
      begin
        FXUnits := nodeTmp.Text;
      end
      else if nodeTmp.NodeName = 'yunits' then
      begin
        FYUnits := nodeTmp.Text;
      end;
    end;
  except
    raise Exception.Create('Size Read XML Error!' + node.Xml);
  end;
end;

function TKMLSize.ToXML(par: IXMLNode; pt: string): IXMLNode;
var
  doc: IXMLDocument;
  node: IXMLNode;
  XTmp: IXMLNode;
  YTmp: IXMLNode;
  XUnitsTmp: IXMLNode;
  YUnitsTmp: IXMLNode;
  I: Integer;
begin
  try
    doc := par.OwnerDocument;
  if (pt = '') or (pt[1] = '#') then
    pt := 'Size';
    node := doc.CreateNode(pt);
    par.ChildNodes.Add(node);
    XTmp := doc.CreateNode('x', ntAttribute);
    XTmp.NodeValue := FloatToStr(FX);
    node.AttributeNodes.Add(XTmp);
    YTmp := doc.CreateNode('y', ntAttribute);
    YTmp.NodeValue := FloatToStr(FY);
    node.AttributeNodes.Add(YTmp);
    XUnitsTmp := doc.CreateNode('xunits', ntAttribute);
    XUnitsTmp.NodeValue := FXUnits;
    node.AttributeNodes.Add(XUnitsTmp);
    YUnitsTmp := doc.CreateNode('yunits', ntAttribute);
    YUnitsTmp.NodeValue := FYUnits;
    node.AttributeNodes.Add(YUnitsTmp);
    Result := node;
  except
    raise Exception.Create('XML2Code Write XML Error!');
  end;
end;

procedure TKMLSize.ToTree;
var
  I: Integer;
begin
  if not Assigned(TreeNodeShape) then
  begin
    Exit;
  end;
  TreeNodeShape.Clear;
  TreeNodeShape.Data := Self;
  TreeNodeShape.Text.Clear;
  TreeNodeShape.Text.Add('Size');
  TreeNodeShape.AddChild('X:' + FloatToStr(FX));
  TreeNodeShape.AddChild('Y:' + FloatToStr(FY));
  TreeNodeShape.AddChild('XUnits:' + FXUnits);
  TreeNodeShape.AddChild('YUnits:' + FYUnits);
end;

procedure TKMLSize.ToPopupMenu(Sender: TObject);
var
  pop: TPopupMenu;
begin
  if Assigned(Sender) and (Sender is TPopupMenu) then
  begin
    pop := TPopupMenu(Sender);
    pop.Items.Clear;
  end;
end;

procedure TKMLSize.ToInspector;
var
  Names_Value: TStringList;
  Types_Value: TList<XMLTypes>;
  _Values_Value: TStringList;
begin
  if not Assigned(ins) then
    Exit;
  Names_Value := TStringList.Create;
  Types_Value := TList<XMLTypes>.Create;
  _Values_Value := TStringList.Create;
  Names_Value.Add('X');
  Types_Value.Add(xs_double);
  _Values_Value.Add(FloatToStr(X));
  Names_Value.Add('Y');
  Types_Value.Add(xs_double);
  _Values_Value.Add(FloatToStr(Y));
  Names_Value.Add('XUnits');
  Types_Value.Add(xs_string);
  _Values_Value.Add(XUnits);
  Names_Value.Add('YUnits');
  Types_Value.Add(xs_string);
  _Values_Value.Add(YUnits);
  TXMLInspector(ins).SetData(Names_Value, _Values_Value, Types_Value, Self);
end;

procedure TKMLSize.CopyFrom(source: TKMLSize);
var
  I:Integer;
begin
  FX := source.X;
  FY := source.Y;
  FXUnits := source.XUnits;
  FYUnits := source.YUnits;
  Self.ToTree;
end;

procedure TKMLSize.PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False);
var
  I: Integer;
begin
  if (items.Count = 1) and (items[0] is TKMLSize) and (not isCut) then
  begin
    Self.CopyFrom(TKMLSize(items[0]));
    Self.ToTree;
    Exit;
  end;
  for I := 0 to items.Count - 1 do
  begin
  end;
  Self.ToTree;
end;

procedure TKMLSize.ChildDeleteEvent(del: TXMLTreeNode);
begin
end;
procedure TKMLSize.SetXMLProperty(Index: Integer; _Value: String);
begin
  case index of
    0:
      begin
        X := StrToFloatDef(_Value, 0);;
      end;
    1:
      begin
        Y := StrToFloatDef(_Value, 0);;
      end;
    2:
      begin
        XUnits := _Value;
      end;
    3:
      begin
        YUnits := _Value;
      end;
  end;
  ToTree;
end;

procedure TKMLSize.SetX(const _Value: Double);
begin
  FX := _Value;
end;

procedure TKMLSize.SetY(const _Value: Double);
begin
  FY := _Value;
end;

procedure TKMLSize.SetXUnits(const _Value: String);
begin
  FXUnits := _Value;
end;

procedure TKMLSize.SetYUnits(const _Value: String);
begin
  FYUnits := _Value;
end;

{  Style}
constructor TKMLStyle.Create(par: TXML = nil);
begin
  inherited Create(par);
end;

destructor TKMLStyle.Destroy;
begin
  if FIconStyleExsit then
    FIconStyle.Free;
  if FLineStyleExsit then
    FLineStyle.Free;
  if FPolyStyleExsit then
    FPolyStyle.Free;
  if FBalloonStyleExsit then
    FBalloonStyle.Free;
  inherited;
end;

procedure TKMLStyle.AfterCreate;
begin
  inherited;
end;

procedure TKMLStyle.FromXML(node: IXMLNode);
var
  I: Integer;
  nodeTmp: IXMLNode;
begin
  try
    FIconStyleExsit := False;
    FLineStyleExsit := False;
    FPolyStyleExsit := False;
    FBalloonStyleExsit := False;
    for I := 0 to node.ChildNodes.Count - 1 do
    begin
      nodeTmp := node.ChildNodes.Get(I);
      if nodeTmp.NodeName = 'IconStyle' then
      begin
        FIconStyle := TKMLIconStyle.Create(Self);
        FIconStyle.FromXML(nodeTmp);
        FIconStyleExsit := True;
      end
      else if nodeTmp.NodeName = 'LineStyle' then
      begin
        FLineStyle := TKMLLineStyle.Create(Self);
        FLineStyle.FromXML(nodeTmp);
        FLineStyleExsit := True;
      end
      else if nodeTmp.NodeName = 'PolyStyle' then
      begin
        FPolyStyle := TKMLLineStyle.Create(Self);
        FPolyStyle.FromXML(nodeTmp);
        FPolyStyleExsit := True;
      end
      else if nodeTmp.NodeName = 'BalloonStyle' then
      begin
        FBalloonStyle := TKMLBalloonStyle.Create(Self);
        FBalloonStyle.FromXML(nodeTmp);
        FBalloonStyleExsit := True;
      end;
    end;
    for I := 0 to node.AttributeNodes.Count - 1 do
    begin
      nodeTmp := node.AttributeNodes.Get(I);
      if nodeTmp.NodeName = 'id' then
      begin
        FID := nodeTmp.Text;
      end;
    end;
  except
    raise Exception.Create('Style Read XML Error!' + node.Xml);
  end;
end;

function TKMLStyle.ToXML(par: IXMLNode; pt: string): IXMLNode;
var
  doc: IXMLDocument;
  node: IXMLNode;
  IDTmp: IXMLNode;
  I: Integer;
begin
  try
    doc := par.OwnerDocument;
  if (pt = '') or (pt[1] = '#') then
    pt := 'Style';
    node := doc.CreateNode(pt);
    par.ChildNodes.Add(node);
    if FIconStyleExsit then
      FIconStyle.ToXML(node, 'IconStyle');
    if FLineStyleExsit then
      FLineStyle.ToXML(node, 'LineStyle');
    if FPolyStyleExsit then
      FPolyStyle.ToXML(node, 'PolyStyle');
    if FBalloonStyleExsit then
      FBalloonStyle.ToXML(node, 'BalloonStyle');
    IDTmp := doc.CreateNode('id', ntAttribute);
    IDTmp.NodeValue := FID;
    node.AttributeNodes.Add(IDTmp);
    Result := node;
  except
    raise Exception.Create('XML2Code Write XML Error!');
  end;
end;

procedure TKMLStyle.ToTree;
var
  I: Integer;
begin
  if not Assigned(TreeNodeShape) then
  begin
    Exit;
  end;
  TreeNodeShape.Clear;
  TreeNodeShape.Data := Self;
  TreeNodeShape.Text.Clear;
  TreeNodeShape.Text.Add('Style');
  TreeNodeShape.AddChild('ID:' + FID);
  if IconStyleExsit then
  begin
    IconStyle.TreeNodeShape := TreeNodeShape.AddChildObject('IconStyle', IconStyle);
    IconStyle.ToTree;
  end;
  if LineStyleExsit then
  begin
    LineStyle.TreeNodeShape := TreeNodeShape.AddChildObject('LineStyle', LineStyle);
    LineStyle.ToTree;
  end;
  if PolyStyleExsit then
  begin
    PolyStyle.TreeNodeShape := TreeNodeShape.AddChildObject('PolyStyle', PolyStyle);
    PolyStyle.ToTree;
  end;
  if BalloonStyleExsit then
  begin
    BalloonStyle.TreeNodeShape := TreeNodeShape.AddChildObject('BalloonStyle', BalloonStyle);
    BalloonStyle.ToTree;
  end;
end;

procedure TKMLStyle.ToPopupMenu(Sender: TObject);
var
  pop: TPopupMenu;
  IconStyleAddMenu: TMenuItem;
  LineStyleAddMenu: TMenuItem;
  PolyStyleAddMenu: TMenuItem;
  BalloonStyleAddMenu: TMenuItem;
begin
  if Assigned(Sender) and (Sender is TPopupMenu) then
  begin
    pop := TPopupMenu(Sender);
    pop.Items.Clear;
    IconStyleAddMenu := TMenuItem.Create(pop);
    IconStyleAddMenu.Caption := 'Add IconStyle';
    IconStyleAddMenu.OnClick := AddIconStyleEvent;
    pop.Items.Add(IconStyleAddMenu);
    LineStyleAddMenu := TMenuItem.Create(pop);
    LineStyleAddMenu.Caption := 'Add LineStyle';
    LineStyleAddMenu.OnClick := AddLineStyleEvent;
    pop.Items.Add(LineStyleAddMenu);
    PolyStyleAddMenu := TMenuItem.Create(pop);
    PolyStyleAddMenu.Caption := 'Add PolyStyle';
    PolyStyleAddMenu.OnClick := AddPolyStyleEvent;
    pop.Items.Add(PolyStyleAddMenu);
    BalloonStyleAddMenu := TMenuItem.Create(pop);
    BalloonStyleAddMenu.Caption := 'Add BalloonStyle';
    BalloonStyleAddMenu.OnClick := AddBalloonStyleEvent;
    pop.Items.Add(BalloonStyleAddMenu);
  end;
end;

procedure TKMLStyle.ToInspector;
var
  Names_Value: TStringList;
  Types_Value: TList<XMLTypes>;
  _Values_Value: TStringList;
begin
  if not Assigned(ins) then
    Exit;
  Names_Value := TStringList.Create;
  Types_Value := TList<XMLTypes>.Create;
  _Values_Value := TStringList.Create;
  Names_Value.Add('ID');
  Types_Value.Add(xs_string);
  _Values_Value.Add(ID);
  TXMLInspector(ins).SetData(Names_Value, _Values_Value, Types_Value, Self);
end;

procedure TKMLStyle.CopyFrom(source: TKMLStyle);
var
  I:Integer;
begin
  FID := source.ID;
  FIconStyleExsit := source.FIconStyleExsit;
  if source.FIconStyleExsit then
  begin
    AddIconStyle.CopyFrom(source.IconStyle);
  end;
  FLineStyleExsit := source.FLineStyleExsit;
  if source.FLineStyleExsit then
  begin
    AddLineStyle.CopyFrom(source.LineStyle);
  end;
  FPolyStyleExsit := source.FPolyStyleExsit;
  if source.FPolyStyleExsit then
  begin
    AddPolyStyle.CopyFrom(source.PolyStyle);
  end;
  FBalloonStyleExsit := source.FBalloonStyleExsit;
  if source.FBalloonStyleExsit then
  begin
    AddBalloonStyle.CopyFrom(source.BalloonStyle);
  end;
  Self.ToTree;
end;

procedure TKMLStyle.PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False);
var
  I: Integer;
begin
  if (items.Count = 1) and (items[0] is TKMLStyle) and (not isCut) then
  begin
    Self.CopyFrom(TKMLStyle(items[0]));
    Self.ToTree;
    Exit;
  end;
  for I := 0 to items.Count - 1 do
  begin
  end;
  Self.ToTree;
end;

procedure TKMLStyle.ChildDeleteEvent(del: TXMLTreeNode);
begin
end;
procedure TKMLStyle.SetXMLProperty(Index: Integer; _Value: String);
begin
  case index of
    0:
      begin
        ID := _Value;
      end;
  end;
  ToTree;
end;

procedure TKMLStyle.SetID(const _Value: String);
begin
  FID := _Value;
end;

function TKMLStyle.AddIconStyle: TKMLIconStyle;
begin;
  if not FIconStyleExsit then
    FIconStyle := TKMLIconStyle.Create(Self);
  Result := FIconStyle;
  FIconStyleExsit := True;
end;

procedure TKMLStyle.SetIconStyle(const _Value: TKMLIconStyle);
begin
  if FIconStyleExsit then
    FIconStyle.Free;
  FIconStyleExsit := True;
  FIconStyle := _Value;
  FIconStyle.Parent := Self;
end;

procedure TKMLStyle.IconStyleRemove;
begin
  if FIconStyleExsit then
  begin
    FIconStyle.Free;
    FIconStyleExsit := False;
  end;
end;

procedure TKMLStyle.AddIconStyleEvent(Sender: TObject);
begin
  AddIconStyle;
  FIconStyle.ToTree;
end;

function TKMLStyle.AddLineStyle: TKMLLineStyle;
begin;
  if not FLineStyleExsit then
    FLineStyle := TKMLLineStyle.Create(Self);
  Result := FLineStyle;
  FLineStyleExsit := True;
end;

procedure TKMLStyle.SetLineStyle(const _Value: TKMLLineStyle);
begin
  if FLineStyleExsit then
    FLineStyle.Free;
  FLineStyleExsit := True;
  FLineStyle := _Value;
  FLineStyle.Parent := Self;
end;

procedure TKMLStyle.LineStyleRemove;
begin
  if FLineStyleExsit then
  begin
    FLineStyle.Free;
    FLineStyleExsit := False;
  end;
end;

procedure TKMLStyle.AddLineStyleEvent(Sender: TObject);
begin
  AddLineStyle;
  FLineStyle.ToTree;
end;

function TKMLStyle.AddPolyStyle: TKMLLineStyle;
begin;
  if not FPolyStyleExsit then
    FPolyStyle := TKMLLineStyle.Create(Self);
  Result := FPolyStyle;
  FPolyStyleExsit := True;
end;

procedure TKMLStyle.SetPolyStyle(const _Value: TKMLLineStyle);
begin
  if FPolyStyleExsit then
    FPolyStyle.Free;
  FPolyStyleExsit := True;
  FPolyStyle := _Value;
  FPolyStyle.Parent := Self;
end;

procedure TKMLStyle.PolyStyleRemove;
begin
  if FPolyStyleExsit then
  begin
    FPolyStyle.Free;
    FPolyStyleExsit := False;
  end;
end;

procedure TKMLStyle.AddPolyStyleEvent(Sender: TObject);
begin
  AddPolyStyle;
  FPolyStyle.ToTree;
end;

function TKMLStyle.AddBalloonStyle: TKMLBalloonStyle;
begin;
  if not FBalloonStyleExsit then
    FBalloonStyle := TKMLBalloonStyle.Create(Self);
  Result := FBalloonStyle;
  FBalloonStyleExsit := True;
end;

procedure TKMLStyle.SetBalloonStyle(const _Value: TKMLBalloonStyle);
begin
  if FBalloonStyleExsit then
    FBalloonStyle.Free;
  FBalloonStyleExsit := True;
  FBalloonStyle := _Value;
  FBalloonStyle.Parent := Self;
end;

procedure TKMLStyle.BalloonStyleRemove;
begin
  if FBalloonStyleExsit then
  begin
    FBalloonStyle.Free;
    FBalloonStyleExsit := False;
  end;
end;

procedure TKMLStyle.AddBalloonStyleEvent(Sender: TObject);
begin
  AddBalloonStyle;
  FBalloonStyle.ToTree;
end;

{  IconStyle}
constructor TKMLIconStyle.Create(par: TXML = nil);
begin
  inherited Create(par);
  FIcon := TKMLIcon.Create(Self);
end;

destructor TKMLIconStyle.Destroy;
begin
  FIcon.Free;
  inherited;
end;

procedure TKMLIconStyle.AfterCreate;
begin
  inherited;
  FIcon := TKMLIcon.Create(Self);
end;

procedure TKMLIconStyle.FromXML(node: IXMLNode);
var
  I: Integer;
  nodeTmp: IXMLNode;
begin
  try
    for I := 0 to node.ChildNodes.Count - 1 do
    begin
      nodeTmp := node.ChildNodes.Get(I);
      if nodeTmp.NodeName = 'Icon' then
      begin
        FIcon := TKMLIcon.Create(Self);
        FIcon.FromXML(nodeTmp);
      end;
    end;
    for I := 0 to node.AttributeNodes.Count - 1 do
    begin
      nodeTmp := node.AttributeNodes.Get(I);
;
    end;
  except
    raise Exception.Create('IconStyle Read XML Error!' + node.Xml);
  end;
end;

function TKMLIconStyle.ToXML(par: IXMLNode; pt: string): IXMLNode;
var
  doc: IXMLDocument;
  node: IXMLNode;
  I: Integer;
begin
  try
    doc := par.OwnerDocument;
  if (pt = '') or (pt[1] = '#') then
    pt := 'IconStyle';
    node := doc.CreateNode(pt);
    par.ChildNodes.Add(node);
    FIcon.ToXML(node, 'Icon');
    Result := node;
  except
    raise Exception.Create('XML2Code Write XML Error!');
  end;
end;

procedure TKMLIconStyle.ToTree;
var
  I: Integer;
begin
  if not Assigned(TreeNodeShape) then
  begin
    Exit;
  end;
  TreeNodeShape.Clear;
  TreeNodeShape.Data := Self;
  TreeNodeShape.Text.Clear;
  TreeNodeShape.Text.Add('IconStyle');
  Icon.TreeNodeShape := TreeNodeShape.AddChildObject('Icon', Icon);
  Icon.ToTree;
end;

procedure TKMLIconStyle.ToPopupMenu(Sender: TObject);
var
  pop: TPopupMenu;
begin
  if Assigned(Sender) and (Sender is TPopupMenu) then
  begin
    pop := TPopupMenu(Sender);
    pop.Items.Clear;
  end;
end;

procedure TKMLIconStyle.ToInspector;
var
  Names_Value: TStringList;
  Types_Value: TList<XMLTypes>;
  _Values_Value: TStringList;
begin
  if not Assigned(ins) then
    Exit;
  Names_Value := TStringList.Create;
  Types_Value := TList<XMLTypes>.Create;
  _Values_Value := TStringList.Create;
  TXMLInspector(ins).SetData(Names_Value, _Values_Value, Types_Value, Self);
end;

procedure TKMLIconStyle.CopyFrom(source: TKMLIconStyle);
var
  I:Integer;
begin
    Icon.CopyFrom(source.Icon);
  Self.ToTree;
end;

procedure TKMLIconStyle.PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False);
var
  I: Integer;
begin
  if (items.Count = 1) and (items[0] is TKMLIconStyle) and (not isCut) then
  begin
    Self.CopyFrom(TKMLIconStyle(items[0]));
    Self.ToTree;
    Exit;
  end;
  for I := 0 to items.Count - 1 do
  begin
  end;
  Self.ToTree;
end;

procedure TKMLIconStyle.ChildDeleteEvent(del: TXMLTreeNode);
begin
end;
procedure TKMLIconStyle.SetXMLProperty(Index: Integer; _Value: String);
begin
end;

procedure TKMLIconStyle.SetIcon(const _Value: TKMLIcon);
begin
  FIcon.Free;
  FIcon := _Value;
  FIcon.Parent := Self;
end;

{  Icon}
constructor TKMLIcon.Create(par: TXML = nil);
begin
  inherited Create(par);
end;

destructor TKMLIcon.Destroy;
begin
  inherited;
end;

procedure TKMLIcon.AfterCreate;
begin
  inherited;
end;

procedure TKMLIcon.FromXML(node: IXMLNode);
var
  I: Integer;
  nodeTmp: IXMLNode;
begin
  try
    for I := 0 to node.ChildNodes.Count - 1 do
    begin
      nodeTmp := node.ChildNodes.Get(I);
      if nodeTmp.NodeName = 'href' then
      begin
        Fhref := nodeTmp.Text;
      end;
    end;
    for I := 0 to node.AttributeNodes.Count - 1 do
    begin
      nodeTmp := node.AttributeNodes.Get(I);
;
    end;
  except
    raise Exception.Create('Icon Read XML Error!' + node.Xml);
  end;
end;

function TKMLIcon.ToXML(par: IXMLNode; pt: string): IXMLNode;
var
  doc: IXMLDocument;
  node: IXMLNode;
  hrefTmp: IXMLNode;
  I: Integer;
begin
  try
    doc := par.OwnerDocument;
  if (pt = '') or (pt[1] = '#') then
    pt := 'Icon';
    node := doc.CreateNode(pt);
    par.ChildNodes.Add(node);
    hrefTmp := doc.CreateNode('href', ntElement);
    hrefTmp.NodeValue := Fhref;
    node.ChildNodes.Add(hrefTmp);
    Result := node;
  except
    raise Exception.Create('XML2Code Write XML Error!');
  end;
end;

procedure TKMLIcon.ToTree;
var
  I: Integer;
begin
  if not Assigned(TreeNodeShape) then
  begin
    Exit;
  end;
  TreeNodeShape.Clear;
  TreeNodeShape.Data := Self;
  TreeNodeShape.Text.Clear;
  TreeNodeShape.Text.Add('Icon');
  TreeNodeShape.AddChild('href:' + Fhref);
end;

procedure TKMLIcon.ToPopupMenu(Sender: TObject);
var
  pop: TPopupMenu;
begin
  if Assigned(Sender) and (Sender is TPopupMenu) then
  begin
    pop := TPopupMenu(Sender);
    pop.Items.Clear;
  end;
end;

procedure TKMLIcon.ToInspector;
var
  Names_Value: TStringList;
  Types_Value: TList<XMLTypes>;
  _Values_Value: TStringList;
begin
  if not Assigned(ins) then
    Exit;
  Names_Value := TStringList.Create;
  Types_Value := TList<XMLTypes>.Create;
  _Values_Value := TStringList.Create;
  Names_Value.Add('href');
  Types_Value.Add(xs_string);
  _Values_Value.Add(href);
  TXMLInspector(ins).SetData(Names_Value, _Values_Value, Types_Value, Self);
end;

procedure TKMLIcon.CopyFrom(source: TKMLIcon);
var
  I:Integer;
begin
  Fhref := source.href;
  Self.ToTree;
end;

procedure TKMLIcon.PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False);
var
  I: Integer;
begin
  if (items.Count = 1) and (items[0] is TKMLIcon) and (not isCut) then
  begin
    Self.CopyFrom(TKMLIcon(items[0]));
    Self.ToTree;
    Exit;
  end;
  for I := 0 to items.Count - 1 do
  begin
  end;
  Self.ToTree;
end;

procedure TKMLIcon.ChildDeleteEvent(del: TXMLTreeNode);
begin
end;
procedure TKMLIcon.SetXMLProperty(Index: Integer; _Value: String);
begin
  case index of
    0:
      begin
        href := _Value;
      end;
  end;
  ToTree;
end;

procedure TKMLIcon.Sethref(const _Value: String);
begin
  Fhref := _Value;
end;

{  LineStyle}
constructor TKMLLineStyle.Create(par: TXML = nil);
begin
  inherited Create(par);
end;

destructor TKMLLineStyle.Destroy;
begin
  inherited;
end;

procedure TKMLLineStyle.AfterCreate;
begin
  inherited;
end;

procedure TKMLLineStyle.FromXML(node: IXMLNode);
var
  I: Integer;
  nodeTmp: IXMLNode;
begin
  try
    FcolorExsit := False;
    FwidthExsit := False;
    for I := 0 to node.ChildNodes.Count - 1 do
    begin
      nodeTmp := node.ChildNodes.Get(I);
      if nodeTmp.NodeName = 'color' then
      begin
        Fcolor := nodeTmp.Text;
        FcolorExsit := True;
      end
      else if nodeTmp.NodeName = 'width' then
      begin
        Fwidth := StrToFloatDef(nodeTmp.Text, 0);;
        FwidthExsit := True;
      end;
    end;
    for I := 0 to node.AttributeNodes.Count - 1 do
    begin
      nodeTmp := node.AttributeNodes.Get(I);
;
    end;
  except
    raise Exception.Create('LineStyle Read XML Error!' + node.Xml);
  end;
end;

function TKMLLineStyle.ToXML(par: IXMLNode; pt: string): IXMLNode;
var
  doc: IXMLDocument;
  node: IXMLNode;
  colorTmp: IXMLNode;
  widthTmp: IXMLNode;
  I: Integer;
begin
  try
    doc := par.OwnerDocument;
  if (pt = '') or (pt[1] = '#') then
    pt := 'LineStyle';
    node := doc.CreateNode(pt);
    par.ChildNodes.Add(node);
    if FcolorExsit then
    begin
      colorTmp := doc.CreateNode('color', ntElement);
      colorTmp.NodeValue := Fcolor;
      node.ChildNodes.Add(colorTmp);
    end;
    if FwidthExsit then
    begin
      widthTmp := doc.CreateNode('width', ntElement);
      widthTmp.NodeValue := FloatToStr(Fwidth);
      node.ChildNodes.Add(widthTmp);
    end;
    Result := node;
  except
    raise Exception.Create('XML2Code Write XML Error!');
  end;
end;

procedure TKMLLineStyle.ToTree;
var
  I: Integer;
begin
  if not Assigned(TreeNodeShape) then
  begin
    Exit;
  end;
  TreeNodeShape.Clear;
  TreeNodeShape.Data := Self;
  TreeNodeShape.Text.Clear;
  TreeNodeShape.Text.Add('LineStyle');
  if colorExsit then
    TreeNodeShape.AddChild('color:' + Fcolor);
  if widthExsit then
    TreeNodeShape.AddChild('width:' + FloatToStr(Fwidth));
end;

procedure TKMLLineStyle.ToPopupMenu(Sender: TObject);
var
  pop: TPopupMenu;
  colorAddMenu: TMenuItem;
  widthAddMenu: TMenuItem;
begin
  if Assigned(Sender) and (Sender is TPopupMenu) then
  begin
    pop := TPopupMenu(Sender);
    pop.Items.Clear;
    colorAddMenu := TMenuItem.Create(pop);
    colorAddMenu.Caption := 'Add color';
    colorAddMenu.OnClick := AddcolorEvent;
    pop.Items.Add(colorAddMenu);
    widthAddMenu := TMenuItem.Create(pop);
    widthAddMenu.Caption := 'Add width';
    widthAddMenu.OnClick := AddwidthEvent;
    pop.Items.Add(widthAddMenu);
  end;
end;

procedure TKMLLineStyle.ToInspector;
var
  Names_Value: TStringList;
  Types_Value: TList<XMLTypes>;
  _Values_Value: TStringList;
begin
  if not Assigned(ins) then
    Exit;
  Names_Value := TStringList.Create;
  Types_Value := TList<XMLTypes>.Create;
  _Values_Value := TStringList.Create;
  Names_Value.Add('color');
  Types_Value.Add(xs_string);
  _Values_Value.Add(color);
  Names_Value.Add('width');
  Types_Value.Add(xs_double);
  _Values_Value.Add(FloatToStr(width));
  TXMLInspector(ins).SetData(Names_Value, _Values_Value, Types_Value, Self);
end;

procedure TKMLLineStyle.CopyFrom(source: TKMLLineStyle);
var
  I:Integer;
begin
  Fcolor := source.color;
  FcolorExsit := source.FcolorExsit;
  Fwidth := source.width;
  FwidthExsit := source.FwidthExsit;
  Self.ToTree;
end;

procedure TKMLLineStyle.PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False);
var
  I: Integer;
begin
  if (items.Count = 1) and (items[0] is TKMLLineStyle) and (not isCut) then
  begin
    Self.CopyFrom(TKMLLineStyle(items[0]));
    Self.ToTree;
    Exit;
  end;
  for I := 0 to items.Count - 1 do
  begin
  end;
  Self.ToTree;
end;

procedure TKMLLineStyle.ChildDeleteEvent(del: TXMLTreeNode);
begin
end;
procedure TKMLLineStyle.SetXMLProperty(Index: Integer; _Value: String);
begin
  case index of
    0:
      begin
        color := _Value;
      end;
    1:
      begin
        width := StrToFloatDef(_Value, 0);;
      end;
  end;
  ToTree;
end;

function TKMLLineStyle.Addcolor: String;
begin;
  Result := Fcolor;
  FcolorExsit := True;
end;

procedure TKMLLineStyle.Setcolor(const _Value: String);
begin
  FcolorExsit := True;
  Fcolor := _Value;
end;

procedure TKMLLineStyle.colorRemove;
begin
  if FcolorExsit then
  begin
    FcolorExsit := False;
  end;
end;

procedure TKMLLineStyle.AddcolorEvent(Sender: TObject);
begin
  Addcolor;
end;

function TKMLLineStyle.Addwidth: Double;
begin;
  Result := Fwidth;
  FwidthExsit := True;
end;

procedure TKMLLineStyle.Setwidth(const _Value: Double);
begin
  FwidthExsit := True;
  Fwidth := _Value;
end;

procedure TKMLLineStyle.widthRemove;
begin
  if FwidthExsit then
  begin
    FwidthExsit := False;
  end;
end;

procedure TKMLLineStyle.AddwidthEvent(Sender: TObject);
begin
  Addwidth;
end;

{  BalloonStyle}
constructor TKMLBalloonStyle.Create(par: TXML = nil);
begin
  inherited Create(par);
end;

destructor TKMLBalloonStyle.Destroy;
begin
  inherited;
end;

procedure TKMLBalloonStyle.AfterCreate;
begin
  inherited;
end;

procedure TKMLBalloonStyle.FromXML(node: IXMLNode);
var
  I: Integer;
  nodeTmp: IXMLNode;
begin
  try
    for I := 0 to node.ChildNodes.Count - 1 do
    begin
      nodeTmp := node.ChildNodes.Get(I);
      if nodeTmp.NodeName = '~text' then
      begin
        Ftext := nodeTmp.Text;
      end;
    end;
    for I := 0 to node.AttributeNodes.Count - 1 do
    begin
      nodeTmp := node.AttributeNodes.Get(I);
;
    end;
  except
    raise Exception.Create('BalloonStyle Read XML Error!' + node.Xml);
  end;
end;

function TKMLBalloonStyle.ToXML(par: IXMLNode; pt: string): IXMLNode;
var
  doc: IXMLDocument;
  node: IXMLNode;
  textTmp: IXMLNode;
  I: Integer;
begin
  try
    doc := par.OwnerDocument;
  if (pt = '') or (pt[1] = '#') then
    pt := 'BalloonStyle';
    node := doc.CreateNode(pt);
    par.ChildNodes.Add(node);
    textTmp := doc.CreateNode('text', ntCData);
    textTmp.NodeValue := Ftext;
    node.ChildNodes.Add(textTmp);
    Result := node;
  except
    raise Exception.Create('XML2Code Write XML Error!');
  end;
end;

procedure TKMLBalloonStyle.ToTree;
var
  I: Integer;
begin
  if not Assigned(TreeNodeShape) then
  begin
    Exit;
  end;
  TreeNodeShape.Clear;
  TreeNodeShape.Data := Self;
  TreeNodeShape.Text.Clear;
  TreeNodeShape.Text.Add('BalloonStyle');
  TreeNodeShape.AddChild('text:' + Ftext);
end;

procedure TKMLBalloonStyle.ToPopupMenu(Sender: TObject);
var
  pop: TPopupMenu;
begin
  if Assigned(Sender) and (Sender is TPopupMenu) then
  begin
    pop := TPopupMenu(Sender);
    pop.Items.Clear;
  end;
end;

procedure TKMLBalloonStyle.ToInspector;
var
  Names_Value: TStringList;
  Types_Value: TList<XMLTypes>;
  _Values_Value: TStringList;
begin
  if not Assigned(ins) then
    Exit;
  Names_Value := TStringList.Create;
  Types_Value := TList<XMLTypes>.Create;
  _Values_Value := TStringList.Create;
  Names_Value.Add('text');
  Types_Value.Add(xs_string);
  _Values_Value.Add(text);
  TXMLInspector(ins).SetData(Names_Value, _Values_Value, Types_Value, Self);
end;

procedure TKMLBalloonStyle.CopyFrom(source: TKMLBalloonStyle);
var
  I:Integer;
begin
  Ftext := source.text;
  Self.ToTree;
end;

procedure TKMLBalloonStyle.PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False);
var
  I: Integer;
begin
  if (items.Count = 1) and (items[0] is TKMLBalloonStyle) and (not isCut) then
  begin
    Self.CopyFrom(TKMLBalloonStyle(items[0]));
    Self.ToTree;
    Exit;
  end;
  for I := 0 to items.Count - 1 do
  begin
  end;
  Self.ToTree;
end;

procedure TKMLBalloonStyle.ChildDeleteEvent(del: TXMLTreeNode);
begin
end;
procedure TKMLBalloonStyle.SetXMLProperty(Index: Integer; _Value: String);
begin
  case index of
    0:
      begin
        text := _Value;
      end;
  end;
  ToTree;
end;

procedure TKMLBalloonStyle.Settext(const _Value: String);
begin
  Ftext := _Value;
end;

{  StyleMap}
constructor TKMLStyleMap.Create(par: TXML = nil);
begin
  inherited Create(par);
  FPairs := TList<TKMLPair>.Create;
end;

destructor TKMLStyleMap.Destroy;
begin
  PairClear;
  FPairs.Free;
  inherited;
end;

procedure TKMLStyleMap.AfterCreate;
begin
  inherited;
  FPairs := TList<TKMLPair>.Create;
end;

procedure TKMLStyleMap.FromXML(node: IXMLNode);
var
  I: Integer;
  nodeTmp: IXMLNode;
  PairTmp: TKMLPair;
begin
  try
    PairClear;
    for I := 0 to node.ChildNodes.Count - 1 do
    begin
      nodeTmp := node.ChildNodes.Get(I);
      if nodeTmp.NodeName = 'Pair' then
      begin
        PairTmp := TKMLPair.Create(Self);
        PairTmp.FromXML(nodeTmp);
        FPairs.Add(PairTmp);
      end;
    end;
    for I := 0 to node.AttributeNodes.Count - 1 do
    begin
      nodeTmp := node.AttributeNodes.Get(I);
      if nodeTmp.NodeName = 'id' then
      begin
        FID := nodeTmp.Text;
      end;
    end;
  except
    raise Exception.Create('StyleMap Read XML Error!' + node.Xml);
  end;
end;

function TKMLStyleMap.ToXML(par: IXMLNode; pt: string): IXMLNode;
var
  doc: IXMLDocument;
  node: IXMLNode;
  IDTmp: IXMLNode;
  I: Integer;
begin
  try
    doc := par.OwnerDocument;
  if (pt = '') or (pt[1] = '#') then
    pt := 'StyleMap';
    node := doc.CreateNode(pt);
    par.ChildNodes.Add(node);
    for I := 0 to FPairs.Count - 1 do
       FPairs.Items[I].ToXML(node, 'Pair');
    IDTmp := doc.CreateNode('id', ntAttribute);
    IDTmp.NodeValue := FID;
    node.AttributeNodes.Add(IDTmp);
    Result := node;
  except
    raise Exception.Create('XML2Code Write XML Error!');
  end;
end;

procedure TKMLStyleMap.ToTree;
var
  I: Integer;
begin
  if not Assigned(TreeNodeShape) then
  begin
    Exit;
  end;
  TreeNodeShape.Clear;
  TreeNodeShape.Data := Self;
  TreeNodeShape.Text.Clear;
  TreeNodeShape.Text.Add('StyleMap');
  for I := 0 to PairCount - 1 do
  begin
    Pairs[I].TreeNodeShape := TreeNodeShape.AddChildObject('Pair', Pair[I]);
    Pair[I].ToTree;
  end;
  TreeNodeShape.AddChild('ID:' + FID);
end;

procedure TKMLStyleMap.ToPopupMenu(Sender: TObject);
var
  pop: TPopupMenu;
  PairAddMenu: TMenuItem;
begin
  if Assigned(Sender) and (Sender is TPopupMenu) then
  begin
    pop := TPopupMenu(Sender);
    pop.Items.Clear;
    PairAddMenu := TMenuItem.Create(pop);
    PairAddMenu.Caption := 'Add Pair';
    PairAddMenu.OnClick := AddPairEvent;
    pop.Items.Add(PairAddMenu);
  end;
end;

procedure TKMLStyleMap.ToInspector;
var
  Names_Value: TStringList;
  Types_Value: TList<XMLTypes>;
  _Values_Value: TStringList;
begin
  if not Assigned(ins) then
    Exit;
  Names_Value := TStringList.Create;
  Types_Value := TList<XMLTypes>.Create;
  _Values_Value := TStringList.Create;
  Names_Value.Add('ID');
  Types_Value.Add(xs_string);
  _Values_Value.Add(ID);
  TXMLInspector(ins).SetData(Names_Value, _Values_Value, Types_Value, Self);
end;

procedure TKMLStyleMap.CopyFrom(source: TKMLStyleMap);
var
  I:Integer;
begin
    PairClear;
  for I := 0 to PairCount - 1 do
  begin
    AddPair.CopyFrom(source.Pair[I]);
  end;
  FID := source.ID;
  Self.ToTree;
end;

procedure TKMLStyleMap.PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False);
var
  I: Integer;
  tmpPair: TKMLPair;
begin
  if (items.Count = 1) and (items[0] is TKMLStyleMap) and (not isCut) then
  begin
    Self.CopyFrom(TKMLStyleMap(items[0]));
    Self.ToTree;
    Exit;
  end;
  for I := 0 to items.Count - 1 do
  begin
    if items[I] is TKMLPair then
    begin
      tmpPair := TKMLPair(items[I]);
      if isCut then
      begin
        TKMLStyleMap(tmpPair.Parent).Pairs.Remove(tmpPair);
        Self.Pairs.Add(tmpPair);
        tmpPair.Parent := Self;
        tmpPair.TreeNodeShape.Parent := Self.TreeNodeShape;
      end
      else
      begin
        AddPair.CopyFrom(tmpPair);
      end;
    end;
  end;
  Self.ToTree;
end;

procedure TKMLStyleMap.ChildDeleteEvent(del: TXMLTreeNode);
begin
  if del is TKMLPair then
  begin
    Self.RemovePair(TKMLPair(del));
  end;
end;
procedure TKMLStyleMap.SetXMLProperty(Index: Integer; _Value: String);
begin
  case index of
    0:
      begin
        ID := _Value;
      end;
  end;
  ToTree;
end;

function TKMLStyleMap.AddPair: TKMLPair;
var
  Pairtmp: TKMLPair;
begin;
  Pairtmp := TKMLPair.Create(Self);
  FPairs.Add(Pairtmp);
  Result := Pairtmp;
end;

procedure TKMLStyleMap.SetPairs(const _Value: TList<TKMLPair>);
begin
  PairClear;
  FPairs := _Value;
end;

procedure TKMLStyleMap.PairClear;
begin
  while FPairs.Count > 0 do
  begin
    FPairs.Items[0].Free;
    FPairs.Delete(0);
  end;
end;

function TKMLStyleMap.PairCount: Integer;
begin
  Result := FPairs.Count;
end;

function TKMLStyleMap.GetPair(Index: Integer): TKMLPair;
begin
  Result := FPairs[Index];
end;

procedure TKMLStyleMap.SetPair(Index: Integer;
  const _Value: TKMLPair);
begin
  _Value.Parent := Self;
  FPairs[Index].Free;
  FPairs[Index] := _Value;
end;

procedure TKMLStyleMap.RemovePair(_Value: TKMLPair);
begin
  FPairs.Remove(_Value);
  _Value.Free;
end;

procedure TKMLStyleMap.DeletePair(Index: Integer);
begin
  FPairs.Items[Index].Free;
  FPairs.Delete(Index);
end;

procedure TKMLStyleMap.AddPairEvent(Sender: TObject);
var
  tmp: TKMLPair;
begin
  tmp := AddPair;
  tmp.TreeNodeShape := TreeNodeShape.AddChildObject('Pair', tmp);
  tmp.ToTree;
end;

procedure TKMLStyleMap.SetID(const _Value: String);
begin
  FID := _Value;
end;

{  ScreenOverlay}
constructor TKMLScreenOverlay.Create(par: TXML = nil);
begin
  inherited Create(par);
end;

destructor TKMLScreenOverlay.Destroy;
begin
  if FIconExsit then
    FIcon.Free;
  if FOverlayXYExsit then
    FOverlayXY.Free;
  if FScreenXYExsit then
    FScreenXY.Free;
  if FRotationXYExsit then
    FRotationXY.Free;
  if FSizeExsit then
    FSize.Free;
  inherited;
end;

procedure TKMLScreenOverlay.AfterCreate;
begin
  inherited;
end;

procedure TKMLScreenOverlay.FromXML(node: IXMLNode);
var
  I: Integer;
  nodeTmp: IXMLNode;
begin
  try
    FNameExsit := False;
    FVisibilityExsit := False;
    FDescriptionExsit := False;
    FIconExsit := False;
    FOverlayXYExsit := False;
    FScreenXYExsit := False;
    FRotationXYExsit := False;
    FSizeExsit := False;
    for I := 0 to node.ChildNodes.Count - 1 do
    begin
      nodeTmp := node.ChildNodes.Get(I);
      if nodeTmp.NodeName = 'name' then
      begin
        FName := nodeTmp.Text;
        FNameExsit := True;
      end
      else if nodeTmp.NodeName = 'visibility' then
      begin
        FVisibility := StrToIntDef(nodeTmp.Text, 0);;
        FVisibilityExsit := True;
      end
      else if nodeTmp.NodeName = 'description' then
      begin
        FDescription := nodeTmp.Text;
        FDescriptionExsit := True;
      end
      else if nodeTmp.NodeName = 'Icon' then
      begin
        FIcon := TKMLIcon.Create(Self);
        FIcon.FromXML(nodeTmp);
        FIconExsit := True;
      end
      else if nodeTmp.NodeName = 'overlayXY' then
      begin
        FOverlayXY := TKMLSize.Create(Self);
        FOverlayXY.FromXML(nodeTmp);
        FOverlayXYExsit := True;
      end
      else if nodeTmp.NodeName = 'screenXY' then
      begin
        FScreenXY := TKMLSize.Create(Self);
        FScreenXY.FromXML(nodeTmp);
        FScreenXYExsit := True;
      end
      else if nodeTmp.NodeName = 'rotationXY' then
      begin
        FRotationXY := TKMLSize.Create(Self);
        FRotationXY.FromXML(nodeTmp);
        FRotationXYExsit := True;
      end
      else if nodeTmp.NodeName = 'size' then
      begin
        FSize := TKMLSize.Create(Self);
        FSize.FromXML(nodeTmp);
        FSizeExsit := True;
      end;
    end;
    for I := 0 to node.AttributeNodes.Count - 1 do
    begin
      nodeTmp := node.AttributeNodes.Get(I);
;
    end;
  except
    raise Exception.Create('ScreenOverlay Read XML Error!' + node.Xml);
  end;
end;

function TKMLScreenOverlay.ToXML(par: IXMLNode; pt: string): IXMLNode;
var
  doc: IXMLDocument;
  node: IXMLNode;
  NameTmp: IXMLNode;
  VisibilityTmp: IXMLNode;
  DescriptionTmp: IXMLNode;
  I: Integer;
begin
  try
    doc := par.OwnerDocument;
  if (pt = '') or (pt[1] = '#') then
    pt := 'ScreenOverlay';
    node := doc.CreateNode(pt);
    par.ChildNodes.Add(node);
    if FNameExsit then
    begin
      NameTmp := doc.CreateNode('name', ntElement);
      NameTmp.NodeValue := FName;
      node.ChildNodes.Add(NameTmp);
    end;
    if FVisibilityExsit then
    begin
      VisibilityTmp := doc.CreateNode('visibility', ntElement);
      VisibilityTmp.NodeValue := IntToStr(FVisibility);
      node.ChildNodes.Add(VisibilityTmp);
    end;
    if FDescriptionExsit then
    begin
      DescriptionTmp := doc.CreateNode('description', ntElement);
      DescriptionTmp.NodeValue := FDescription;
      node.ChildNodes.Add(DescriptionTmp);
    end;
    if FIconExsit then
      FIcon.ToXML(node, 'Icon');
    if FOverlayXYExsit then
      FOverlayXY.ToXML(node, 'overlayXY');
    if FScreenXYExsit then
      FScreenXY.ToXML(node, 'screenXY');
    if FRotationXYExsit then
      FRotationXY.ToXML(node, 'rotationXY');
    if FSizeExsit then
      FSize.ToXML(node, 'size');
    Result := node;
  except
    raise Exception.Create('XML2Code Write XML Error!');
  end;
end;

procedure TKMLScreenOverlay.ToTree;
var
  I: Integer;
begin
  if not Assigned(TreeNodeShape) then
  begin
    Exit;
  end;
  TreeNodeShape.Clear;
  TreeNodeShape.Data := Self;
  TreeNodeShape.Text.Clear;
  TreeNodeShape.Text.Add('ScreenOverlay');
  if NameExsit then
    TreeNodeShape.AddChild('Name:' + FName);
  if VisibilityExsit then
    TreeNodeShape.AddChild('Visibility:' + IntToStr(FVisibility));
  if DescriptionExsit then
    TreeNodeShape.AddChild('Description:' + FDescription);
  if IconExsit then
  begin
    Icon.TreeNodeShape := TreeNodeShape.AddChildObject('Icon', Icon);
    Icon.ToTree;
  end;
  if OverlayXYExsit then
  begin
    OverlayXY.TreeNodeShape := TreeNodeShape.AddChildObject('OverlayXY', OverlayXY);
    OverlayXY.ToTree;
  end;
  if ScreenXYExsit then
  begin
    ScreenXY.TreeNodeShape := TreeNodeShape.AddChildObject('ScreenXY', ScreenXY);
    ScreenXY.ToTree;
  end;
  if RotationXYExsit then
  begin
    RotationXY.TreeNodeShape := TreeNodeShape.AddChildObject('RotationXY', RotationXY);
    RotationXY.ToTree;
  end;
  if SizeExsit then
  begin
    Size.TreeNodeShape := TreeNodeShape.AddChildObject('Size', Size);
    Size.ToTree;
  end;
end;

procedure TKMLScreenOverlay.ToPopupMenu(Sender: TObject);
var
  pop: TPopupMenu;
  NameAddMenu: TMenuItem;
  VisibilityAddMenu: TMenuItem;
  DescriptionAddMenu: TMenuItem;
  IconAddMenu: TMenuItem;
  OverlayXYAddMenu: TMenuItem;
  ScreenXYAddMenu: TMenuItem;
  RotationXYAddMenu: TMenuItem;
  SizeAddMenu: TMenuItem;
begin
  if Assigned(Sender) and (Sender is TPopupMenu) then
  begin
    pop := TPopupMenu(Sender);
    pop.Items.Clear;
    NameAddMenu := TMenuItem.Create(pop);
    NameAddMenu.Caption := 'Add Name';
    NameAddMenu.OnClick := AddNameEvent;
    pop.Items.Add(NameAddMenu);
    VisibilityAddMenu := TMenuItem.Create(pop);
    VisibilityAddMenu.Caption := 'Add Visibility';
    VisibilityAddMenu.OnClick := AddVisibilityEvent;
    pop.Items.Add(VisibilityAddMenu);
    DescriptionAddMenu := TMenuItem.Create(pop);
    DescriptionAddMenu.Caption := 'Add Description';
    DescriptionAddMenu.OnClick := AddDescriptionEvent;
    pop.Items.Add(DescriptionAddMenu);
    IconAddMenu := TMenuItem.Create(pop);
    IconAddMenu.Caption := 'Add Icon';
    IconAddMenu.OnClick := AddIconEvent;
    pop.Items.Add(IconAddMenu);
    OverlayXYAddMenu := TMenuItem.Create(pop);
    OverlayXYAddMenu.Caption := 'Add OverlayXY';
    OverlayXYAddMenu.OnClick := AddOverlayXYEvent;
    pop.Items.Add(OverlayXYAddMenu);
    ScreenXYAddMenu := TMenuItem.Create(pop);
    ScreenXYAddMenu.Caption := 'Add ScreenXY';
    ScreenXYAddMenu.OnClick := AddScreenXYEvent;
    pop.Items.Add(ScreenXYAddMenu);
    RotationXYAddMenu := TMenuItem.Create(pop);
    RotationXYAddMenu.Caption := 'Add RotationXY';
    RotationXYAddMenu.OnClick := AddRotationXYEvent;
    pop.Items.Add(RotationXYAddMenu);
    SizeAddMenu := TMenuItem.Create(pop);
    SizeAddMenu.Caption := 'Add Size';
    SizeAddMenu.OnClick := AddSizeEvent;
    pop.Items.Add(SizeAddMenu);
  end;
end;

procedure TKMLScreenOverlay.ToInspector;
var
  Names_Value: TStringList;
  Types_Value: TList<XMLTypes>;
  _Values_Value: TStringList;
begin
  if not Assigned(ins) then
    Exit;
  Names_Value := TStringList.Create;
  Types_Value := TList<XMLTypes>.Create;
  _Values_Value := TStringList.Create;
  Names_Value.Add('Name');
  Types_Value.Add(xs_string);
  _Values_Value.Add(Name);
  Names_Value.Add('Visibility');
  Types_Value.Add(xs_integer);
  _Values_Value.Add(IntToStr(Visibility));
  Names_Value.Add('Description');
  Types_Value.Add(xs_string);
  _Values_Value.Add(Description);
  TXMLInspector(ins).SetData(Names_Value, _Values_Value, Types_Value, Self);
end;

procedure TKMLScreenOverlay.CopyFrom(source: TKMLScreenOverlay);
var
  I:Integer;
begin
  FName := source.Name;
  FNameExsit := source.FNameExsit;
  FVisibility := source.Visibility;
  FVisibilityExsit := source.FVisibilityExsit;
  FDescription := source.Description;
  FDescriptionExsit := source.FDescriptionExsit;
  FIconExsit := source.FIconExsit;
  if source.FIconExsit then
  begin
    AddIcon.CopyFrom(source.Icon);
  end;
  FOverlayXYExsit := source.FOverlayXYExsit;
  if source.FOverlayXYExsit then
  begin
    AddOverlayXY.CopyFrom(source.OverlayXY);
  end;
  FScreenXYExsit := source.FScreenXYExsit;
  if source.FScreenXYExsit then
  begin
    AddScreenXY.CopyFrom(source.ScreenXY);
  end;
  FRotationXYExsit := source.FRotationXYExsit;
  if source.FRotationXYExsit then
  begin
    AddRotationXY.CopyFrom(source.RotationXY);
  end;
  FSizeExsit := source.FSizeExsit;
  if source.FSizeExsit then
  begin
    AddSize.CopyFrom(source.Size);
  end;
  Self.ToTree;
end;

procedure TKMLScreenOverlay.PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False);
var
  I: Integer;
begin
  if (items.Count = 1) and (items[0] is TKMLScreenOverlay) and (not isCut) then
  begin
    Self.CopyFrom(TKMLScreenOverlay(items[0]));
    Self.ToTree;
    Exit;
  end;
  for I := 0 to items.Count - 1 do
  begin
  end;
  Self.ToTree;
end;

procedure TKMLScreenOverlay.ChildDeleteEvent(del: TXMLTreeNode);
begin
end;
procedure TKMLScreenOverlay.SetXMLProperty(Index: Integer; _Value: String);
begin
  case index of
    0:
      begin
        Name := _Value;
      end;
    1:
      begin
        Visibility := StrToIntDef(_Value, 0);;
      end;
    2:
      begin
        Description := _Value;
      end;
  end;
  ToTree;
end;

function TKMLScreenOverlay.AddName: String;
begin;
  Result := FName;
  FNameExsit := True;
end;

procedure TKMLScreenOverlay.SetName(const _Value: String);
begin
  FNameExsit := True;
  FName := _Value;
end;

procedure TKMLScreenOverlay.NameRemove;
begin
  if FNameExsit then
  begin
    FNameExsit := False;
  end;
end;

procedure TKMLScreenOverlay.AddNameEvent(Sender: TObject);
begin
  AddName;
end;

function TKMLScreenOverlay.AddVisibility: Integer;
begin;
  Result := FVisibility;
  FVisibilityExsit := True;
end;

procedure TKMLScreenOverlay.SetVisibility(const _Value: Integer);
begin
  FVisibilityExsit := True;
  FVisibility := _Value;
end;

procedure TKMLScreenOverlay.VisibilityRemove;
begin
  if FVisibilityExsit then
  begin
    FVisibilityExsit := False;
  end;
end;

procedure TKMLScreenOverlay.AddVisibilityEvent(Sender: TObject);
begin
  AddVisibility;
end;

function TKMLScreenOverlay.AddDescription: String;
begin;
  Result := FDescription;
  FDescriptionExsit := True;
end;

procedure TKMLScreenOverlay.SetDescription(const _Value: String);
begin
  FDescriptionExsit := True;
  FDescription := _Value;
end;

procedure TKMLScreenOverlay.DescriptionRemove;
begin
  if FDescriptionExsit then
  begin
    FDescriptionExsit := False;
  end;
end;

procedure TKMLScreenOverlay.AddDescriptionEvent(Sender: TObject);
begin
  AddDescription;
end;

function TKMLScreenOverlay.AddIcon: TKMLIcon;
begin;
  if not FIconExsit then
    FIcon := TKMLIcon.Create(Self);
  Result := FIcon;
  FIconExsit := True;
end;

procedure TKMLScreenOverlay.SetIcon(const _Value: TKMLIcon);
begin
  if FIconExsit then
    FIcon.Free;
  FIconExsit := True;
  FIcon := _Value;
  FIcon.Parent := Self;
end;

procedure TKMLScreenOverlay.IconRemove;
begin
  if FIconExsit then
  begin
    FIcon.Free;
    FIconExsit := False;
  end;
end;

procedure TKMLScreenOverlay.AddIconEvent(Sender: TObject);
begin
  AddIcon;
  FIcon.ToTree;
end;

function TKMLScreenOverlay.AddOverlayXY: TKMLSize;
begin;
  if not FOverlayXYExsit then
    FOverlayXY := TKMLSize.Create(Self);
  Result := FOverlayXY;
  FOverlayXYExsit := True;
end;

procedure TKMLScreenOverlay.SetOverlayXY(const _Value: TKMLSize);
begin
  if FOverlayXYExsit then
    FOverlayXY.Free;
  FOverlayXYExsit := True;
  FOverlayXY := _Value;
  FOverlayXY.Parent := Self;
end;

procedure TKMLScreenOverlay.OverlayXYRemove;
begin
  if FOverlayXYExsit then
  begin
    FOverlayXY.Free;
    FOverlayXYExsit := False;
  end;
end;

procedure TKMLScreenOverlay.AddOverlayXYEvent(Sender: TObject);
begin
  AddOverlayXY;
  FOverlayXY.ToTree;
end;

function TKMLScreenOverlay.AddScreenXY: TKMLSize;
begin;
  if not FScreenXYExsit then
    FScreenXY := TKMLSize.Create(Self);
  Result := FScreenXY;
  FScreenXYExsit := True;
end;

procedure TKMLScreenOverlay.SetScreenXY(const _Value: TKMLSize);
begin
  if FScreenXYExsit then
    FScreenXY.Free;
  FScreenXYExsit := True;
  FScreenXY := _Value;
  FScreenXY.Parent := Self;
end;

procedure TKMLScreenOverlay.ScreenXYRemove;
begin
  if FScreenXYExsit then
  begin
    FScreenXY.Free;
    FScreenXYExsit := False;
  end;
end;

procedure TKMLScreenOverlay.AddScreenXYEvent(Sender: TObject);
begin
  AddScreenXY;
  FScreenXY.ToTree;
end;

function TKMLScreenOverlay.AddRotationXY: TKMLSize;
begin;
  if not FRotationXYExsit then
    FRotationXY := TKMLSize.Create(Self);
  Result := FRotationXY;
  FRotationXYExsit := True;
end;

procedure TKMLScreenOverlay.SetRotationXY(const _Value: TKMLSize);
begin
  if FRotationXYExsit then
    FRotationXY.Free;
  FRotationXYExsit := True;
  FRotationXY := _Value;
  FRotationXY.Parent := Self;
end;

procedure TKMLScreenOverlay.RotationXYRemove;
begin
  if FRotationXYExsit then
  begin
    FRotationXY.Free;
    FRotationXYExsit := False;
  end;
end;

procedure TKMLScreenOverlay.AddRotationXYEvent(Sender: TObject);
begin
  AddRotationXY;
  FRotationXY.ToTree;
end;

function TKMLScreenOverlay.AddSize: TKMLSize;
begin;
  if not FSizeExsit then
    FSize := TKMLSize.Create(Self);
  Result := FSize;
  FSizeExsit := True;
end;

procedure TKMLScreenOverlay.SetSize(const _Value: TKMLSize);
begin
  if FSizeExsit then
    FSize.Free;
  FSizeExsit := True;
  FSize := _Value;
  FSize.Parent := Self;
end;

procedure TKMLScreenOverlay.SizeRemove;
begin
  if FSizeExsit then
  begin
    FSize.Free;
    FSizeExsit := False;
  end;
end;

procedure TKMLScreenOverlay.AddSizeEvent(Sender: TObject);
begin
  AddSize;
  FSize.ToTree;
end;

{  Pair}
constructor TKMLPair.Create(par: TXML = nil);
begin
  inherited Create(par);
end;

destructor TKMLPair.Destroy;
begin
  inherited;
end;

procedure TKMLPair.AfterCreate;
begin
  inherited;
end;

procedure TKMLPair.FromXML(node: IXMLNode);
var
  I: Integer;
  nodeTmp: IXMLNode;
begin
  try
    FKeyExsit := False;
    FStyleUrlExsit := False;
    for I := 0 to node.ChildNodes.Count - 1 do
    begin
      nodeTmp := node.ChildNodes.Get(I);
      if nodeTmp.NodeName = 'key' then
      begin
        FKey := nodeTmp.Text;
        FKeyExsit := True;
      end
      else if nodeTmp.NodeName = 'styleUrl' then
      begin
        FStyleUrl := nodeTmp.Text;
        FStyleUrlExsit := True;
      end;
    end;
    for I := 0 to node.AttributeNodes.Count - 1 do
    begin
      nodeTmp := node.AttributeNodes.Get(I);
;
    end;
  except
    raise Exception.Create('Pair Read XML Error!' + node.Xml);
  end;
end;

function TKMLPair.ToXML(par: IXMLNode; pt: string): IXMLNode;
var
  doc: IXMLDocument;
  node: IXMLNode;
  KeyTmp: IXMLNode;
  StyleUrlTmp: IXMLNode;
  I: Integer;
begin
  try
    doc := par.OwnerDocument;
  if (pt = '') or (pt[1] = '#') then
    pt := 'Pair';
    node := doc.CreateNode(pt);
    par.ChildNodes.Add(node);
    if FKeyExsit then
    begin
      KeyTmp := doc.CreateNode('key', ntElement);
      KeyTmp.NodeValue := FKey;
      node.ChildNodes.Add(KeyTmp);
    end;
    if FStyleUrlExsit then
    begin
      StyleUrlTmp := doc.CreateNode('styleUrl', ntElement);
      StyleUrlTmp.NodeValue := FStyleUrl;
      node.ChildNodes.Add(StyleUrlTmp);
    end;
    Result := node;
  except
    raise Exception.Create('XML2Code Write XML Error!');
  end;
end;

procedure TKMLPair.ToTree;
var
  I: Integer;
begin
  if not Assigned(TreeNodeShape) then
  begin
    Exit;
  end;
  TreeNodeShape.Clear;
  TreeNodeShape.Data := Self;
  TreeNodeShape.Text.Clear;
  TreeNodeShape.Text.Add('Pair');
  if KeyExsit then
    TreeNodeShape.AddChild('Key:' + FKey);
  if StyleUrlExsit then
    TreeNodeShape.AddChild('StyleUrl:' + FStyleUrl);
end;

procedure TKMLPair.ToPopupMenu(Sender: TObject);
var
  pop: TPopupMenu;
  KeyAddMenu: TMenuItem;
  StyleUrlAddMenu: TMenuItem;
begin
  if Assigned(Sender) and (Sender is TPopupMenu) then
  begin
    pop := TPopupMenu(Sender);
    pop.Items.Clear;
    KeyAddMenu := TMenuItem.Create(pop);
    KeyAddMenu.Caption := 'Add Key';
    KeyAddMenu.OnClick := AddKeyEvent;
    pop.Items.Add(KeyAddMenu);
    StyleUrlAddMenu := TMenuItem.Create(pop);
    StyleUrlAddMenu.Caption := 'Add StyleUrl';
    StyleUrlAddMenu.OnClick := AddStyleUrlEvent;
    pop.Items.Add(StyleUrlAddMenu);
  end;
end;

procedure TKMLPair.ToInspector;
var
  Names_Value: TStringList;
  Types_Value: TList<XMLTypes>;
  _Values_Value: TStringList;
begin
  if not Assigned(ins) then
    Exit;
  Names_Value := TStringList.Create;
  Types_Value := TList<XMLTypes>.Create;
  _Values_Value := TStringList.Create;
  Names_Value.Add('Key');
  Types_Value.Add(xs_string);
  _Values_Value.Add(Key);
  Names_Value.Add('StyleUrl');
  Types_Value.Add(xs_string);
  _Values_Value.Add(StyleUrl);
  TXMLInspector(ins).SetData(Names_Value, _Values_Value, Types_Value, Self);
end;

procedure TKMLPair.CopyFrom(source: TKMLPair);
var
  I:Integer;
begin
  FKey := source.Key;
  FKeyExsit := source.FKeyExsit;
  FStyleUrl := source.StyleUrl;
  FStyleUrlExsit := source.FStyleUrlExsit;
  Self.ToTree;
end;

procedure TKMLPair.PasteToEvent(items: TList<TXMLTreeNode>; const isCut: Boolean = False);
var
  I: Integer;
begin
  if (items.Count = 1) and (items[0] is TKMLPair) and (not isCut) then
  begin
    Self.CopyFrom(TKMLPair(items[0]));
    Self.ToTree;
    Exit;
  end;
  for I := 0 to items.Count - 1 do
  begin
  end;
  Self.ToTree;
end;

procedure TKMLPair.ChildDeleteEvent(del: TXMLTreeNode);
begin
end;
procedure TKMLPair.SetXMLProperty(Index: Integer; _Value: String);
begin
  case index of
    0:
      begin
        Key := _Value;
      end;
    1:
      begin
        StyleUrl := _Value;
      end;
  end;
  ToTree;
end;

function TKMLPair.AddKey: String;
begin;
  Result := FKey;
  FKeyExsit := True;
end;

procedure TKMLPair.SetKey(const _Value: String);
begin
  FKeyExsit := True;
  FKey := _Value;
end;

procedure TKMLPair.KeyRemove;
begin
  if FKeyExsit then
  begin
    FKeyExsit := False;
  end;
end;

procedure TKMLPair.AddKeyEvent(Sender: TObject);
begin
  AddKey;
end;

function TKMLPair.AddStyleUrl: String;
begin;
  Result := FStyleUrl;
  FStyleUrlExsit := True;
end;

procedure TKMLPair.SetStyleUrl(const _Value: String);
begin
  FStyleUrlExsit := True;
  FStyleUrl := _Value;
end;

procedure TKMLPair.StyleUrlRemove;
begin
  if FStyleUrlExsit then
  begin
    FStyleUrlExsit := False;
  end;
end;

procedure TKMLPair.AddStyleUrlEvent(Sender: TObject);
begin
  AddStyleUrl;
end;



end.
